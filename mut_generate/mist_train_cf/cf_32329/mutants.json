{
  "task_id": "cf_32329",
  "entry_point": "largest_product_of_three_regions",
  "mutant_count": 103,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "size = 0",
      "mutated_line": "size = 1",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 1\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "size = 0",
      "mutated_line": "size = -1",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = -1\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "size = 0",
      "mutated_line": "size = 1",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 1\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "size += 1",
      "mutated_line": "size -= 1",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size -= 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) > 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) > 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) < 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) < 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) == 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) == 3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] / ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] / ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] + ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] + ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return (ans[-1] * ans[-2]) ** ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return (ans[-1] * ans[-2]) ** ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 1",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else -1",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 1",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(2, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(2, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(-1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, -1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, -1), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (+1, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (+1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, -1), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, -1), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (-1, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (-1, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 2), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 2), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, -1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, -1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (-1, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (-1, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, +1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, +1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "size += 1",
      "mutated_line": "size += 2",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 2\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "size += 1",
      "mutated_line": "size += 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 0\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "size += 1",
      "mutated_line": "size += 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 0\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "size += 1",
      "mutated_line": "size += -1",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += -1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if grid[r][c] == 0 and (r, c) not in checked:",
      "mutated_line": "if grid[r][c] == 0 or (r, c) not in checked:",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 or (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 4 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 4 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 2 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 2 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 0 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 0 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 1 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 1 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= -3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= -3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] / ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] / ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return (ans[-1] + ans[-2]) * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return (ans[-1] + ans[-2]) * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] ** ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] ** ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "rlen, clen = len(grid), len(grid[0])",
      "mutated_line": "(rlen, clen) = (len(grid), len(grid[1]))",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[1]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "rlen, clen = len(grid), len(grid[0])",
      "mutated_line": "(rlen, clen) = (len(grid), len(grid[-1]))",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[-1]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "rlen, clen = len(grid), len(grid[0])",
      "mutated_line": "(rlen, clen) = (len(grid), len(grid[1]))",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[1]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-2, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-2, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (--1, 0), (0, 1), (0, -1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (--1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -2)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -2)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, --1)]",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, --1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ar = nr + ar",
      "mutated_line": "ar = nr - ar",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr - ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ar = nr + ar",
      "mutated_line": "ar = nr * ar",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr * ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ac = nc + ac",
      "mutated_line": "ac = nc - ac",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc - ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ac = nc + ac",
      "mutated_line": "ac = nc * ac",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc * ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked or 0 <= ar < rlen or 0 <= ac < clen or (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked or 0 <= ar < rlen or 0 <= ac < clen or (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if grid[r][c] == 0 and (r, c) not in checked:",
      "mutated_line": "if grid[r][c] != 0 and (r, c) not in checked:",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] != 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if grid[r][c] == 0 and (r, c) not in checked:",
      "mutated_line": "if grid[r][c] == 0 and (r, c) in checked:",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[+3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[+3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 < ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 < ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 > ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 > ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 == ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 == ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (0 < ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 < ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (0 > ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 > ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (0 == ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 == ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] != 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] != 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if grid[r][c] == 0 and (r, c) not in checked:",
      "mutated_line": "if grid[r][c] == 1 and (r, c) not in checked:",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 1 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if grid[r][c] == 0 and (r, c) not in checked:",
      "mutated_line": "if grid[r][c] == -1 and (r, c) not in checked:",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == -1 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if grid[r][c] == 0 and (r, c) not in checked:",
      "mutated_line": "if grid[r][c] == 1 and (r, c) not in checked:",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 1 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[+1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[+1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[+2] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[+2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-4] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-4] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-2] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-2] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-0] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-0] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[-1] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-1] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-2] * ans[--3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[--3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 1 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 1 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and -1 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and -1 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 1 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 1 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (1 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (1 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (-1 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (-1 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (1 <= ac < clen) and (grid[ar][ac] == 0):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (1 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 1):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 1):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == -1):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == -1):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (ar, ac) not in checked and (0 <= ar < rlen) and (0 <= ac < clen) and (grid[ar][ac] == 0):",
      "mutated_line": "if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 1):",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 1):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-2] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-2] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-0] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-0] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-0] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-0] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[--1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[--1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-3] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-3] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-1] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-1] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-0] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-0] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[-1] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[-1] * ans[-3] if len(ans) >= 3 else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return ans[-1] * ans[-2] * ans[-3] if len(ans) >= 3 else 0",
      "mutated_line": "return ans[-1] * ans[--2] * ans[-3] if len(ans) >= 3 else 0",
      "code": "def largest_product_of_three_regions(grid):\n    (rlen, clen) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    checked = set()\n    ans = []\n\n    def dfs(r, c):\n        size = 0\n        s = [(r, c)]\n        while s:\n            (nr, nc) = s.pop()\n            size += 1\n            for (ar, ac) in directions:\n                ar = nr + ar\n                ac = nc + ac\n                if (ar, ac) not in checked and 0 <= ar < rlen and (0 <= ac < clen) and (grid[ar][ac] == 0):\n                    s.append((ar, ac))\n                    checked.add((ar, ac))\n        return size\n    for r in range(rlen):\n        for c in range(clen):\n            if grid[r][c] == 0 and (r, c) not in checked:\n                ans.append(dfs(r, c))\n                checked.add((r, c))\n    ans.sort()\n    return ans[-1] * ans[--2] * ans[-3] if len(ans) >= 3 else 0"
    }
  ]
}