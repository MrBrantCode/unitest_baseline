{
  "task_id": "cf_53997",
  "entry_point": "alienOrder",
  "mutant_count": 68,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if len(output) < len(in_degree):",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) <= len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if len(output) < len(in_degree):",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) >= len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if len(output) < len(in_degree):",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) != len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "in_degree = {c : 0 for word in words for c in word}",
      "mutated_line": "in_degree = {c: 1 for word in words for c in word}",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 1 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "in_degree = {c : 0 for word in words for c in word}",
      "mutated_line": "in_degree = {c: -1 for word in words for c in word}",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: -1 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "in_degree = {c : 0 for word in words for c in word}",
      "mutated_line": "in_degree = {c: 1 for word in words for c in word}",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 1 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(len(words) - 1):",
      "mutated_line": "for i in range(len(words) + 1):",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) + 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(len(words) - 1):",
      "mutated_line": "for i in range(len(words) * 1):",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) * 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if constraint[1] not in adj_list[constraint[0]]:",
      "mutated_line": "if constraint[1] in adj_list[constraint[0]]:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "in_degree[constraint[1]] += 1",
      "mutated_line": "in_degree[constraint[1]] -= 1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] -= 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "in_degree[d] -= 1",
      "mutated_line": "in_degree[d] += 1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] += 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return \"\"",
      "mutated_line": "return 'MUTATED'",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return 'MUTATED'\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(len(words) - 1):",
      "mutated_line": "for i in range(len(words) - 2):",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 2):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(len(words) - 1):",
      "mutated_line": "for i in range(len(words) - 0):",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 0):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(len(words) - 1):",
      "mutated_line": "for i in range(len(words) - 0):",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 0):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(len(words) - 1):",
      "mutated_line": "for i in range(len(words) - -1):",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - -1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "word2 = words[i+1]",
      "mutated_line": "word2 = words[i - 1]",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i - 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "word2 = words[i+1]",
      "mutated_line": "word2 = words[i * 1]",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i * 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if c != d:",
      "mutated_line": "if c == d:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c == d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(word1) > len(word2):",
      "mutated_line": "if len(word1) >= len(word2):",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) >= len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(word1) > len(word2):",
      "mutated_line": "if len(word1) <= len(word2):",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) <= len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(word1) > len(word2):",
      "mutated_line": "if len(word1) != len(word2):",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) != len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[constraint[1]] += 1",
      "mutated_line": "in_degree[constraint[1]] += 2",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 2\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[constraint[1]] += 1",
      "mutated_line": "in_degree[constraint[1]] += 0",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 0\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[constraint[1]] += 1",
      "mutated_line": "in_degree[constraint[1]] += 0",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 0\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[constraint[1]] += 1",
      "mutated_line": "in_degree[constraint[1]] += -1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += -1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "in_degree[d] -= 1",
      "mutated_line": "in_degree[d] -= 2",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 2\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "in_degree[d] -= 1",
      "mutated_line": "in_degree[d] -= 0",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 0\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "in_degree[d] -= 1",
      "mutated_line": "in_degree[d] -= 0",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 0\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "in_degree[d] -= 1",
      "mutated_line": "in_degree[d] -= -1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= -1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if in_degree[d] == 0:",
      "mutated_line": "if in_degree[d] != 0:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] != 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "word2 = words[i+1]",
      "mutated_line": "word2 = words[i + 2]",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 2]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "word2 = words[i+1]",
      "mutated_line": "word2 = words[i + 0]",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 0]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "word2 = words[i+1]",
      "mutated_line": "word2 = words[i + 0]",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 0]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "word2 = words[i+1]",
      "mutated_line": "word2 = words[i + -1]",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + -1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d not in adj_list[c]:",
      "mutated_line": "if d in adj_list[c]:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "in_degree[d] += 1",
      "mutated_line": "in_degree[d] -= 1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] -= 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return ''",
      "mutated_line": "return 'MUTATED'",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return 'MUTATED'\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if constraint[1] not in adj_list[constraint[0]]:",
      "mutated_line": "if constraint[2] not in adj_list[constraint[0]]:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[2] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if constraint[1] not in adj_list[constraint[0]]:",
      "mutated_line": "if constraint[0] not in adj_list[constraint[0]]:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[0] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if constraint[1] not in adj_list[constraint[0]]:",
      "mutated_line": "if constraint[0] not in adj_list[constraint[0]]:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[0] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if constraint[1] not in adj_list[constraint[0]]:",
      "mutated_line": "if constraint[-1] not in adj_list[constraint[0]]:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[-1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "queue = deque([c for c in in_degree if in_degree[c] == 0])",
      "mutated_line": "queue = deque([c for c in in_degree if in_degree[c] != 0])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] != 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if in_degree[d] == 0:",
      "mutated_line": "if in_degree[d] == 1:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 1:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if in_degree[d] == 0:",
      "mutated_line": "if in_degree[d] == -1:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == -1:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if in_degree[d] == 0:",
      "mutated_line": "if in_degree[d] == 1:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 1:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ''.join(output)",
      "mutated_line": "return 'MUTATED'.join(output)",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return 'MUTATED'.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "in_degree[d] += 1",
      "mutated_line": "in_degree[d] += 2",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 2\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "in_degree[d] += 1",
      "mutated_line": "in_degree[d] += 0",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 0\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "in_degree[d] += 1",
      "mutated_line": "in_degree[d] += 0",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 0\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "in_degree[d] += 1",
      "mutated_line": "in_degree[d] += -1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += -1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if constraint[1] not in adj_list[constraint[0]]:",
      "mutated_line": "if constraint[1] not in adj_list[constraint[1]]:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[1]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if constraint[1] not in adj_list[constraint[0]]:",
      "mutated_line": "if constraint[1] not in adj_list[constraint[-1]]:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[-1]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if constraint[1] not in adj_list[constraint[0]]:",
      "mutated_line": "if constraint[1] not in adj_list[constraint[1]]:",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[1]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj_list[constraint[0]].add(constraint[1])",
      "mutated_line": "adj_list[constraint[0]].add(constraint[2])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[2])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj_list[constraint[0]].add(constraint[1])",
      "mutated_line": "adj_list[constraint[0]].add(constraint[0])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[0])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj_list[constraint[0]].add(constraint[1])",
      "mutated_line": "adj_list[constraint[0]].add(constraint[0])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[0])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj_list[constraint[0]].add(constraint[1])",
      "mutated_line": "adj_list[constraint[0]].add(constraint[-1])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[-1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[constraint[1]] += 1",
      "mutated_line": "in_degree[constraint[2]] += 1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[2]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[constraint[1]] += 1",
      "mutated_line": "in_degree[constraint[0]] += 1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[0]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[constraint[1]] += 1",
      "mutated_line": "in_degree[constraint[0]] += 1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[0]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[constraint[1]] += 1",
      "mutated_line": "in_degree[constraint[-1]] += 1",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[-1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "queue = deque([c for c in in_degree if in_degree[c] == 0])",
      "mutated_line": "queue = deque([c for c in in_degree if in_degree[c] == 1])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 1])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "queue = deque([c for c in in_degree if in_degree[c] == 0])",
      "mutated_line": "queue = deque([c for c in in_degree if in_degree[c] == -1])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == -1])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "queue = deque([c for c in in_degree if in_degree[c] == 0])",
      "mutated_line": "queue = deque([c for c in in_degree if in_degree[c] == 1])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[0]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 1])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj_list[constraint[0]].add(constraint[1])",
      "mutated_line": "adj_list[constraint[1]].add(constraint[1])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[1]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj_list[constraint[0]].add(constraint[1])",
      "mutated_line": "adj_list[constraint[-1]].add(constraint[1])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[-1]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj_list[constraint[0]].add(constraint[1])",
      "mutated_line": "adj_list[constraint[1]].add(constraint[1])",
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words, constraints):\n    adj_list = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        word1 = words[i]\n        word2 = words[i + 1]\n        for (c, d) in zip(word1, word2):\n            if c != d:\n                if d not in adj_list[c]:\n                    adj_list[c].add(d)\n                    in_degree[d] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return ''\n    for constraint in constraints:\n        if constraint[1] not in adj_list[constraint[0]]:\n            adj_list[constraint[1]].add(constraint[1])\n            in_degree[constraint[1]] += 1\n    output = []\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    while queue:\n        c = queue.popleft()\n        output.append(c)\n        for d in adj_list[c]:\n            in_degree[d] -= 1\n            if in_degree[d] == 0:\n                queue.append(d)\n    if len(output) < len(in_degree):\n        return ''\n    else:\n        return ''.join(output)"
    }
  ]
}