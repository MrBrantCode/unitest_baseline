{
  "task_id": "cf_42733",
  "entry_point": "simulate_disc_trajectory",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi / 180) / v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) / v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi / 180) + v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) + v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi / 180) ** v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) ** v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi / 180) / v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) / v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi / 180) + v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) + v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi / 180) ** v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) ** v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "max_step = 0.2  # Default max_step value",
      "mutated_line": "max_step = 1.2",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 1.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "max_step = 0.2  # Default max_step value",
      "mutated_line": "max_step = -0.8",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = -0.8\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "max_step = 0.2  # Default max_step value",
      "mutated_line": "max_step = 0",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "max_step = 0.2  # Default max_step value",
      "mutated_line": "max_step = 1",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 1\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "max_step = 0.2  # Default max_step value",
      "mutated_line": "max_step = -0.2",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = -0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(1, int(time * 10) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(1, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(-1, int(time * 10) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(-1, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(1, int(time * 10) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(1, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 10) - 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) - 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 10) * 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) * 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "x = vx * t * max_step",
      "mutated_line": "x = vx * t / max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t / max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "x = vx * t * max_step",
      "mutated_line": "x = vx * t + max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t + max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "x = vx * t * max_step",
      "mutated_line": "x = (vx * t) ** max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = (vx * t) ** max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = vz * t * max_step",
      "mutated_line": "y = vz * t / max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t / max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = vz * t * max_step",
      "mutated_line": "y = vz * t + max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t + max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = vz * t * max_step",
      "mutated_line": "y = (vz * t) ** max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = (vz * t) ** max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "z = rot * t * max_step",
      "mutated_line": "z = rot * t / max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t / max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "z = rot * t * max_step",
      "mutated_line": "z = rot * t + max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t + max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "z = rot * t * max_step",
      "mutated_line": "z = (rot * t) ** max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = (rot * t) ** max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi * 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi * 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi // 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi // 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi * 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi * 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi // 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi // 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 10) + 2):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 2):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 10) + 0):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 0):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 10) + 0):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 0):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 10) + -1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + -1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "x = vx * t * max_step",
      "mutated_line": "x = vx / t * max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx / t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "x = vx * t * max_step",
      "mutated_line": "x = (vx + t) * max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = (vx + t) * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "x = vx * t * max_step",
      "mutated_line": "x = vx ** t * max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx ** t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = vz * t * max_step",
      "mutated_line": "y = vz / t * max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz / t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = vz * t * max_step",
      "mutated_line": "y = (vz + t) * max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = (vz + t) * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = vz * t * max_step",
      "mutated_line": "y = vz ** t * max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz ** t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "z = rot * t * max_step",
      "mutated_line": "z = rot / t * max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot / t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "z = rot * t * max_step",
      "mutated_line": "z = (rot + t) * max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = (rot + t) * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "z = rot * t * max_step",
      "mutated_line": "z = rot ** t * max_step",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot ** t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a / math.pi / 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a / math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos((a + math.pi) / 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos((a + math.pi) / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a ** math.pi / 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a ** math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi / 181) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 181) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi / 179) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 179) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi / 0) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 0) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi / 1) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 1) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vx = math.cos(a * math.pi / 180) * v",
      "mutated_line": "vx = math.cos(a * math.pi / -180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / -180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a / math.pi / 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a / math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin((a + math.pi) / 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin((a + math.pi) / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a ** math.pi / 180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a ** math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi / 181) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 181) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi / 179) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 179) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi / 0) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 0) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi / 1) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 1) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vz = math.sin(a * math.pi / 180) * v",
      "mutated_line": "vz = math.sin(a * math.pi / -180) * v",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / -180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time / 10) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time / 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time + 10) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time + 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time ** 10) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time ** 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "trajectory.append((t * max_step, x, y, z))",
      "mutated_line": "trajectory.append((t / max_step, x, y, z))",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t / max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "trajectory.append((t * max_step, x, y, z))",
      "mutated_line": "trajectory.append((t + max_step, x, y, z))",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t + max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "trajectory.append((t * max_step, x, y, z))",
      "mutated_line": "trajectory.append((t ** max_step, x, y, z))",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t ** max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 11) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 11) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 9) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 9) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 0) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 0) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * 1) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * 1) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for t in range(0, int(time*10)+1):",
      "mutated_line": "for t in range(0, int(time * -10) + 1):",
      "code": "import math\n\ndef simulate_disc_trajectory(model, a, v, rot, nose_up, hyzer, time):\n    \"\"\"\n    Simulates the trajectory of a disc based on given parameters.\n\n    Args:\n    - model (string): The disc model name.\n    - a (float): The launch angle in degrees.\n    - v (float): The launch velocity in meters per second.\n    - rot (float): The rotation rate in radians per second.\n    - nose_up (bool): Indicates whether the disc is thrown nose up (True) or not (False).\n    - hyzer (float): The hyzer angle in degrees.\n    - time (float): The total time for which the trajectory should be simulated.\n\n    Returns:\n    - A list of tuples, where each tuple represents the disc's position at a specific time during its flight.\n      Each tuple contains the time (in seconds) and the 3D coordinates (x, y, z) of the disc's position.\n    \"\"\"\n    vx = math.cos(a * math.pi / 180) * v\n    vz = math.sin(a * math.pi / 180) * v\n    trajectory = []\n    max_step = 0.2\n    for t in range(0, int(time * -10) + 1):\n        x = vx * t * max_step\n        y = vz * t * max_step\n        z = rot * t * max_step\n        trajectory.append((t * max_step, x, y, z))\n    return trajectory"
    }
  ]
}