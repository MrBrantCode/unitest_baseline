{
  "task_id": "cf_71989",
  "entry_point": "min_swaps_binary",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if source == target:",
      "mutated_line": "if source != target:",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source != target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited = {source: 0}",
      "mutated_line": "visited = {source: 1}",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 1}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited = {source: 0}",
      "mutated_line": "visited = {source: -1}",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: -1}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited = {source: 0}",
      "mutated_line": "visited = {source: 1}",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 1}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "return (-1, [])",
      "mutated_line": "return (+1, [])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (+1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (0, [])",
      "mutated_line": "return (1, [])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (1, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (0, [])",
      "mutated_line": "return (-1, [])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (-1, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (0, [])",
      "mutated_line": "return (1, [])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (1, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (-1, [])",
      "mutated_line": "return (-2, [])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-2, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (-1, [])",
      "mutated_line": "return (-0, [])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (-1, [])",
      "mutated_line": "return (-0, [])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (-1, [])",
      "mutated_line": "return (--1, [])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (--1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(source, 0, [])])",
      "mutated_line": "queue = deque([(source, 1, [])])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 1, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(source, 0, [])])",
      "mutated_line": "queue = deque([(source, -1, [])])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, -1, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(source, 0, [])])",
      "mutated_line": "queue = deque([(source, 1, [])])",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 1, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(i+1, N):",
      "mutated_line": "for j in range(i - 1, N):",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i - 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(i+1, N):",
      "mutated_line": "for j in range(i * 1, N):",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i * 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if curr[i] != curr[j]:",
      "mutated_line": "if curr[i] == curr[j]:",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] == curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(i+1, N):",
      "mutated_line": "for j in range(i + 2, N):",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 2, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(i+1, N):",
      "mutated_line": "for j in range(i + 0, N):",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 0, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(i+1, N):",
      "mutated_line": "for j in range(i + 0, N):",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 0, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(i+1, N):",
      "mutated_line": "for j in range(i + -1, N):",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + -1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] - curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] - curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = (curr[:i] + curr[j] + curr[i + 1:j] + curr[i]) * curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = (curr[:i] + curr[j] + curr[i + 1:j] + curr[i]) * curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if swapped not in visited:",
      "mutated_line": "if swapped in visited:",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 1:j] - curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] - curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = (curr[:i] + curr[j] + curr[i + 1:j]) * curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = (curr[:i] + curr[j] + curr[i + 1:j]) * curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if swapped == target:",
      "mutated_line": "if swapped != target:",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped != target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "visited[swapped] = dist + 1",
      "mutated_line": "visited[swapped] = dist - 1",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist - 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "visited[swapped] = dist + 1",
      "mutated_line": "visited[swapped] = dist * 1",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist * 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] - curr[i + 1:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] - curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = (curr[:i] + curr[j]) * curr[i + 1:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = (curr[:i] + curr[j]) * curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[swapped] = dist + 1",
      "mutated_line": "visited[swapped] = dist + 2",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 2\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[swapped] = dist + 1",
      "mutated_line": "visited[swapped] = dist + 0",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 0\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[swapped] = dist + 1",
      "mutated_line": "visited[swapped] = dist + 0",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 0\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[swapped] = dist + 1",
      "mutated_line": "visited[swapped] = dist + -1",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + -1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] - curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] - curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] * curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] * curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j - 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j - 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j * 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j * 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return (dist + 1, swaps)",
      "mutated_line": "return (dist - 1, swaps)",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist - 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return (dist + 1, swaps)",
      "mutated_line": "return (dist * 1, swaps)",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist * 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "queue.append((swapped, dist + 1, swaps + [(i, j)]))",
      "mutated_line": "queue.append((swapped, dist - 1, swaps + [(i, j)]))",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist - 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "queue.append((swapped, dist + 1, swaps + [(i, j)]))",
      "mutated_line": "queue.append((swapped, dist * 1, swaps + [(i, j)]))",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist * 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "queue.append((swapped, dist + 1, swaps + [(i, j)]))",
      "mutated_line": "queue.append((swapped, dist + 1, swaps - [(i, j)]))",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps - [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "queue.append((swapped, dist + 1, swaps + [(i, j)]))",
      "mutated_line": "queue.append((swapped, dist + 1, swaps * [(i, j)]))",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps * [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 2:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 2:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 0:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 0:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 0:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 0:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + -1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + -1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return (dist + 1, swaps)",
      "mutated_line": "return (dist + 2, swaps)",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 2, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return (dist + 1, swaps)",
      "mutated_line": "return (dist + 0, swaps)",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 0, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return (dist + 1, swaps)",
      "mutated_line": "return (dist + 0, swaps)",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 0, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return (dist + 1, swaps)",
      "mutated_line": "return (dist + -1, swaps)",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + -1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue.append((swapped, dist + 1, swaps + [(i, j)]))",
      "mutated_line": "queue.append((swapped, dist + 2, swaps + [(i, j)]))",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 2, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue.append((swapped, dist + 1, swaps + [(i, j)]))",
      "mutated_line": "queue.append((swapped, dist + 0, swaps + [(i, j)]))",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 0, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue.append((swapped, dist + 1, swaps + [(i, j)]))",
      "mutated_line": "queue.append((swapped, dist + 0, swaps + [(i, j)]))",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 0, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue.append((swapped, dist + 1, swaps + [(i, j)]))",
      "mutated_line": "queue.append((swapped, dist + -1, swaps + [(i, j)]))",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + -1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i - 1:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i - 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i * 1:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i * 1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 2:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 2:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 0:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 0:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + 0:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + 0:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swapped = curr[:i] + curr[j] + curr[i+1:j] + curr[i] + curr[j+1:]",
      "mutated_line": "swapped = curr[:i] + curr[j] + curr[i + -1:j] + curr[i] + curr[j + 1:]",
      "code": "from collections import deque\n\ndef min_swaps_binary(source, target):\n    if source == target:\n        return (0, [])\n    N = len(source)\n    queue = deque([(source, 0, [])])\n    visited = {source: 0}\n    while queue:\n        (curr, dist, swaps) = queue.popleft()\n        for i in range(N):\n            for j in range(i + 1, N):\n                if curr[i] != curr[j]:\n                    swapped = curr[:i] + curr[j] + curr[i + -1:j] + curr[i] + curr[j + 1:]\n                    if swapped not in visited:\n                        if swapped == target:\n                            swaps.append((i, j))\n                            return (dist + 1, swaps)\n                        queue.append((swapped, dist + 1, swaps + [(i, j)]))\n                        visited[swapped] = dist + 1\n    return (-1, [])"
    }
  ]
}