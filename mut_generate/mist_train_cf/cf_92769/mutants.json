{
  "task_id": "cf_92769",
  "entry_point": "print_combinations",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if remaining_sum == 0:",
      "mutated_line": "if remaining_sum != 0:",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum != 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(current_combination) == 0:",
      "mutated_line": "if len(current_combination) != 0:",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) != 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if remaining_sum == 0:",
      "mutated_line": "if remaining_sum == 1:",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 1:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if remaining_sum == 0:",
      "mutated_line": "if remaining_sum == -1:",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == -1:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if remaining_sum == 0:",
      "mutated_line": "if remaining_sum == 1:",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 1:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(current_combination) == 0:",
      "mutated_line": "if len(current_combination) == 1:",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 1:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(current_combination) == 0:",
      "mutated_line": "if len(current_combination) == -1:",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == -1:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(current_combination) == 0:",
      "mutated_line": "if len(current_combination) == 1:",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 1:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start_num = 1",
      "mutated_line": "start_num = 2",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 2\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start_num = 1",
      "mutated_line": "start_num = 0",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 0\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start_num = 1",
      "mutated_line": "start_num = 0",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 0\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start_num = 1",
      "mutated_line": "start_num = -1",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = -1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for num in range(start_num, min(remaining_sum, M) + 1):",
      "mutated_line": "for num in range(start_num, min(remaining_sum, M) - 1):",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) - 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for num in range(start_num, min(remaining_sum, M) + 1):",
      "mutated_line": "for num in range(start_num, min(remaining_sum, M) * 1):",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) * 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if num not in current_combination:",
      "mutated_line": "if num in current_combination:",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "start_num = current_combination[-1]",
      "mutated_line": "start_num = current_combination[+1]",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[+1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for num in range(start_num, min(remaining_sum, M) + 1):",
      "mutated_line": "for num in range(start_num, min(remaining_sum, M) + 2):",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 2):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for num in range(start_num, min(remaining_sum, M) + 1):",
      "mutated_line": "for num in range(start_num, min(remaining_sum, M) + 0):",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 0):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for num in range(start_num, min(remaining_sum, M) + 1):",
      "mutated_line": "for num in range(start_num, min(remaining_sum, M) + 0):",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 0):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for num in range(start_num, min(remaining_sum, M) + 1):",
      "mutated_line": "for num in range(start_num, min(remaining_sum, M) + -1):",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + -1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "start_num = current_combination[-1]",
      "mutated_line": "start_num = current_combination[-2]",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-2]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "start_num = current_combination[-1]",
      "mutated_line": "start_num = current_combination[-0]",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-0]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "start_num = current_combination[-1]",
      "mutated_line": "start_num = current_combination[-0]",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-0]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "start_num = current_combination[-1]",
      "mutated_line": "start_num = current_combination[--1]",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[--1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "backtrack(remaining_sum - num, current_combination + [num])",
      "mutated_line": "backtrack(remaining_sum + num, current_combination + [num])",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum + num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "backtrack(remaining_sum - num, current_combination + [num])",
      "mutated_line": "backtrack(remaining_sum * num, current_combination + [num])",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum * num, current_combination + [num])\n    backtrack(N, [])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "backtrack(remaining_sum - num, current_combination + [num])",
      "mutated_line": "backtrack(remaining_sum - num, current_combination - [num])",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination - [num])\n    backtrack(N, [])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "backtrack(remaining_sum - num, current_combination + [num])",
      "mutated_line": "backtrack(remaining_sum - num, current_combination * [num])",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print('+'.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination * [num])\n    backtrack(N, [])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "print(\"+\".join(str(num) for num in current_combination))",
      "mutated_line": "print(''.join((str(num) for num in current_combination)))",
      "code": "def print_combinations(N, M):\n\n    def backtrack(remaining_sum, current_combination):\n        if remaining_sum == 0:\n            print(''.join((str(num) for num in current_combination)))\n            return\n        if len(current_combination) == 0:\n            start_num = 1\n        else:\n            start_num = current_combination[-1]\n        for num in range(start_num, min(remaining_sum, M) + 1):\n            if num not in current_combination:\n                backtrack(remaining_sum - num, current_combination + [num])\n    backtrack(N, [])"
    }
  ]
}