{
  "task_id": "cf_50742",
  "entry_point": "partition",
  "mutant_count": 110,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"Rearrange the list such that all elements less than the pivot are to its left,",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def partition(lst, low, high):\n    \"\"\"\"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "i = low - 1",
      "mutated_line": "i = low + 1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low + 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "i = low - 1",
      "mutated_line": "i = low * 1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low * 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return i + 1",
      "mutated_line": "return i - 1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i - 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return i + 1",
      "mutated_line": "return i * 1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i * 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "\"\"\"Return the element at index k if the list were sorted.",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"\"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) != 1:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) != 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if pivot_index == k:",
      "mutated_line": "if pivot_index != k:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index != k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "\"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"\"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 != 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 != 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = low - 1",
      "mutated_line": "i = low - 2",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 2\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = low - 1",
      "mutated_line": "i = low - 0",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 0\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = low - 1",
      "mutated_line": "i = low - 0",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 0\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = low - 1",
      "mutated_line": "i = low - -1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - -1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if lst[j] <= pivot:",
      "mutated_line": "if lst[j] < pivot:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] < pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if lst[j] <= pivot:",
      "mutated_line": "if lst[j] > pivot:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] > pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if lst[j] <= pivot:",
      "mutated_line": "if lst[j] == pivot:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] == pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i -= 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return i + 1",
      "mutated_line": "return i + 2",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 2\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return i + 1",
      "mutated_line": "return i + 0",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 0\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return i + 1",
      "mutated_line": "return i + 0",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 0\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return i + 1",
      "mutated_line": "return i + -1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + -1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == 2:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 2:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 0:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 0:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == -1:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == -1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pivot_index = partition(lst, 0, len(lst) - 1)",
      "mutated_line": "pivot_index = partition(lst, 1, len(lst) - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 1, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pivot_index = partition(lst, 0, len(lst) - 1)",
      "mutated_line": "pivot_index = partition(lst, -1, len(lst) - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, -1, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pivot_index = partition(lst, 0, len(lst) - 1)",
      "mutated_line": "pivot_index = partition(lst, 1, len(lst) - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 1, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "pivot_index = partition(lst, 0, len(lst) - 1)",
      "mutated_line": "pivot_index = partition(lst, 0, len(lst) + 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) + 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "pivot_index = partition(lst, 0, len(lst) - 1)",
      "mutated_line": "pivot_index = partition(lst, 0, len(lst) * 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) * 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif pivot_index > k:",
      "mutated_line": "elif pivot_index >= k:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index >= k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif pivot_index > k:",
      "mutated_line": "elif pivot_index <= k:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index <= k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif pivot_index > k:",
      "mutated_line": "elif pivot_index != k:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index != k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid1 = quick_select(lst, n // 2)",
      "mutated_line": "mid1 = quick_select(lst, n / 2)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n / 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid1 = quick_select(lst, n // 2)",
      "mutated_line": "mid1 = quick_select(lst, n * 2)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n * 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n * 2 == 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n * 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n + 2 == 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n + 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 1:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == -1:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 1:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return (mid1 + mid2) / 2",
      "mutated_line": "return (mid1 + mid2) * 2",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) * 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return (mid1 + mid2) / 2",
      "mutated_line": "return (mid1 + mid2) // 2",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) // 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 2\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 0\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 0\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += -1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i - 1], lst[high]) = (lst[high], lst[i + 1])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i - 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i * 1], lst[high]) = (lst[high], lst[i + 1])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i * 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + 1], lst[high]) = (lst[high], lst[i - 1])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i - 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + 1], lst[high]) = (lst[high], lst[i * 1])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i * 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[1]",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[1]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[-1]",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[-1]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[1]",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[1]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pivot_index = partition(lst, 0, len(lst) - 1)",
      "mutated_line": "pivot_index = partition(lst, 0, len(lst) - 2)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 2)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pivot_index = partition(lst, 0, len(lst) - 1)",
      "mutated_line": "pivot_index = partition(lst, 0, len(lst) - 0)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 0)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pivot_index = partition(lst, 0, len(lst) - 1)",
      "mutated_line": "pivot_index = partition(lst, 0, len(lst) - 0)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 0)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pivot_index = partition(lst, 0, len(lst) - 1)",
      "mutated_line": "pivot_index = partition(lst, 0, len(lst) - -1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - -1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid1 = quick_select(lst, n // 2)",
      "mutated_line": "mid1 = quick_select(lst, n // 3)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 3)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid1 = quick_select(lst, n // 2)",
      "mutated_line": "mid1 = quick_select(lst, n // 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 1)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid1 = quick_select(lst, n // 2)",
      "mutated_line": "mid1 = quick_select(lst, n // 0)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 0)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid1 = quick_select(lst, n // 2)",
      "mutated_line": "mid1 = quick_select(lst, n // 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 1)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid1 = quick_select(lst, n // 2)",
      "mutated_line": "mid1 = quick_select(lst, n // -2)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // -2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 3 == 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 3 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 1 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 0 == 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 0 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 1 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % -2 == 0:",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % -2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 2 + 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 + 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 2 * 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 * 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return (mid1 + mid2) / 2",
      "mutated_line": "return (mid1 - mid2) / 2",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 - mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return (mid1 + mid2) / 2",
      "mutated_line": "return mid1 * mid2 / 2",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return mid1 * mid2 / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (mid1 + mid2) / 2",
      "mutated_line": "return (mid1 + mid2) / 3",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 3\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (mid1 + mid2) / 2",
      "mutated_line": "return (mid1 + mid2) / 1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 1\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (mid1 + mid2) / 2",
      "mutated_line": "return (mid1 + mid2) / 0",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 0\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (mid1 + mid2) / 2",
      "mutated_line": "return (mid1 + mid2) / 1",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 1\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (mid1 + mid2) / 2",
      "mutated_line": "return (mid1 + mid2) / -2",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / -2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + 2], lst[high]) = (lst[high], lst[i + 1])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 2], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + 0], lst[high]) = (lst[high], lst[i + 1])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 0], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + 0], lst[high]) = (lst[high], lst[i + 1])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 0], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + -1], lst[high]) = (lst[high], lst[i + 1])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + -1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + 1], lst[high]) = (lst[high], lst[i + 2])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 2])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + 1], lst[high]) = (lst[high], lst[i + 0])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 0])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + 1], lst[high]) = (lst[high], lst[i + 0])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 0])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lst[i + 1], lst[high] = lst[high], lst[i + 1]",
      "mutated_line": "(lst[i + 1], lst[high]) = (lst[high], lst[i + -1])",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + -1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index + 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index + 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 1:], (k - pivot_index) * 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], (k - pivot_index) * 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n / 2 - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n / 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n * 2 - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n * 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 2 - 2)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 2)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 2 - 0)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 0)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 2 - 0)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 0)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 2 - -1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - -1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 1:], k + pivot_index - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k + pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 1:], k * pivot_index - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k * pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 2)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 2)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 0)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 0)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 0)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 0)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - -1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - -1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 3 - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 3 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 1 - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 1 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 0 - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 0 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // 1 - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 1 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mid2 = quick_select(lst, n // 2 - 1)",
      "mutated_line": "mid2 = quick_select(lst, n // -2 - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // -2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index - 1:], k - pivot_index - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index - 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index * 1:], k - pivot_index - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index * 1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 2:], k - pivot_index - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 2:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 0:], k - pivot_index - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 0:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + 0:], k - pivot_index - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + 0:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return quick_select(lst[pivot_index + 1:], k - pivot_index - 1)",
      "mutated_line": "return quick_select(lst[pivot_index + -1:], k - pivot_index - 1)",
      "code": "def partition(lst, low, high):\n    \"\"\"Rearrange the list such that all elements less than the pivot are to its left,\n    and all elements greater are to its right, and return the index of the pivot.\n    \"\"\"\n    pivot = lst[high]\n    i = low - 1\n    for j in range(low, high):\n        if lst[j] <= pivot:\n            i += 1\n            (lst[i], lst[j]) = (lst[j], lst[i])\n    (lst[i + 1], lst[high]) = (lst[high], lst[i + 1])\n    return i + 1\n\ndef quick_select(lst, k):\n    \"\"\"Return the element at index k if the list were sorted.\n    \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    pivot_index = partition(lst, 0, len(lst) - 1)\n    if pivot_index == k:\n        return lst[pivot_index]\n    elif pivot_index > k:\n        return quick_select(lst[:pivot_index], k)\n    else:\n        return quick_select(lst[pivot_index + -1:], k - pivot_index - 1)\n\ndef median(lst):\n    \"\"\"Calculate the median element of an unsorted list of numbers using the QuickSelect algorithm.\n    \"\"\"\n    n = len(lst)\n    mid1 = quick_select(lst, n // 2)\n    mid2 = None\n    if n % 2 == 0:\n        mid2 = quick_select(lst, n // 2 - 1)\n        return (mid1 + mid2) / 2\n    else:\n        return mid1"
    }
  ]
}