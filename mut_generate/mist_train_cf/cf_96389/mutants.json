{
  "task_id": "cf_96389",
  "entry_point": "merge_intervals",
  "mutant_count": 48,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def merge_intervals(intervals):\n    \"\"\"\"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(2, len(intervals)):",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(2, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(0, len(intervals)):",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(0, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(0, len(intervals)):",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(0, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(-1, len(intervals)):",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(-1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] >= result[-1][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] >= result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] <= result[-1][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] <= result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] != result[-1][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] != result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "result = [intervals[0]]",
      "mutated_line": "result = [intervals[1]]",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[1]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "result = [intervals[0]]",
      "mutated_line": "result = [intervals[-1]]",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[-1]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "result = [intervals[0]]",
      "mutated_line": "result = [intervals[1]]",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[1]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][1] > result[-1][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][1] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][-1] > result[-1][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][-1] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][1] > result[-1][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][1] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] > result[-1][2]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][2]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] > result[-1][0]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][0]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] > result[-1][0]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][0]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] > result[-1][-1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][-1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][2] = max(intervals[i][1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][2] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][0] = max(intervals[i][1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][0] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][0] = max(intervals[i][1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][0] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][-1] = max(intervals[i][1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][-1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[1])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[-1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[-1])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[1])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] > result[+1][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[+1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[+1][1] = max(intervals[i][1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[+1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][2], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][2], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][0], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][0], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][0], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][0], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][-1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][-1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][1], result[-1][2])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][2])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][1], result[-1][0])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][1], result[-1][0])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][1], result[-1][-1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][-1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] > result[-2][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-2][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] > result[-0][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-0][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] > result[-0][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-0][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if intervals[i][0] > result[-1][1]:",
      "mutated_line": "if intervals[i][0] > result[--1][1]:",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[--1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-2][1] = max(intervals[i][1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-2][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-0][1] = max(intervals[i][1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-0][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-0][1] = max(intervals[i][1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-0][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[--1][1] = max(intervals[i][1], result[-1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[--1][1] = max(intervals[i][1], result[-1][1])\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][1], result[+1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[+1][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][1], result[-2][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-2][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][1], result[-0][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-0][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][1], result[-0][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[-0][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "result[-1][1] = max(intervals[i][1], result[-1][1])",
      "mutated_line": "result[-1][1] = max(intervals[i][1], result[--1][1])",
      "code": "def merge_intervals(intervals):\n    \"\"\"\n    This function merges overlapping intervals and returns a new list of non-overlapping intervals.\n\n    Args:\n        intervals (list): A list of intervals, where each interval is a list of two integers representing the start and end times.\n\n    Returns:\n        list: A new list of merged intervals.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(intervals[i][1], result[--1][1])\n    return result"
    }
  ]
}