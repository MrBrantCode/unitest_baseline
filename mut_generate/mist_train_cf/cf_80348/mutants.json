{
  "task_id": "cf_80348",
  "entry_point": "BFS",
  "mutant_count": 9,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import deque\n\ndef BFS(graph, start_node, end_node):\n    \"\"\"\"\"\"\n    queue = deque([[start_node]])\n    visited = set()\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n        if node not in visited:\n            visited.add(node)\n            if node == end_node:\n                return path\n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if node not in visited:",
      "mutated_line": "if node in visited:",
      "code": "from collections import deque\n\ndef BFS(graph, start_node, end_node):\n    \"\"\"\n    Performs a Breadth-First Search traversal between two nodes in a graph to find the shortest path.\n    \n    Args:\n        graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n        start_node (any): The node to start the search from.\n        end_node (any): The node to search for.\n    \n    Returns:\n        list: The shortest path from start_node to end_node if it exists, otherwise None.\n    \"\"\"\n    queue = deque([[start_node]])\n    visited = set()\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n        if node in visited:\n            visited.add(node)\n            if node == end_node:\n                return path\n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "node = path[-1]",
      "mutated_line": "node = path[+1]",
      "code": "from collections import deque\n\ndef BFS(graph, start_node, end_node):\n    \"\"\"\n    Performs a Breadth-First Search traversal between two nodes in a graph to find the shortest path.\n    \n    Args:\n        graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n        start_node (any): The node to start the search from.\n        end_node (any): The node to search for.\n    \n    Returns:\n        list: The shortest path from start_node to end_node if it exists, otherwise None.\n    \"\"\"\n    queue = deque([[start_node]])\n    visited = set()\n    while queue:\n        path = queue.popleft()\n        node = path[+1]\n        if node not in visited:\n            visited.add(node)\n            if node == end_node:\n                return path\n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if node == end_node:",
      "mutated_line": "if node != end_node:",
      "code": "from collections import deque\n\ndef BFS(graph, start_node, end_node):\n    \"\"\"\n    Performs a Breadth-First Search traversal between two nodes in a graph to find the shortest path.\n    \n    Args:\n        graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n        start_node (any): The node to start the search from.\n        end_node (any): The node to search for.\n    \n    Returns:\n        list: The shortest path from start_node to end_node if it exists, otherwise None.\n    \"\"\"\n    queue = deque([[start_node]])\n    visited = set()\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n        if node not in visited:\n            visited.add(node)\n            if node != end_node:\n                return path\n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "node = path[-1]",
      "mutated_line": "node = path[-2]",
      "code": "from collections import deque\n\ndef BFS(graph, start_node, end_node):\n    \"\"\"\n    Performs a Breadth-First Search traversal between two nodes in a graph to find the shortest path.\n    \n    Args:\n        graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n        start_node (any): The node to start the search from.\n        end_node (any): The node to search for.\n    \n    Returns:\n        list: The shortest path from start_node to end_node if it exists, otherwise None.\n    \"\"\"\n    queue = deque([[start_node]])\n    visited = set()\n    while queue:\n        path = queue.popleft()\n        node = path[-2]\n        if node not in visited:\n            visited.add(node)\n            if node == end_node:\n                return path\n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "node = path[-1]",
      "mutated_line": "node = path[-0]",
      "code": "from collections import deque\n\ndef BFS(graph, start_node, end_node):\n    \"\"\"\n    Performs a Breadth-First Search traversal between two nodes in a graph to find the shortest path.\n    \n    Args:\n        graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n        start_node (any): The node to start the search from.\n        end_node (any): The node to search for.\n    \n    Returns:\n        list: The shortest path from start_node to end_node if it exists, otherwise None.\n    \"\"\"\n    queue = deque([[start_node]])\n    visited = set()\n    while queue:\n        path = queue.popleft()\n        node = path[-0]\n        if node not in visited:\n            visited.add(node)\n            if node == end_node:\n                return path\n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "node = path[-1]",
      "mutated_line": "node = path[-0]",
      "code": "from collections import deque\n\ndef BFS(graph, start_node, end_node):\n    \"\"\"\n    Performs a Breadth-First Search traversal between two nodes in a graph to find the shortest path.\n    \n    Args:\n        graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n        start_node (any): The node to start the search from.\n        end_node (any): The node to search for.\n    \n    Returns:\n        list: The shortest path from start_node to end_node if it exists, otherwise None.\n    \"\"\"\n    queue = deque([[start_node]])\n    visited = set()\n    while queue:\n        path = queue.popleft()\n        node = path[-0]\n        if node not in visited:\n            visited.add(node)\n            if node == end_node:\n                return path\n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "node = path[-1]",
      "mutated_line": "node = path[--1]",
      "code": "from collections import deque\n\ndef BFS(graph, start_node, end_node):\n    \"\"\"\n    Performs a Breadth-First Search traversal between two nodes in a graph to find the shortest path.\n    \n    Args:\n        graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n        start_node (any): The node to start the search from.\n        end_node (any): The node to search for.\n    \n    Returns:\n        list: The shortest path from start_node to end_node if it exists, otherwise None.\n    \"\"\"\n    queue = deque([[start_node]])\n    visited = set()\n    while queue:\n        path = queue.popleft()\n        node = path[--1]\n        if node not in visited:\n            visited.add(node)\n            if node == end_node:\n                return path\n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if neighbor not in visited:",
      "mutated_line": "if neighbor in visited:",
      "code": "from collections import deque\n\ndef BFS(graph, start_node, end_node):\n    \"\"\"\n    Performs a Breadth-First Search traversal between two nodes in a graph to find the shortest path.\n    \n    Args:\n        graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n        start_node (any): The node to start the search from.\n        end_node (any): The node to search for.\n    \n    Returns:\n        list: The shortest path from start_node to end_node if it exists, otherwise None.\n    \"\"\"\n    queue = deque([[start_node]])\n    visited = set()\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n        if node not in visited:\n            visited.add(node)\n            if node == end_node:\n                return path\n            for neighbor in graph.get(node, []):\n                if neighbor in visited:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    return None"
    }
  ]
}