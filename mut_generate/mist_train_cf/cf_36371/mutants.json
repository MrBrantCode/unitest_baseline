{
  "task_id": "cf_36371",
  "entry_point": "dijkstra_shortest_path",
  "mutant_count": 18,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = 1",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 1\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = -1",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = -1\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = 1",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 1\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if cur_node == target:",
      "mutated_line": "return (cur_path + [cur_node], cur_dist)",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node != target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {node: float('inf') for node in graph}",
      "mutated_line": "distances = {node: float('') for node in graph}",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue = [(0, source, [])]",
      "mutated_line": "queue = [(1, source, [])]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(1, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue = [(0, source, [])]",
      "mutated_line": "queue = [(-1, source, [])]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(-1, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue = [(0, source, [])]",
      "mutated_line": "queue = [(1, source, [])]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(1, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "new_dist = cur_dist + weight",
      "mutated_line": "new_dist = cur_dist - weight",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist - weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "new_dist = cur_dist + weight",
      "mutated_line": "new_dist = cur_dist * weight",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist * weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if new_dist < distances[neighbor]:",
      "mutated_line": "if new_dist <= distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist <= distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if new_dist < distances[neighbor]:",
      "mutated_line": "if new_dist >= distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist >= distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if new_dist < distances[neighbor]:",
      "mutated_line": "if new_dist != distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist != distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return None, float('inf')",
      "mutated_line": "return (None, float(''))",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float(''))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return cur_path + [cur_node], cur_dist",
      "mutated_line": "return (cur_path - [cur_node], cur_dist)",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path - [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return cur_path + [cur_node], cur_dist",
      "mutated_line": "return (cur_path * [cur_node], cur_dist)",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path * [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))",
      "mutated_line": "heapq.heappush(queue, (new_dist, neighbor, cur_path - [cur_node]))",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path - [cur_node]))\n    return (None, float('inf'))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(queue, (new_dist, neighbor, cur_path + [cur_node]))",
      "mutated_line": "heapq.heappush(queue, (new_dist, neighbor, cur_path * [cur_node]))",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source, target):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    queue = [(0, source, [])]\n    while queue:\n        (cur_dist, cur_node, cur_path) = heapq.heappop(queue)\n        if cur_node == target:\n            return (cur_path + [cur_node], cur_dist)\n        for (neighbor, weight) in graph[cur_node]:\n            new_dist = cur_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, cur_path * [cur_node]))\n    return (None, float('inf'))"
    }
  ]
}