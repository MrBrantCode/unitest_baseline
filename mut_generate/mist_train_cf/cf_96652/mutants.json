{
  "task_id": "cf_96652",
  "entry_point": "count_combinations",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(1000000000.0 - 7)",
      "code": "MOD = int(1000000000.0 - 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(1000000000.0 * 7)",
      "code": "MOD = int(1000000000.0 * 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "denominator = (factorial(r) * factorial(n - r)) % MOD",
      "mutated_line": "denominator = factorial(r) * factorial(n - r) * MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) * MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "denominator = (factorial(r) * factorial(n - r)) % MOD",
      "mutated_line": "denominator = factorial(r) * factorial(n - r) + MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) + MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (numerator * denominator_inverse) % MOD",
      "mutated_line": "return numerator * denominator_inverse * MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (numerator * denominator_inverse) % MOD",
      "mutated_line": "return numerator * denominator_inverse + MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse + MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(1000000001.0 + 7)",
      "code": "MOD = int(1000000001.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(999999999.0 + 7)",
      "code": "MOD = int(999999999.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(0 + 7)",
      "code": "MOD = int(0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(1 + 7)",
      "code": "MOD = int(1 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(-1000000000.0 + 7)",
      "code": "MOD = int(-1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(1000000000.0 + 8)",
      "code": "MOD = int(1000000000.0 + 8)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(1000000000.0 + 6)",
      "code": "MOD = int(1000000000.0 + 6)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(1000000000.0 + 0)",
      "code": "MOD = int(1000000000.0 + 0)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(1000000000.0 + 1)",
      "code": "MOD = int(1000000000.0 + 1)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = int(1e9 + 7)",
      "mutated_line": "MOD = int(1000000000.0 + -7)",
      "code": "MOD = int(1000000000.0 + -7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = 1",
      "mutated_line": "result = 2",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 2\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = 1",
      "mutated_line": "result = 0",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 0\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = 1",
      "mutated_line": "result = 0",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 0\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = 1",
      "mutated_line": "result = -1",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = -1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if g == 1:",
      "mutated_line": "if g != 1:",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g != 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "denominator = (factorial(r) * factorial(n - r)) % MOD",
      "mutated_line": "denominator = factorial(r) / factorial(n - r) % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) / factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "denominator = (factorial(r) * factorial(n - r)) % MOD",
      "mutated_line": "denominator = (factorial(r) + factorial(n - r)) % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = (factorial(r) + factorial(n - r)) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "denominator = (factorial(r) * factorial(n - r)) % MOD",
      "mutated_line": "denominator = factorial(r) ** factorial(n - r) % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) ** factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (numerator * denominator_inverse) % MOD",
      "mutated_line": "return numerator / denominator_inverse % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator / denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (numerator * denominator_inverse) % MOD",
      "mutated_line": "return (numerator + denominator_inverse) % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return (numerator + denominator_inverse) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (numerator * denominator_inverse) % MOD",
      "mutated_line": "return numerator ** denominator_inverse % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator ** denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(2, x + 1):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(2, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(0, x + 1):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(0, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(0, x + 1):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(0, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(-1, x + 1):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(-1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(1, x - 1):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x - 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(1, x * 1):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x * 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = (result * i) % MOD",
      "mutated_line": "result = result * i * MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i * MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = (result * i) % MOD",
      "mutated_line": "result = result * i + MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i + MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if a == 0:",
      "mutated_line": "if a != 0:",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a != 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if g == 1:",
      "mutated_line": "if g == 2:",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 2:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if g == 1:",
      "mutated_line": "if g == 0:",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 0:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if g == 1:",
      "mutated_line": "if g == 0:",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 0:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if g == 1:",
      "mutated_line": "if g == -1:",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == -1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return x % MOD",
      "mutated_line": "return x * MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x * MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return x % MOD",
      "mutated_line": "return x + MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x + MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(1, x + 2):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 2):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(1, x + 0):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 0):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(1, x + 0):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 0):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, x+1):",
      "mutated_line": "for i in range(1, x + -1):",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + -1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = (result * i) % MOD",
      "mutated_line": "result = result / i % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result / i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = (result * i) % MOD",
      "mutated_line": "result = (result + i) % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = (result + i) % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = (result * i) % MOD",
      "mutated_line": "result = result ** i % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result ** i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if a == 0:",
      "mutated_line": "if a == 1:",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 1:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if a == 0:",
      "mutated_line": "if a == -1:",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == -1:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if a == 0:",
      "mutated_line": "if a == 1:",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 1:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "denominator = (factorial(r) * factorial(n - r)) % MOD",
      "mutated_line": "denominator = factorial(r) * factorial(n + r) % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n + r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "denominator = (factorial(r) * factorial(n - r)) % MOD",
      "mutated_line": "denominator = factorial(r) * factorial(n * r) % MOD",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n * r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return b, 0, 1",
      "mutated_line": "return (b, 1, 1)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 1, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return b, 0, 1",
      "mutated_line": "return (b, -1, 1)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, -1, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return b, 0, 1",
      "mutated_line": "return (b, 1, 1)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 1, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return b, 0, 1",
      "mutated_line": "return (b, 0, 2)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 2)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return b, 0, 1",
      "mutated_line": "return (b, 0, 0)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 0)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return b, 0, 1",
      "mutated_line": "return (b, 0, 0)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 0)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return b, 0, 1",
      "mutated_line": "return (b, 0, -1)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, -1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "g, x, y = extended_gcd(b % a, a)",
      "mutated_line": "(g, x, y) = extended_gcd(b * a, a)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b * a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "g, x, y = extended_gcd(b % a, a)",
      "mutated_line": "(g, x, y) = extended_gcd(b + a, a)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b + a, a)\n                return (g, y - b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return g, y - (b // a) * x, x",
      "mutated_line": "return (g, y + b // a * x, x)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y + b // a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return g, y - (b // a) * x, x",
      "mutated_line": "return (g, y * (b // a * x), x)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y * (b // a * x), x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return g, y - (b // a) * x, x",
      "mutated_line": "return (g, y - b // a / x, x)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b // a / x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return g, y - (b // a) * x, x",
      "mutated_line": "return (g, y - (b // a + x), x)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - (b // a + x), x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return g, y - (b // a) * x, x",
      "mutated_line": "return (g, y - (b // a) ** x, x)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - (b // a) ** x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return g, y - (b // a) * x, x",
      "mutated_line": "return (g, y - b / a * x, x)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b / a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return g, y - (b // a) * x, x",
      "mutated_line": "return (g, y - b * a * x, x)",
      "code": "MOD = int(1000000000.0 + 7)\n\ndef count_combinations(string, length):\n    unique_chars = set(string)\n    n = len(unique_chars)\n    r = length\n\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result = result * i % MOD\n        return result\n\n    def modular_inverse(a):\n\n        def extended_gcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                (g, x, y) = extended_gcd(b % a, a)\n                return (g, y - b * a * x, x)\n        (g, x, _) = extended_gcd(a, MOD)\n        if g == 1:\n            return x % MOD\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r) % MOD\n    denominator_inverse = modular_inverse(denominator)\n    return numerator * denominator_inverse % MOD"
    }
  ]
}