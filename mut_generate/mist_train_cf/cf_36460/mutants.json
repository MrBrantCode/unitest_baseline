{
  "task_id": "cf_36460",
  "entry_point": "dijkstra",
  "mutant_count": 15,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist[(h, w)] = 0",
      "mutated_line": "dist[h, w] = 1",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 1\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist[(h, w)] = 0",
      "mutated_line": "dist[h, w] = -1",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = -1\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist[(h, w)] = 0",
      "mutated_line": "dist[h, w] = 1",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 1\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if dist[key] == float('inf'):",
      "mutated_line": "if dist[key] != float('inf'):",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] != float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "return dist[(a, b)] if dist[(a, b)] != float('inf') else -1",
      "mutated_line": "return dist[a, b] if dist[a, b] == float('inf') else -1",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] == float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return dist[(a, b)] if dist[(a, b)] != float('inf') else -1",
      "mutated_line": "return dist[a, b] if dist[a, b] != float('inf') else +1",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dist = {node: float('inf') for node in alst}",
      "mutated_line": "dist = {node: float('') for node in alst}",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return dist[(a, b)] if dist[(a, b)] != float('inf') else -1",
      "mutated_line": "return dist[a, b] if dist[a, b] != float('inf') else -2",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return dist[(a, b)] if dist[(a, b)] != float('inf') else -1",
      "mutated_line": "return dist[a, b] if dist[a, b] != float('inf') else -0",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return dist[(a, b)] if dist[(a, b)] != float('inf') else -1",
      "mutated_line": "return dist[a, b] if dist[a, b] != float('inf') else -0",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return dist[(a, b)] if dist[(a, b)] != float('inf') else -1",
      "mutated_line": "return dist[a, b] if dist[a, b] != float('inf') else --1",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else --1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if dist[key] == float('inf'):",
      "mutated_line": "if dist[key] == float(''):",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float(''):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist[t] = min(dist[t], val + alst[key][t])",
      "mutated_line": "dist[t] = min(dist[t], val - alst[key][t])",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val - alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist[t] = min(dist[t], val + alst[key][t])",
      "mutated_line": "dist[t] = min(dist[t], val * alst[key][t])",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val * alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return dist[(a, b)] if dist[(a, b)] != float('inf') else -1",
      "mutated_line": "return dist[a, b] if dist[a, b] != float('') else -1",
      "code": "import heapq\n\ndef dijkstra(alst, h, w, a, b):\n    dist = {node: float('inf') for node in alst}\n    dist[h, w] = 0\n    toVisit = list(alst.keys())\n    while toVisit:\n        key = min(toVisit, key=lambda x: dist[x])\n        if dist[key] == float('inf'):\n            break\n        for t in alst[key]:\n            val = dist[key]\n            dist[t] = min(dist[t], val + alst[key][t])\n        toVisit.remove(key)\n    return dist[a, b] if dist[a, b] != float('') else -1"
    }
  ]
}