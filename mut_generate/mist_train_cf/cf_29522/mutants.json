{
  "task_id": "cf_29522",
  "entry_point": "closest_pair",
  "mutant_count": 136,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if n <= 3:",
      "mutated_line": "if n < 3:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n < 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if n <= 3:",
      "mutated_line": "if n > 3:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n > 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if n <= 3:",
      "mutated_line": "if n == 3:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n == 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n / 2",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n / 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n * 2",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n * 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 - (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 - (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 * (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 * (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "min_dist = float('inf')",
      "mutated_line": "min_dist = float('')",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= 4:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 4:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= 2:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 2:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= 0:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 0:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= 1:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 1:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= -3:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= -3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // 3",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 3\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // 1",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 1\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // 0",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 0\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // 1",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 1\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // -2",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // -2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) <= distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) <= distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) >= distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) >= distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) != distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) != distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) <= distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) <= distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) >= distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) >= distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) != distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) != distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) * 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) * 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt(p1[0] - p2[0] + 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt(p1[0] - p2[0] + 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) * 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) * 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1] + 2))",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1] + 2))\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in range(i+1, len(points)):",
      "mutated_line": "for j in range(i - 1, len(points)):",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i - 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in range(i+1, len(points)):",
      "mutated_line": "for j in range(i * 1, len(points)):",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i * 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if dist < min_dist:",
      "mutated_line": "if dist <= min_dist:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist <= min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if dist < min_dist:",
      "mutated_line": "if dist >= min_dist:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist >= min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if dist < min_dist:",
      "mutated_line": "if dist != min_dist:",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist != min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "mutated_line": "left_y = [p for p in sorted_y if p[0] < mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] < mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "mutated_line": "left_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "mutated_line": "left_y = [p for p in sorted_y if p[0] == mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] == mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "right_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "mutated_line": "right_y = [p for p in sorted_y if p[0] >= mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] >= mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "right_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "mutated_line": "right_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "right_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "mutated_line": "right_y = [p for p in sorted_y if p[0] != mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] != mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) <= distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) <= distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) >= distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) >= distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) != distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) != distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] + p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] + p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] * p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] * p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 3 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 3 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 0 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 0 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** -2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** -2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] + p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] + p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] * p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] * p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 3)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 3)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 0)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 0)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** -2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** -2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(i+1, len(points)):",
      "mutated_line": "for j in range(i + 2, len(points)):",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 2, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(i+1, len(points)):",
      "mutated_line": "for j in range(i + 0, len(points)):",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 0, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(i+1, len(points)):",
      "mutated_line": "for j in range(i + 0, len(points)):",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 0, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(i+1, len(points)):",
      "mutated_line": "for j in range(i + -1, len(points)):",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + -1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "sorted_x = sorted(points, key=lambda x: x[0])",
      "mutated_line": "sorted_x = sorted(points, key=lambda x: x[1])",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[1])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "sorted_x = sorted(points, key=lambda x: x[0])",
      "mutated_line": "sorted_x = sorted(points, key=lambda x: x[-1])",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[-1])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "sorted_x = sorted(points, key=lambda x: x[0])",
      "mutated_line": "sorted_x = sorted(points, key=lambda x: x[1])",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[1])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "sorted_y = sorted(points, key=lambda x: x[1])",
      "mutated_line": "sorted_y = sorted(points, key=lambda x: x[2])",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[2])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "sorted_y = sorted(points, key=lambda x: x[1])",
      "mutated_line": "sorted_y = sorted(points, key=lambda x: x[0])",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[0])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "sorted_y = sorted(points, key=lambda x: x[1])",
      "mutated_line": "sorted_y = sorted(points, key=lambda x: x[0])",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[0])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "sorted_y = sorted(points, key=lambda x: x[1])",
      "mutated_line": "sorted_y = sorted(points, key=lambda x: x[-1])",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[-1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "mutated_line": "left_y = [p for p in sorted_y if p[1] <= mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[1] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "mutated_line": "left_y = [p for p in sorted_y if p[-1] <= mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[-1] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "mutated_line": "left_y = [p for p in sorted_y if p[1] <= mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[1] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "mutated_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[1]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[1]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "mutated_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[-1]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[-1]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[0]]",
      "mutated_line": "left_y = [p for p in sorted_y if p[0] <= mid_point[1]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[1]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "right_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "mutated_line": "right_y = [p for p in sorted_y if p[1] > mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[1] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "right_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "mutated_line": "right_y = [p for p in sorted_y if p[-1] > mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[-1] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "right_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "mutated_line": "right_y = [p for p in sorted_y if p[1] > mid_point[0]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[1] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "right_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "mutated_line": "right_y = [p for p in sorted_y if p[0] > mid_point[1]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[1]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "right_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "mutated_line": "right_y = [p for p in sorted_y if p[0] > mid_point[-1]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[-1]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "right_y = [p for p in sorted_y if p[0] > mid_point[0]]",
      "mutated_line": "right_y = [p for p in sorted_y if p[0] > mid_point[1]]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[1]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[1], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[1], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[-1], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[-1], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[1], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[1], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[2]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[2]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[0]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[0]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[0]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[0]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[-1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[-1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[1], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[1], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[-1], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[-1], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[1], right_pair[1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[1], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[2]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[2]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[0]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[0]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[0]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[0]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair",
      "mutated_line": "min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[-1]) else right_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[-1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] + mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] + mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] * mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] * mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[1], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[1], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[-1], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[-1], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[1], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[1], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[2]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[2]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[0]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[0]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[0]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[0]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[-1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[-1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[1], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[1], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[-1], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[-1], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[1], min_pair[1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[1], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[2]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[2]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[0]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[0]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[0]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[0]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair",
      "mutated_line": "return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[-1]) else min_pair",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[-1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[-1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[-1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[-1]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[-1]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[2] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[2] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[-1] - p2[1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[-1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[2]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[2]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[-1]) ** 2)",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[-1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[1], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[1], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[-1], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[-1], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[1], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[1], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[2])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[2])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[0])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[0])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[0])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[0])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[-1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[-1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[1] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[1] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[-1] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[-1] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[1] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[1] - mid_point[0]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[1]) < distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[1]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[-1]) < distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[-1]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[0]) < distance(min_pair[0], min_pair[1])]",
      "mutated_line": "strip = [p for p in sorted_y if abs(p[0] - mid_point[1]) < distance(min_pair[0], min_pair[1])]",
      "code": "import math\n\ndef closest_pair(points):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = ()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair\n\n    def closest_pair_recursive(sorted_x, sorted_y):\n        n = len(sorted_x)\n        if n <= 3:\n            return brute_force(sorted_x)\n        mid = n // 2\n        mid_point = sorted_x[mid]\n        left_x = sorted_x[:mid]\n        right_x = sorted_x[mid:]\n        left_y = [p for p in sorted_y if p[0] <= mid_point[0]]\n        right_y = [p for p in sorted_y if p[0] > mid_point[0]]\n        left_pair = closest_pair_recursive(left_x, left_y)\n        right_pair = closest_pair_recursive(right_x, right_y)\n        min_pair = left_pair if distance(left_pair[0], left_pair[1]) < distance(right_pair[0], right_pair[1]) else right_pair\n        strip = [p for p in sorted_y if abs(p[0] - mid_point[1]) < distance(min_pair[0], min_pair[1])]\n        strip_closest = brute_force(strip)\n        return strip_closest if distance(strip_closest[0], strip_closest[1]) < distance(min_pair[0], min_pair[1]) else min_pair\n    sorted_x = sorted(points, key=lambda x: x[0])\n    sorted_y = sorted(points, key=lambda x: x[1])\n    return closest_pair_recursive(sorted_x, sorted_y)"
    }
  ]
}