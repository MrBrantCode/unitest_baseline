{
  "task_id": "cf_10661",
  "entry_point": "bfs_shortest_path",
  "mutant_count": 7,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance = {start: 0}",
      "mutated_line": "distance = {start: 1}",
      "code": "from collections import deque\n\ndef bfs_shortest_path(graph, start, end):\n    queue = deque()\n    queue.append(start)\n    visited = set()\n    visited.add(start)\n    distance = {start: 1}\n    previous = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            path = []\n            while node:\n                path.append(node)\n                node = previous[node]\n            return list(reversed(path))\n        for (neighbor, weight) in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                distance[neighbor] = distance[node] + weight\n                previous[neighbor] = node\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance = {start: 0}",
      "mutated_line": "distance = {start: -1}",
      "code": "from collections import deque\n\ndef bfs_shortest_path(graph, start, end):\n    queue = deque()\n    queue.append(start)\n    visited = set()\n    visited.add(start)\n    distance = {start: -1}\n    previous = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            path = []\n            while node:\n                path.append(node)\n                node = previous[node]\n            return list(reversed(path))\n        for (neighbor, weight) in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                distance[neighbor] = distance[node] + weight\n                previous[neighbor] = node\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance = {start: 0}",
      "mutated_line": "distance = {start: 1}",
      "code": "from collections import deque\n\ndef bfs_shortest_path(graph, start, end):\n    queue = deque()\n    queue.append(start)\n    visited = set()\n    visited.add(start)\n    distance = {start: 1}\n    previous = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            path = []\n            while node:\n                path.append(node)\n                node = previous[node]\n            return list(reversed(path))\n        for (neighbor, weight) in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                distance[neighbor] = distance[node] + weight\n                previous[neighbor] = node\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if node == end:",
      "mutated_line": "if node != end:",
      "code": "from collections import deque\n\ndef bfs_shortest_path(graph, start, end):\n    queue = deque()\n    queue.append(start)\n    visited = set()\n    visited.add(start)\n    distance = {start: 0}\n    previous = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node != end:\n            path = []\n            while node:\n                path.append(node)\n                node = previous[node]\n            return list(reversed(path))\n        for (neighbor, weight) in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                distance[neighbor] = distance[node] + weight\n                previous[neighbor] = node\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if neighbor not in visited:",
      "mutated_line": "if neighbor in visited:",
      "code": "from collections import deque\n\ndef bfs_shortest_path(graph, start, end):\n    queue = deque()\n    queue.append(start)\n    visited = set()\n    visited.add(start)\n    distance = {start: 0}\n    previous = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            path = []\n            while node:\n                path.append(node)\n                node = previous[node]\n            return list(reversed(path))\n        for (neighbor, weight) in graph[node]:\n            if neighbor in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                distance[neighbor] = distance[node] + weight\n                previous[neighbor] = node\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance[neighbor] = distance[node] + weight",
      "mutated_line": "distance[neighbor] = distance[node] - weight",
      "code": "from collections import deque\n\ndef bfs_shortest_path(graph, start, end):\n    queue = deque()\n    queue.append(start)\n    visited = set()\n    visited.add(start)\n    distance = {start: 0}\n    previous = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            path = []\n            while node:\n                path.append(node)\n                node = previous[node]\n            return list(reversed(path))\n        for (neighbor, weight) in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                distance[neighbor] = distance[node] - weight\n                previous[neighbor] = node\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance[neighbor] = distance[node] + weight",
      "mutated_line": "distance[neighbor] = distance[node] * weight",
      "code": "from collections import deque\n\ndef bfs_shortest_path(graph, start, end):\n    queue = deque()\n    queue.append(start)\n    visited = set()\n    visited.add(start)\n    distance = {start: 0}\n    previous = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            path = []\n            while node:\n                path.append(node)\n                node = previous[node]\n            return list(reversed(path))\n        for (neighbor, weight) in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                distance[neighbor] = distance[node] * weight\n                previous[neighbor] = node\n    return None"
    }
  ]
}