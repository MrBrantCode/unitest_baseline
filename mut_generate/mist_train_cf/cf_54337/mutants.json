{
  "task_id": "cf_54337",
  "entry_point": "is_happy",
  "mutant_count": 102,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_happy(s):\n    \"\"\"\"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(s) < 3:",
      "mutated_line": "if len(s) <= 3:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) <= 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(s) < 3:",
      "mutated_line": "if len(s) >= 3:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) >= 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(s) < 3:",
      "mutated_line": "if len(s) != 3:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) != 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "min_count = max_count = -1",
      "mutated_line": "min_count = max_count = +1",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = +1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(s) < 3:",
      "mutated_line": "if len(s) < 4:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 4:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(s) < 3:",
      "mutated_line": "if len(s) < 2:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 2:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(s) < 3:",
      "mutated_line": "if len(s) < 0:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 0:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(s) < 3:",
      "mutated_line": "if len(s) < 1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 1:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(s) < 3:",
      "mutated_line": "if len(s) < -3:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < -3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return True\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(s) == i:",
      "mutated_line": "if len(s) != i:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) != i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] or s[i] != s[i - 2] or s[i - 1] != s[i - 2]",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] or s[i] != s[i - 2] or s[i - 1] != s[i - 2]\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 1 or s[i] == s[i - 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 or s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if i >= 2 and not consecutive_distinct(s, i):",
      "mutated_line": "if i >= 2 or not consecutive_distinct(s, i):",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 or not consecutive_distinct(s, i):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1",
      "mutated_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) - 1",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) - 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1",
      "mutated_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) * 1",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) * 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_count = max_count = -1",
      "mutated_line": "min_count = max_count = -2",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -2\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_count = max_count = -1",
      "mutated_line": "min_count = max_count = -0",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -0\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_count = max_count = -1",
      "mutated_line": "min_count = max_count = -0",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -0\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_count = max_count = -1",
      "mutated_line": "min_count = max_count = --1",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = --1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -1 or max_count == -1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 or max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if min_count != max_count:",
      "mutated_line": "if min_count == max_count:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count == max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return False",
      "mutated_line": "return False",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return True\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] == s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] == s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] == s[i - 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] == s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] == s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] == s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i > 1 and s[i] == s[i - 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i > 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i < 1 and s[i] == s[i - 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i < 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i == 1 and s[i] == s[i - 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i == 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 1 and s[i] != s[i - 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] != s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return False",
      "mutated_line": "return False",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return True\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i >= 2 and not consecutive_distinct(s, i):",
      "mutated_line": "if i > 2 and (not consecutive_distinct(s, i)):",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i > 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i >= 2 and not consecutive_distinct(s, i):",
      "mutated_line": "if i < 2 and (not consecutive_distinct(s, i)):",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i < 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i >= 2 and not consecutive_distinct(s, i):",
      "mutated_line": "if i == 2 and (not consecutive_distinct(s, i)):",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i == 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return True\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1",
      "mutated_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 2",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 2\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1",
      "mutated_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 0",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 0\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1",
      "mutated_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 0",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 0\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1",
      "mutated_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + -1",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + -1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count != -1 and max_count == -1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count != -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -1 and max_count != -1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count != -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "elif count != min_count and count != max_count:",
      "mutated_line": "elif count != min_count or count != max_count:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count or count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return True\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 2 and s[i] == s[i - 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 2 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 0 and s[i] == s[i - 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 0 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 0 and s[i] == s[i - 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 0 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= -1 and s[i] == s[i - 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= -1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i >= 2 and not consecutive_distinct(s, i):",
      "mutated_line": "if i >= 3 and (not consecutive_distinct(s, i)):",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 3 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i >= 2 and not consecutive_distinct(s, i):",
      "mutated_line": "if i >= 1 and (not consecutive_distinct(s, i)):",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 1 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i >= 2 and not consecutive_distinct(s, i):",
      "mutated_line": "if i >= 0 and (not consecutive_distinct(s, i)):",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 0 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i >= 2 and not consecutive_distinct(s, i):",
      "mutated_line": "if i >= 1 and (not consecutive_distinct(s, i)):",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 1 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i >= 2 and not consecutive_distinct(s, i):",
      "mutated_line": "if i >= -2 and (not consecutive_distinct(s, i)):",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= -2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1",
      "mutated_line": "letter_dict[s[i]] = letter_dict.get(s[i], 1) + 1",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 1) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1",
      "mutated_line": "letter_dict[s[i]] = letter_dict.get(s[i], -1) + 1",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], -1) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1",
      "mutated_line": "letter_dict[s[i]] = letter_dict.get(s[i], 1) + 1",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 1) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == +1 and max_count == -1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == +1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -1 and max_count == +1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == +1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif count != min_count and count != max_count:",
      "mutated_line": "elif count == min_count and count != max_count:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count == min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif count != min_count and count != max_count:",
      "mutated_line": "elif count != min_count and count == max_count:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count == max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return True\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i + 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i + 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i * 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i * 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i + 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i + 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i * 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i * 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i + 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i + 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i * 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i * 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i + 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i + 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i * 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i * 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 1 and s[i] == s[i + 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i + 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 1 and s[i] == s[i * 1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i * 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -2 and max_count == -1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -2 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -0 and max_count == -1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -0 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -0 and max_count == -1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -0 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == --1 and max_count == -1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == --1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -1 and max_count == -2:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -2:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -1 and max_count == -0:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -0:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -1 and max_count == -0:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -0:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if min_count == -1 and max_count == -1:",
      "mutated_line": "if min_count == -1 and max_count == --1:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == --1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 2] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 2] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 0] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 0] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 0] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 0] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - -1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - -1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 3] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 3] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 1] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 1] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 0] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 0] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 1] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 1] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - -2] and (s[i - 1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - -2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 2] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 2] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 0] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 0] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 0] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 0] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - -1] != s[i - 2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - -1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 3])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 3])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 1])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 1])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 0])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 0])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 1])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 1])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2]",
      "mutated_line": "return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - -2])",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - -2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 1 and s[i] == s[i - 2]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 2]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 1 and s[i] == s[i - 0]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 0]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 1 and s[i] == s[i - 0]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - 0]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i >= 1 and s[i] == s[i-1]:",
      "mutated_line": "if i >= 1 and s[i] == s[i - -1]:",
      "code": "def is_happy(s):\n    \"\"\"\n    Checks if a given string s is happy.\n    A string is happy if its length is at least 3, every 3 consecutive letters are distinct, \n    every distinct letter appears at least twice, there should not be any consecutive repeating letters, \n    and the count of each distinct letter should be equal.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    letter_dict = {}\n\n    def consecutive_distinct(s, i):\n        if len(s) == i:\n            return False\n        return s[i] != s[i - 1] and s[i] != s[i - 2] and (s[i - 1] != s[i - 2])\n    for i in range(len(s)):\n        if i >= 1 and s[i] == s[i - -1]:\n            return False\n        if i >= 2 and (not consecutive_distinct(s, i)):\n            return False\n        letter_dict[s[i]] = letter_dict.get(s[i], 0) + 1\n    min_count = max_count = -1\n    for count in letter_dict.values():\n        if min_count == -1 and max_count == -1:\n            min_count = max_count = count\n        elif count != min_count and count != max_count:\n            return False\n        else:\n            min_count = min(min_count, count)\n            max_count = max(max_count, count)\n        if min_count != max_count:\n            return False\n    return True"
    }
  ]
}