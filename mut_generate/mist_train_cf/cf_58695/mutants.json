{
  "task_id": "cf_58695",
  "entry_point": "is_palindrome",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\"\"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if l >= r:",
      "mutated_line": "if l > r:",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l > r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if l >= r:",
      "mutated_line": "if l < r:",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l < r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if l >= r:",
      "mutated_line": "if l == r:",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l == r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if string[l].lower() != string[r].lower():",
      "mutated_line": "if string[l].lower() == string[r].lower():",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() == string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "\"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"\"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return string + string[::-1]",
      "mutated_line": "return string - string[::-1]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string - string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return string + string[::-1]",
      "mutated_line": "return string * string[::-1]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string * string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return False\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return True\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l - 1, r - 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l - 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l * 1, r - 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l * 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + 1, r + 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r + 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + 1, r * 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r * 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return is_palindrome(string, l + 1, r)",
      "mutated_line": "return is_palindrome(string, l - 1, r)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l - 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return is_palindrome(string, l + 1, r)",
      "mutated_line": "return is_palindrome(string, l * 1, r)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l * 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return is_palindrome(string, l, r - 1)",
      "mutated_line": "return is_palindrome(string, l, r + 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r + 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return is_palindrome(string, l, r - 1)",
      "mutated_line": "return is_palindrome(string, l, r * 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r * 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + 2, r - 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 2, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + 0, r - 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 0, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + 0, r - 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 0, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + -1, r - 1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + -1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + 1, r - 2)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 2)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + 1, r - 0)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 0)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + 1, r - 0)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 0)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return is_palindrome(string, l + 1, r - 1)",
      "mutated_line": "return is_palindrome(string, l + 1, r - -1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - -1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if is_palindrome(string, i, len(string) - 1):",
      "mutated_line": "if is_palindrome(string, i, len(string) + 1):",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) + 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if is_palindrome(string, i, len(string) - 1):",
      "mutated_line": "if is_palindrome(string, i, len(string) * 1):",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) * 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return string + prefix[::-1]",
      "mutated_line": "return string - prefix[::-1]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string - prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return string + prefix[::-1]",
      "mutated_line": "return string * prefix[::-1]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string * prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return is_palindrome(string, l + 1, r)",
      "mutated_line": "return is_palindrome(string, l + 2, r)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 2, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return is_palindrome(string, l + 1, r)",
      "mutated_line": "return is_palindrome(string, l + 0, r)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 0, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return is_palindrome(string, l + 1, r)",
      "mutated_line": "return is_palindrome(string, l + 0, r)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 0, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return is_palindrome(string, l + 1, r)",
      "mutated_line": "return is_palindrome(string, l + -1, r)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + -1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(string, l, r - 1)",
      "mutated_line": "return is_palindrome(string, l, r - 2)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 2)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(string, l, r - 1)",
      "mutated_line": "return is_palindrome(string, l, r - 0)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 0)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(string, l, r - 1)",
      "mutated_line": "return is_palindrome(string, l, r - 0)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 0)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(string, l, r - 1)",
      "mutated_line": "return is_palindrome(string, l, r - -1)",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - -1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if is_palindrome(string, i, len(string) - 1):",
      "mutated_line": "if is_palindrome(string, i, len(string) - 2):",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 2):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if is_palindrome(string, i, len(string) - 1):",
      "mutated_line": "if is_palindrome(string, i, len(string) - 0):",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 0):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if is_palindrome(string, i, len(string) - 1):",
      "mutated_line": "if is_palindrome(string, i, len(string) - 0):",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 0):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if is_palindrome(string, i, len(string) - 1):",
      "mutated_line": "if is_palindrome(string, i, len(string) - -1):",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - -1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return string + string[::-1]",
      "mutated_line": "return string + string[::+1]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::+1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefix = string[0:i]",
      "mutated_line": "prefix = string[1:i]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[1:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefix = string[0:i]",
      "mutated_line": "prefix = string[-1:i]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[-1:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefix = string[0:i]",
      "mutated_line": "prefix = string[1:i]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[1:i]\n            return string + prefix[::-1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return string + string[::-1]",
      "mutated_line": "return string + string[::-2]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-2]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return string + string[::-1]",
      "mutated_line": "return string + string[::-0]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return string + string[::-1]",
      "mutated_line": "return string + string[::-0]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::-0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return string + string[::-1]",
      "mutated_line": "return string + string[::--1]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-1]\n    return string + string[::--1]"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "return string + prefix[::-1]",
      "mutated_line": "return string + prefix[::+1]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::+1]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return string + prefix[::-1]",
      "mutated_line": "return string + prefix[::-2]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-2]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return string + prefix[::-1]",
      "mutated_line": "return string + prefix[::-0]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-0]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return string + prefix[::-1]",
      "mutated_line": "return string + prefix[::-0]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::-0]\n    return string + string[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return string + prefix[::-1]",
      "mutated_line": "return string + prefix[::--1]",
      "code": "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string) - 1):\n            prefix = string[0:i]\n            return string + prefix[::--1]\n    return string + string[::-1]"
    }
  ]
}