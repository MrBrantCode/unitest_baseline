{
  "task_id": "cf_2602",
  "entry_point": "longest_substring",
  "mutant_count": 63,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 1\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "start = 0",
      "mutated_line": "start = -1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = -1\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 1\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_length = 0",
      "mutated_line": "max_length = 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 1\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_length = 0",
      "mutated_line": "max_length = -1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = -1\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_length = 0",
      "mutated_line": "max_length = 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 1\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "\"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "return c.isupper() or c.islower() or c.isdigit()",
      "mutated_line": "return c.isupper() and c.islower() and c.isdigit()",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() and c.islower() and c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "\"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "return any(c.isupper() for c in s) and any(c.islower() for c in s) and any(c.isdigit() for c in s)",
      "mutated_line": "return any((c.isupper() for c in s)) or any((c.islower() for c in s)) or any((c.isdigit() for c in s))",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) or any((c.islower() for c in s)) or any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "\"\"\"Check if a string is in lexicographical order.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "return s == ''.join(sorted(s))",
      "mutated_line": "return s != ''.join(sorted(s))",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s != ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "start = end + 1",
      "mutated_line": "start = end - 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end - 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "start = end + 1",
      "mutated_line": "start = end * 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end * 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif c in char_set:",
      "mutated_line": "elif c not in char_set:",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c not in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "start = end + 1",
      "mutated_line": "start = end + 2",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 2\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "start = end + 1",
      "mutated_line": "start = end + 0",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 0\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "start = end + 1",
      "mutated_line": "start = end + 0",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 0\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "start = end + 1",
      "mutated_line": "start = end + -1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + -1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while c in char_set:",
      "mutated_line": "while c not in char_set:",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c not in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "start += 1",
      "mutated_line": "start -= 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start -= 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length or start == 0 or is_lexicographical_order(s[start:end + 1]) or has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length or start == 0 or is_lexicographical_order(s[start:end + 1]) or has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return s == ''.join(sorted(s))",
      "mutated_line": "return s == 'MUTATED'.join(sorted(s))",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == 'MUTATED'.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start += 1",
      "mutated_line": "start += 2",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 2\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start += 1",
      "mutated_line": "start += 0",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 0\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start += 1",
      "mutated_line": "start += 0",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 0\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start += 1",
      "mutated_line": "start += -1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += -1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 >= max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 >= max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 <= max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 <= max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 != max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 != max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start != 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start != 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "max_length = end - start + 1",
      "mutated_line": "max_length = end - start - 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start - 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "max_length = end - start + 1",
      "mutated_line": "max_length = (end - start) * 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = (end - start) * 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start - 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start - 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if (end - start) * 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if (end - start) * 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 1 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 1 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == -1 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == -1 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 1 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 1 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "max_length = end - start + 1",
      "mutated_line": "max_length = end + start + 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end + start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "max_length = end - start + 1",
      "mutated_line": "max_length = end * start + 1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end * start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "max_length = end - start + 1",
      "mutated_line": "max_length = end - start + 2",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 2\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "max_length = end - start + 1",
      "mutated_line": "max_length = end - start + 0",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 0\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "max_length = end - start + 1",
      "mutated_line": "max_length = end - start + 0",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 0\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "max_length = end - start + 1",
      "mutated_line": "max_length = end - start + -1",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + -1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end + start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end + start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end * start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end * start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 2 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 2 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 0 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 0 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 0 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 0 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + -1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + -1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end - 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end - 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end * 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end * 1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end - 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end - 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end * 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end * 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 2]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 2]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 0]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 0]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 0]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 0]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + -1]) and has_upper_lower_digit(s[start:end + 1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + -1]) and has_upper_lower_digit(s[start:end + 1]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 2]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 2]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 0]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 0]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 0]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 0]):\n                max_length = end - start + 1\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (end - start + 1) > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + 1]):",
      "mutated_line": "if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + -1]):",
      "code": "def longest_substring(s: str) -> int:\n    \"\"\"\n    This function finds the length of the longest substring without repeating characters \n    in a given string that meets the conditions:\n    - contains at least one uppercase letter, one lowercase letter, and one digit\n    - is in lexicographical order\n    - starts with an uppercase letter\n    - does not contain any special characters or symbols.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The length of the longest substring that meets the conditions.\n    \"\"\"\n\n    def is_valid(c):\n        \"\"\"Check if a character is an uppercase letter, lowercase letter, or digit.\"\"\"\n        return c.isupper() or c.islower() or c.isdigit()\n\n    def has_upper_lower_digit(s):\n        \"\"\"Check if a string contains at least one uppercase letter, one lowercase letter, and one digit.\"\"\"\n        return any((c.isupper() for c in s)) and any((c.islower() for c in s)) and any((c.isdigit() for c in s))\n\n    def is_lexicographical_order(s):\n        \"\"\"Check if a string is in lexicographical order.\"\"\"\n        return s == ''.join(sorted(s))\n    start = 0\n    max_length = 0\n    char_set = set()\n    for (end, c) in enumerate(s):\n        if not is_valid(c):\n            start = end + 1\n            char_set = set()\n        elif c in char_set:\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n        else:\n            char_set.add(c)\n            if end - start + 1 > max_length and start == 0 and is_lexicographical_order(s[start:end + 1]) and has_upper_lower_digit(s[start:end + -1]):\n                max_length = end - start + 1\n    return max_length"
    }
  ]
}