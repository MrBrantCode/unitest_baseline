{
  "task_id": "cf_19869",
  "entry_point": "create_sparse_matrix",
  "mutant_count": 14,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "row_pointers = np.zeros(num_rows + 1, dtype=int)",
      "mutated_line": "for (i, (row, col, val)) in enumerate(non_zero_elements):",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows - 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "row_pointers = np.zeros(num_rows + 1, dtype=int)",
      "mutated_line": "for (i, (row, col, val)) in enumerate(non_zero_elements):",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows * 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "row_pointers = np.zeros(num_rows + 1, dtype=int)",
      "mutated_line": "for (i, (row, col, val)) in enumerate(non_zero_elements):",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 2, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "row_pointers = np.zeros(num_rows + 1, dtype=int)",
      "mutated_line": "for (i, (row, col, val)) in enumerate(non_zero_elements):",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 0, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "row_pointers = np.zeros(num_rows + 1, dtype=int)",
      "mutated_line": "for (i, (row, col, val)) in enumerate(non_zero_elements):",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 0, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "row_pointers = np.zeros(num_rows + 1, dtype=int)",
      "mutated_line": "for (i, (row, col, val)) in enumerate(non_zero_elements):",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + -1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "row_pointers[1:] = np.cumsum(row_counts)",
      "mutated_line": "row_pointers[2:] = np.cumsum(row_counts)",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[2:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "row_pointers[1:] = np.cumsum(row_counts)",
      "mutated_line": "row_pointers[0:] = np.cumsum(row_counts)",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[0:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "row_pointers[1:] = np.cumsum(row_counts)",
      "mutated_line": "row_pointers[0:] = np.cumsum(row_counts)",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[0:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "row_pointers[1:] = np.cumsum(row_counts)",
      "mutated_line": "row_pointers[-1:] = np.cumsum(row_counts)",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[-1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)",
      "mutated_line": "row_counts = np.bincount([x[1] for x in non_zero_elements], minlength=num_rows)",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[1] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)",
      "mutated_line": "row_counts = np.bincount([x[-1] for x in non_zero_elements], minlength=num_rows)",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[-1] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "row_counts = np.bincount([x[0] for x in non_zero_elements], minlength=num_rows)",
      "mutated_line": "row_counts = np.bincount([x[1] for x in non_zero_elements], minlength=num_rows)",
      "code": "import numpy as np\n\ndef create_sparse_matrix(num_rows, num_cols, non_zero_elements):\n    \"\"\"\n    Creates a sparse matrix in the Compressed Sparse Row (CSR) format.\n\n    Args:\n    num_rows (int): The number of rows in the sparse matrix.\n    num_cols (int): The number of columns in the sparse matrix.\n    non_zero_elements (list): A list of tuples containing the row index, column index, and value of each non-zero element.\n\n    Returns:\n    values (numpy.ndarray): The values array of the CSR format, containing the non-zero elements of the matrix.\n    col_indices (numpy.ndarray): The column indices array of the CSR format, storing the column index for each non-zero element.\n    row_pointers (numpy.ndarray): The row pointer array of the CSR format, indicating the starting index in the values array for each row.\n    \"\"\"\n    values = np.zeros(len(non_zero_elements))\n    col_indices = np.zeros(len(non_zero_elements), dtype=int)\n    row_pointers = np.zeros(num_rows + 1, dtype=int)\n    for (i, (row, col, val)) in enumerate(non_zero_elements):\n        values[i] = val\n        col_indices[i] = col\n    row_counts = np.bincount([x[1] for x in non_zero_elements], minlength=num_rows)\n    row_pointers[1:] = np.cumsum(row_counts)\n    return (values, col_indices, row_pointers)"
    }
  ]
}