{
  "task_id": "cf_98656",
  "entry_point": "calculate_coulomb_matrix",
  "mutant_count": 11,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i == j:",
      "mutated_line": "if i != j:",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i != j:\n                coulomb_matrix[i, j] = 0\n            else:\n                distance = np.linalg.norm(positions[i] - positions[j])\n                coulomb_matrix[i, j] = charges[i] * charges[j] / distance\n    return coulomb_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "coulomb_matrix[i, j] = 0",
      "mutated_line": "coulomb_matrix[i, j] = 1",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = 1\n            else:\n                distance = np.linalg.norm(positions[i] - positions[j])\n                coulomb_matrix[i, j] = charges[i] * charges[j] / distance\n    return coulomb_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "coulomb_matrix[i, j] = 0",
      "mutated_line": "coulomb_matrix[i, j] = -1",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = -1\n            else:\n                distance = np.linalg.norm(positions[i] - positions[j])\n                coulomb_matrix[i, j] = charges[i] * charges[j] / distance\n    return coulomb_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "coulomb_matrix[i, j] = 0",
      "mutated_line": "coulomb_matrix[i, j] = 1",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = 1\n            else:\n                distance = np.linalg.norm(positions[i] - positions[j])\n                coulomb_matrix[i, j] = charges[i] * charges[j] / distance\n    return coulomb_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "coulomb_matrix[i, j] = charges[i] * charges[j] / distance",
      "mutated_line": "coulomb_matrix[i, j] = charges[i] * charges[j] * distance",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = 0\n            else:\n                distance = np.linalg.norm(positions[i] - positions[j])\n                coulomb_matrix[i, j] = charges[i] * charges[j] * distance\n    return coulomb_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "coulomb_matrix[i, j] = charges[i] * charges[j] / distance",
      "mutated_line": "coulomb_matrix[i, j] = charges[i] * charges[j] // distance",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = 0\n            else:\n                distance = np.linalg.norm(positions[i] - positions[j])\n                coulomb_matrix[i, j] = charges[i] * charges[j] // distance\n    return coulomb_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "distance = np.linalg.norm(positions[i] - positions[j])",
      "mutated_line": "distance = np.linalg.norm(positions[i] + positions[j])",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = 0\n            else:\n                distance = np.linalg.norm(positions[i] + positions[j])\n                coulomb_matrix[i, j] = charges[i] * charges[j] / distance\n    return coulomb_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "distance = np.linalg.norm(positions[i] - positions[j])",
      "mutated_line": "distance = np.linalg.norm(positions[i] * positions[j])",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = 0\n            else:\n                distance = np.linalg.norm(positions[i] * positions[j])\n                coulomb_matrix[i, j] = charges[i] * charges[j] / distance\n    return coulomb_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "coulomb_matrix[i, j] = charges[i] * charges[j] / distance",
      "mutated_line": "coulomb_matrix[i, j] = charges[i] / charges[j] / distance",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = 0\n            else:\n                distance = np.linalg.norm(positions[i] - positions[j])\n                coulomb_matrix[i, j] = charges[i] / charges[j] / distance\n    return coulomb_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "coulomb_matrix[i, j] = charges[i] * charges[j] / distance",
      "mutated_line": "coulomb_matrix[i, j] = (charges[i] + charges[j]) / distance",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = 0\n            else:\n                distance = np.linalg.norm(positions[i] - positions[j])\n                coulomb_matrix[i, j] = (charges[i] + charges[j]) / distance\n    return coulomb_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "coulomb_matrix[i, j] = charges[i] * charges[j] / distance",
      "mutated_line": "coulomb_matrix[i, j] = charges[i] ** charges[j] / distance",
      "code": "import numpy as np\n\ndef calculate_coulomb_matrix(charges, positions):\n    n_atoms = len(charges)\n    coulomb_matrix = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(n_atoms):\n            if i == j:\n                coulomb_matrix[i, j] = 0\n            else:\n                distance = np.linalg.norm(positions[i] - positions[j])\n                coulomb_matrix[i, j] = charges[i] ** charges[j] / distance\n    return coulomb_matrix"
    }
  ]
}