{
  "task_id": "cf_73103",
  "entry_point": "minPathSumSequence",
  "mutant_count": 101,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "while minheap and len(sequence) < k:",
      "mutated_line": "(min_dist, x, y) = heapq.heappop(minheap)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap or len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 <= x < N or 0 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N or 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [[0]*N for _ in range(N)]",
      "mutated_line": "visited = [[0] / N for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] / N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [[0]*N for _ in range(N)]",
      "mutated_line": "visited = [[0] + N for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] + N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [[0]*N for _ in range(N)]",
      "mutated_line": "visited = [[0] ** N for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] ** N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while minheap and len(sequence) < k:",
      "mutated_line": "(min_dist, x, y) = heapq.heappop(minheap)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) <= k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while minheap and len(sequence) < k:",
      "mutated_line": "(min_dist, x, y) = heapq.heappop(minheap)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) >= k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while minheap and len(sequence) < k:",
      "mutated_line": "(min_dist, x, y) = heapq.heappop(minheap)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) != k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if visited[x][y] == 1:",
      "mutated_line": "if visited[x][y] != 1:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] != 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[x][y] = 1",
      "mutated_line": "visited[x][y] = 2",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 2\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[x][y] = 1",
      "mutated_line": "visited[x][y] = 0",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 0\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[x][y] = 1",
      "mutated_line": "visited[x][y] = 0",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 0\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[x][y] = 1",
      "mutated_line": "visited[x][y] = -1",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = -1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(minheap) > 0:",
      "mutated_line": "if len(minheap) >= 0:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) >= 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(minheap) > 0:",
      "mutated_line": "if len(minheap) <= 0:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) <= 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(minheap) > 0:",
      "mutated_line": "if len(minheap) != 0:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) != 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[0][0], 1, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 1, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[0][0], -1, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], -1, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[0][0], 1, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 1, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[0][0], 0, 1)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 1)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[0][0], 0, -1)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, -1)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[0][0], 0, 1)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 1)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[1, -1], [-1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[1, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[-1, -1], [-1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[-1, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[1, -1], [-1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[1, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, +1], [-1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, +1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [+1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [+1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 1], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 1], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, -1], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, -1], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 1], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 1], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [1, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [1, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [-1, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [-1, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [1, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [1, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 2], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 2], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 0], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 0], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 0], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 0], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, -1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, -1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 1], [2, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [2, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 1], [0, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [0, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 1], [0, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [0, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 1], [-1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [-1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 1]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 1]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, -1]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, -1]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 1]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 1]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 < x < N and 0 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 < x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 > x < N and 0 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 > x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 == x < N and 0 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 == x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 <= x < N and 0 < y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 < y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 <= x < N and 0 > y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 > y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 <= x < N and 0 == y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 == y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sequence = [grid[0][0]]",
      "mutated_line": "sequence = [grid[0][1]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][1]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sequence = [grid[0][0]]",
      "mutated_line": "sequence = [grid[0][-1]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][-1]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sequence = [grid[0][0]]",
      "mutated_line": "sequence = [grid[0][1]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][1]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if visited[x][y] == 1:",
      "mutated_line": "if visited[x][y] == 2:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 2:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if visited[x][y] == 1:",
      "mutated_line": "if visited[x][y] == 0:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 0:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if visited[x][y] == 1:",
      "mutated_line": "if visited[x][y] == 0:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 0:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if visited[x][y] == 1:",
      "mutated_line": "if visited[x][y] == -1:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == -1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if valid(newX, newY) and visited[newX][newY] == 0:",
      "mutated_line": "if valid(newX, newY) or visited[newX][newY] == 0:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) or visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(minheap) > 0:",
      "mutated_line": "if len(minheap) > 1:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 1:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(minheap) > 0:",
      "mutated_line": "if len(minheap) > -1:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > -1:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(minheap) > 0:",
      "mutated_line": "if len(minheap) > 1:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 1:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[0][1], 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][1], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[0][-1], 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][-1], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[0][1], 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][1], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -2], [-1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -2], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -0], [-1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -0], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -0], [-1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -0], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, --1], [-1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, --1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-2, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-2, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-0, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-0, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [-0, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-0, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]",
      "mutated_line": "dirs = [[0, -1], [--1, 0], [0, 1], [1, 0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [--1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 1 <= x < N and 0 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 1 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return -1 <= x < N and 0 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return -1 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 1 <= x < N and 0 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 1 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 <= x < N and 1 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 1 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 <= x < N and -1 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and -1 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0 <= x < N and 0 <= y < N",
      "mutated_line": "return 0 <= x < N and 1 <= y < N",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 1 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [[0]*N for _ in range(N)]",
      "mutated_line": "visited = [[1] * N for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[1] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [[0]*N for _ in range(N)]",
      "mutated_line": "visited = [[-1] * N for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[-1] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [[0]*N for _ in range(N)]",
      "mutated_line": "visited = [[1] * N for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[1] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sequence = [grid[0][0]]",
      "mutated_line": "sequence = [grid[1][0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[1][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sequence = [grid[0][0]]",
      "mutated_line": "sequence = [grid[-1][0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[-1][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sequence = [grid[0][0]]",
      "mutated_line": "sequence = [grid[1][0]]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[1][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "newX, newY = x + dx, y + dy",
      "mutated_line": "(newX, newY) = (x - dx, y + dy)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x - dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "newX, newY = x + dx, y + dy",
      "mutated_line": "(newX, newY) = (x * dx, y + dy)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x * dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "newX, newY = x + dx, y + dy",
      "mutated_line": "(newX, newY) = (x + dx, y - dy)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y - dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "newX, newY = x + dx, y + dy",
      "mutated_line": "(newX, newY) = (x + dx, y * dy)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y * dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if valid(newX, newY) and visited[newX][newY] == 0:",
      "mutated_line": "if valid(newX, newY) and visited[newX][newY] != 0:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] != 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[1][0], 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[1][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[-1][0], 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[-1][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minheap = [(grid[0][0], 0, 0)]",
      "mutated_line": "minheap = [(grid[1][0], 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[1][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if valid(newX, newY) and visited[newX][newY] == 0:",
      "mutated_line": "if valid(newX, newY) and visited[newX][newY] == 1:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 1:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if valid(newX, newY) and visited[newX][newY] == 0:",
      "mutated_line": "if valid(newX, newY) and visited[newX][newY] == -1:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == -1:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if valid(newX, newY) and visited[newX][newY] == 0:",
      "mutated_line": "if valid(newX, newY) and visited[newX][newY] == 1:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 1:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sequence.append(minheap[0][0])",
      "mutated_line": "sequence.append(minheap[0][1])",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][1])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sequence.append(minheap[0][0])",
      "mutated_line": "sequence.append(minheap[0][-1])",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][-1])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sequence.append(minheap[0][0])",
      "mutated_line": "sequence.append(minheap[0][1])",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[0][1])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sequence.append(minheap[0][0])",
      "mutated_line": "sequence.append(minheap[1][0])",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[1][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sequence.append(minheap[0][0])",
      "mutated_line": "sequence.append(minheap[-1][0])",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[-1][0])\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sequence.append(minheap[0][0])",
      "mutated_line": "sequence.append(minheap[1][0])",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0)]\n    dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]\n\n    def valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    visited = [[0] * N for _ in range(N)]\n    sequence = [grid[0][0]]\n    while minheap and len(sequence) < k:\n        (min_dist, x, y) = heapq.heappop(minheap)\n        if visited[x][y] == 1:\n            continue\n        visited[x][y] = 1\n        for (dx, dy) in dirs:\n            (newX, newY) = (x + dx, y + dy)\n            if valid(newX, newY) and visited[newX][newY] == 0:\n                heapq.heappush(minheap, (grid[newX][newY], newX, newY))\n        if len(minheap) > 0:\n            sequence.append(minheap[1][0])\n    return sequence"
    }
  ]
}