{
  "task_id": "cf_16767",
  "entry_point": "damerau_levenshtein_distance",
  "mutant_count": 159,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "len1 = len(word1) + 1",
      "mutated_line": "len1 = len(word1) - 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) - 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "len1 = len(word1) + 1",
      "mutated_line": "len1 = len(word1) * 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) * 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "len2 = len(word2) + 1",
      "mutated_line": "len2 = len(word2) - 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) - 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "len2 = len(word2) + 1",
      "mutated_line": "len2 = len(word2) * 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) * 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "len1 = len(word1) + 1",
      "mutated_line": "len1 = len(word1) + 2",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 2\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "len1 = len(word1) + 1",
      "mutated_line": "len1 = len(word1) + 0",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 0\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "len1 = len(word1) + 1",
      "mutated_line": "len1 = len(word1) + 0",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 0\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "len1 = len(word1) + 1",
      "mutated_line": "len1 = len(word1) + -1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + -1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "len2 = len(word2) + 1",
      "mutated_line": "len2 = len(word2) + 2",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 2\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "len2 = len(word2) + 1",
      "mutated_line": "len2 = len(word2) + 0",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 0\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "len2 = len(word2) + 1",
      "mutated_line": "len2 = len(word2) + 0",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 0\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "len2 = len(word2) + 1",
      "mutated_line": "len2 = len(word2) + -1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + -1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, len1):",
      "mutated_line": "for i in range(2, len1):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(2, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, len1):",
      "mutated_line": "for i in range(0, len1):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(0, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, len1):",
      "mutated_line": "for i in range(0, len1):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(0, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, len1):",
      "mutated_line": "for i in range(-1, len1):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(-1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - 1][len2 + 1]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - 1][len2 * 1]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 * 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0 for _ in range(len2)] for _ in range(len1)]",
      "mutated_line": "dp = [[1 for _ in range(len2)] for _ in range(len1)]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[1 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0 for _ in range(len2)] for _ in range(len1)]",
      "mutated_line": "dp = [[-1 for _ in range(len2)] for _ in range(len1)]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[-1 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0 for _ in range(len2)] for _ in range(len1)]",
      "mutated_line": "dp = [[1 for _ in range(len2)] for _ in range(len1)]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[1 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i][0] = i",
      "mutated_line": "dp[i][1] = i",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][1] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i][0] = i",
      "mutated_line": "dp[i][-1] = i",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][-1] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i][0] = i",
      "mutated_line": "dp[i][1] = i",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][1] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, len2):",
      "mutated_line": "for j in range(2, len2):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(2, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, len2):",
      "mutated_line": "for j in range(0, len2):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(0, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, len2):",
      "mutated_line": "for j in range(0, len2):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(0, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, len2):",
      "mutated_line": "for j in range(-1, len2):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(-1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 or j > 1 or word1[i - 1] == word2[j - 2] or (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 or j > 1 or word1[i - 1] == word2[j - 2] or (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 + 1][len2 - 1]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 + 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 * 1][len2 - 1]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 * 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - 1][len2 - 2]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 2]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - 1][len2 - 0]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - 1][len2 - 0]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - 1][len2 - -1]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - -1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0][j] = j",
      "mutated_line": "dp[1][j] = j",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[1][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0][j] = j",
      "mutated_line": "dp[-1][j] = j",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[-1][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0][j] = j",
      "mutated_line": "dp[1][j] = j",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[1][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] != word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] != word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 1 if word1[i - 1] == word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 1 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = -1 if word1[i - 1] == word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = -1 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 1 if word1[i - 1] == word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 1 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 2",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 2\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 0",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 0\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 0",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 0\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j - 1] else -1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else -1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - 1][j] - 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] - 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - 1][j] * 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] * 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] - 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] * 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] - cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] * cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i >= 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i >= 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i <= 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i <= 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i != 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i != 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j >= 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j >= 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j <= 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j <= 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j != 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j != 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] != word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] != word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] != word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] != word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - 2][len2 - 1]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 2][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - 0][len2 - 1]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 0][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - 0][len2 - 1]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 0][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[len1 - 1][len2 - 1]",
      "mutated_line": "return dp[len1 - -1][len2 - 1]",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - -1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - 1][j] + 2, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 2, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - 1][j] + 0, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 0, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - 1][j] + 0, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 0, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - 1][j] + -1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + -1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 2, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 0, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 0, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + -1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 2 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 2 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 0 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 0 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 0 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 0 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > -1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > -1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 2 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 2 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 0 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 0 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 0 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 0 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > -1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > -1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] - cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] - cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] * cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] * cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i + 1] == word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i + 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i * 1] == word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i * 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j + 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j + 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j * 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j * 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j + 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j * 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j + 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j * 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i + 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i + 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i * 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i * 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j + 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j + 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j * 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j * 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i + 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i + 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i * 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i * 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j + 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j + 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j * 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j * 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 2] == word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 2] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 0] == word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 0] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 0] == word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 0] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - -1] == word2[j - 1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - -1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j - 2] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 2] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j - 0] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 0] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j - 0] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 0] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 0 if word1[i - 1] == word2[j - 1] else 1",
      "mutated_line": "cost = 0 if word1[i - 1] == word2[j - -1] else 1",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - -1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i * 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i * 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 2] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 0] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 0] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[i][j - 1] + 1,      # Insertion",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - -1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i * 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 2] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 0] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 0] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - -1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 2] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 2] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 0] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 0] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 0] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 0] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - -1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - -1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 3]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 3]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 1]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 1]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 0]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 0]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 1]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 1]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - -2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - -2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 3] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 3] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 1] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 1] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 0] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 0] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 1] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 1] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - -2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - -2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 2]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 2]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 0]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 0]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 0]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 0]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]:",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - -1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - -1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j + 2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j + 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j * 2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j * 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - 2][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 2][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - 0][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 0][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - 0][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 0][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion",
      "mutated_line": "dp[i][j] = min(dp[i - -1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - -1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 2][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 0][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 0][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[i - 1][j - 1] + cost)  # Substitution or no operation",
      "mutated_line": "if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - -1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i + 2][j - 2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i + 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i * 2][j - 2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i * 2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 3] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 3] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 1] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 0] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 0] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 1] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 1] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - -2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - -2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 3][j - 2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 3][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 1][j - 2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 0][j - 2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 0][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - 1][j - 2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + cost)",
      "mutated_line": "dp[i][j] = min(dp[i][j], dp[i - -2][j - 2] + cost)",
      "code": "def damerau_levenshtein_distance(word1, word2):\n    \"\"\"\n    Compute the Damerau-Levenshtein distance between two words.\n\n    The Damerau-Levenshtein distance is a measure of the minimum number of single-character edits (insertions, deletions or substitutions)\n    required to change one word into the other, with the additional possibility of transpositions.\n\n    Args:\n        word1 (str): The first word.\n        word2 (str): The second word.\n\n    Returns:\n        int: The Damerau-Levenshtein distance between word1 and word2.\n    \"\"\"\n    len1 = len(word1) + 1\n    len2 = len(word2) + 1\n    dp = [[0 for _ in range(len2)] for _ in range(len1)]\n    for i in range(len1):\n        dp[i][0] = i\n    for j in range(len2):\n        dp[0][j] = j\n    for i in range(1, len1):\n        for j in range(1, len2):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n            if i > 1 and j > 1 and (word1[i - 1] == word2[j - 2]) and (word1[i - 2] == word2[j - 1]):\n                dp[i][j] = min(dp[i][j], dp[i - -2][j - 2] + cost)\n    return dp[len1 - 1][len2 - 1]"
    }
  ]
}