{
  "task_id": "cf_80550",
  "entry_point": "minPath",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while len(res) < k:",
      "mutated_line": "(val, x, y) = heapq.heappop(heap)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) <= k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while len(res) < k:",
      "mutated_line": "(val, x, y) = heapq.heappop(heap)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) >= k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while len(res) < k:",
      "mutated_line": "(val, x, y) = heapq.heappop(heap)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) != k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if (x, y) not in visited:",
      "mutated_line": "if (x, y) in visited:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[0][0], 1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 1, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[0][0], -1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], -1, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[0][0], 1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 1, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[0][0], 0, 1)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 1)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[0][0], 0, -1)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, -1)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[0][0], 0, 1)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 1)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[0][1], 0, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][1], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[0][-1], 0, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][-1], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[0][1], 0, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][1], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n or 0 <= ny < n or (nx, ny) not in visited:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n or 0 <= ny < n or (nx, ny) not in visited:\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[1][0], 0, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[1][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[-1][0], 0, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[-1][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(grid[0][0], 0, 0)]",
      "mutated_line": "heap = [(grid[1][0], 0, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[1][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x - dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x * dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y - dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y * dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 < nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 < nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 > nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 > nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 == nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 == nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 0 < ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 < ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 0 > ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 > ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 0 == ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 == ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < n and ((nx, ny) in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 1 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if -1 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if -1 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 1 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 1 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and -1 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and -1 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < n and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n    while len(res) < k:\n        (val, x, y) = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < n and 1 <= ny < n and ((nx, ny) not in visited):\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(res)"
    }
  ]
}