{
  "task_id": "cf_58789",
  "entry_point": "advanced_operation",
  "mutant_count": 190,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "p_q_total = 0",
      "mutated_line": "p_q_total = 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 1\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "p_q_total = 0",
      "mutated_line": "p_q_total = -1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = -1\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "p_q_total = 0",
      "mutated_line": "p_q_total = 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 1\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ASR",
      "lineno": 56,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total -= find_start_end_with_one(len(str(num)), num)[1]",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total -= find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return sum(n_m_prime_nums) + p_q_total",
      "mutated_line": "return sum(n_m_prime_nums) - p_q_total",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) - p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return sum(n_m_prime_nums) + p_q_total",
      "mutated_line": "return sum(n_m_prime_nums) * p_q_total",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) * p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return math.isqrt(num) ** 2 == num",
      "mutated_line": "return math.isqrt(num) ** 2 != num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 != num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 3)) ** 3 != num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 != num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 and num % 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 and num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return False\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 * (num_digits - 1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 * (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 + (num_digits - 1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 + (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits + 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits + 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits * 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits * 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if upper < lower:",
      "mutated_line": "if upper <= lower:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper <= lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if upper < lower:",
      "mutated_line": "if upper >= lower:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper >= lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if upper < lower:",
      "mutated_line": "if upper != lower:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper != lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 1\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = -1\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 1\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 1\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "total = 0",
      "mutated_line": "total = -1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = -1\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 1\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):",
      "mutated_line": "if not (is_perfect_square(n) or is_perfect_square(m) or is_perfect_cube(p) or is_perfect_cube(q)):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) or is_perfect_square(m) or is_perfect_cube(p) or is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 'Invalid Inputs.'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return ''\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if len(find_prime_divisors(num)) < 4:",
      "mutated_line": "if len(find_prime_divisors(num)) <= 4:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) <= 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if len(find_prime_divisors(num)) < 4:",
      "mutated_line": "if len(find_prime_divisors(num)) >= 4:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) >= 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if len(find_prime_divisors(num)) < 4:",
      "mutated_line": "if len(find_prime_divisors(num)) != 4:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) != 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.isqrt(num) ** 2 == num",
      "mutated_line": "return math.isqrt(num) * 2 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) * 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.isqrt(num) ** 2 == num",
      "mutated_line": "return math.isqrt(num) + 2 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) + 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 3)) * 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) * 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 3)) + 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) + 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num <= 2 or num % 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num <= 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num >= 2 or num % 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num >= 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num != 2 or num % 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num != 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % 1 >= 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 >= 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % 1 <= 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 <= 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % 1 != 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 != 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return True\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(3, int(math.sqrt(num)) + 1, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(3, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(num)) + 1, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(1, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(0, int(math.sqrt(num)) + 1, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(0, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(num)) + 1, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(1, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(-2, int(math.sqrt(num)) + 1, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(-2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) - 1, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) - 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) * 1, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) * 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 1, 2):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 1, 0):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 0):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 1, 0):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 0):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 1, -1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, -1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i != 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i != 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 11 ** (num_digits - 1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 11 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 9 ** (num_digits - 1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 9 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 0 ** (num_digits - 1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 0 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 1 ** (num_digits - 1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 1 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = -10 ** (num_digits - 1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = -10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits + 1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits + 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits * 1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits * 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 * num_digits - 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 * num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 + num_digits - 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 + num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits - 2",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 2\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits - 0",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 0\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits - 0",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 0\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits - -1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - -1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return +1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper - 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper - 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper * 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper * 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' and str(num)[-1] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' and str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(3, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(3, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(1, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(0, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(0, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(1, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(-2, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(-2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) - 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) - 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) * 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) * 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i != 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i != 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(find_prime_divisors(num)) < 4:",
      "mutated_line": "if len(find_prime_divisors(num)) < 5:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 5:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(find_prime_divisors(num)) < 4:",
      "mutated_line": "if len(find_prime_divisors(num)) < 3:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 3:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(find_prime_divisors(num)) < 4:",
      "mutated_line": "if len(find_prime_divisors(num)) < 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 0:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(find_prime_divisors(num)) < 4:",
      "mutated_line": "if len(find_prime_divisors(num)) < 1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 1:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(find_prime_divisors(num)) < 4:",
      "mutated_line": "if len(find_prime_divisors(num)) < -4:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < -4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 'Invalid Inputs.'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return ''\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[2]",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[2]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[0]",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[0]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[0]",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[0]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[-1]",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[-1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.isqrt(num) ** 2 == num",
      "mutated_line": "return math.isqrt(num) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 3 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.isqrt(num) ** 2 == num",
      "mutated_line": "return math.isqrt(num) ** 1 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 1 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.isqrt(num) ** 2 == num",
      "mutated_line": "return math.isqrt(num) ** 0 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 0 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.isqrt(num) ** 2 == num",
      "mutated_line": "return math.isqrt(num) ** 1 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 1 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.isqrt(num) ** 2 == num",
      "mutated_line": "return math.isqrt(num) ** -2 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** -2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 3)) ** 4 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 4 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 3)) ** 2 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 2 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 3)) ** 0 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 0 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 3)) ** 1 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 1 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 3)) ** -3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** -3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 3 or num % 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 3 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 1 or num % 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 1 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 0 or num % 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 0 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 1 or num % 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 1 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < -2 or num % 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < -2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num * 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num * 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num + 1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num + 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % 1 > 1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 1:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % 1 > -1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > -1:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % 1 > 1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 1:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 2, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 2, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 0, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 0, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 0, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 0, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + -1, 1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + -1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num * i == 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num * i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num + i == 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num + i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 1:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == -1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == -1:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 1:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return True\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits - 2)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 2)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits - 0)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 0)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits - 0)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 0)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits - -1)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - -1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 11 ** num_digits - 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 11 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 9 ** num_digits - 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 9 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 0 ** num_digits - 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 0 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 1 ** num_digits - 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 1 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = -10 ** num_digits - 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = -10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -2\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -0\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -0\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return --1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper + 2):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 2):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper + 0):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 0):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper + 0):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 0):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper + -1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + -1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] != '1' or str(num)[-1] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] != '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-1] != '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] != '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor != 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor != 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt -= 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "total += num",
      "mutated_line": "total -= num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total -= num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 2):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 2):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 0):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 0):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 0):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 0):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + -1):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + -1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num * i == 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num * i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num + i == 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num + i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 1:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == -1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == -1:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 1:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num * (1.0 / 3)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num * (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num + 1.0 / 3) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num + 1.0 / 3) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % 2 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 2 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % 0 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 0 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % 0 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 0 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if num < 2 or num % 1 > 0:",
      "mutated_line": "if num < 2 or num % -1 > 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % -1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '' or str(num)[-1] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-1] == '':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num * divisor == 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num * divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num + divisor == 0:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num + divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor == 1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 1:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor == -1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == -1:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor == 1:",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 1:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 2\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 0\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 0\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += -1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if is_prime(num // i):",
      "mutated_line": "if is_prime(num / i):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num / i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if is_prime(num // i):",
      "mutated_line": "if is_prime(num * i):",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num * i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])",
      "mutated_line": "n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[1])",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[1])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])",
      "mutated_line": "n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[-1])",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[-1])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])",
      "mutated_line": "n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[1])",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[1])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 * 3)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 * 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 // 3)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 // 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[1] == '1' or str(num)[-1] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[1] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[-1] == '1' or str(num)[-1] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[-1] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[1] == '1' or str(num)[-1] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[1] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[+1] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[+1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "divs.add(num // i)",
      "mutated_line": "divs.add(num / i)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num / i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "divs.add(num // i)",
      "mutated_line": "divs.add(num * i)",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num * i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (2.0 / 3)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (2.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (0.0 / 3)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (0.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (0 / 3)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (-1.0 / 3)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (-1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 4)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 4)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 2)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 2)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 0)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 0)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / 1)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 1)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return round(num ** (1. / 3)) ** 3 == num",
      "mutated_line": "return round(num ** (1.0 / -3)) ** 3 == num",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / -3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-2] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-2] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-0] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-0] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-0] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[-0] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[--1] == '1':",
      "code": "import math\n\ndef advanced_operation(n, m, p, q):\n\n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n\n    def is_perfect_cube(num):\n        return round(num ** (1.0 / 3)) ** 3 == num\n\n    def is_prime(num):\n        if num < 2 or num % 1 > 0:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1, 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_start_end_with_one(num_digits, divisor):\n        lower = 10 ** (num_digits - 1)\n        upper = 10 ** num_digits - 1\n        if upper < lower:\n            return -1\n        cnt = 0\n        total = 0\n        for num in range(lower, upper + 1):\n            if str(num)[0] == '1' or str(num)[--1] == '1':\n                if num % divisor == 0:\n                    cnt += 1\n                    total += num\n        return (cnt, total)\n\n    def find_prime_divisors(num):\n        divs = set()\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if is_prime(i):\n                    divs.add(i)\n                if is_prime(num // i):\n                    divs.add(num // i)\n        return divs\n    if not (is_perfect_square(n) and is_perfect_square(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    n_m_prime_nums = []\n    for num in [n, m]:\n        if len(find_prime_divisors(num)) < 4:\n            return 'Invalid Inputs.'\n        else:\n            n_m_prime_nums.append(find_start_end_with_one(len(str(num)), num)[0])\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return sum(n_m_prime_nums) + p_q_total"
    }
  ]
}