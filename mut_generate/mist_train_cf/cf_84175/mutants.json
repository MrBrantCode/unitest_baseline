{
  "task_id": "cf_84175",
  "entry_point": "shortest_cycle",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "shortest = float('inf')",
      "mutated_line": "shortest = float('')",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "visited = [0] * len(graph)",
      "mutated_line": "visited = [0] / len(graph)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] / len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "visited = [0] * len(graph)",
      "mutated_line": "visited = [0] + len(graph)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] + len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "visited = [0] * len(graph)",
      "mutated_line": "visited = [0] ** len(graph)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] ** len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited[source] = 1",
      "mutated_line": "visited[source] = 2",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 2\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited[source] = 1",
      "mutated_line": "visited[source] = 0",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 0\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited[source] = 1",
      "mutated_line": "visited[source] = 0",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 0\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited[source] = 1",
      "mutated_line": "visited[source] = -1",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = -1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "return -1 if shortest == float('inf') else shortest",
      "mutated_line": "return -1 if shortest != float('inf') else shortest",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest != float('inf') else shortest"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return -1 if shortest == float('inf') else shortest",
      "mutated_line": "return +1 if shortest == float('inf') else shortest",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return +1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1 if shortest == float('inf') else shortest",
      "mutated_line": "return -2 if shortest == float('inf') else shortest",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -2 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1 if shortest == float('inf') else shortest",
      "mutated_line": "return -0 if shortest == float('inf') else shortest",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -0 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1 if shortest == float('inf') else shortest",
      "mutated_line": "return -0 if shortest == float('inf') else shortest",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -0 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1 if shortest == float('inf') else shortest",
      "mutated_line": "return --1 if shortest == float('inf') else shortest",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return --1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "queue.append((source, -1, 0))  # (vertex, parent, depth)",
      "mutated_line": "queue.append((source, +1, 0))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, +1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((source, -1, 0))  # (vertex, parent, depth)",
      "mutated_line": "queue.append((source, -1, 1))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 1))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((source, -1, 0))  # (vertex, parent, depth)",
      "mutated_line": "queue.append((source, -1, -1))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, -1))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((source, -1, 0))  # (vertex, parent, depth)",
      "mutated_line": "queue.append((source, -1, 1))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 1))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = [0] * len(graph)",
      "mutated_line": "visited = [1] * len(graph)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [1] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = [0] * len(graph)",
      "mutated_line": "visited = [-1] * len(graph)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [-1] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = [0] * len(graph)",
      "mutated_line": "visited = [1] * len(graph)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [1] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1 if shortest == float('inf') else shortest",
      "mutated_line": "return -1 if shortest == float('') else shortest",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((source, -1, 0))  # (vertex, parent, depth)",
      "mutated_line": "queue.append((source, -2, 0))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -2, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((source, -1, 0))  # (vertex, parent, depth)",
      "mutated_line": "queue.append((source, -0, 0))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -0, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((source, -1, 0))  # (vertex, parent, depth)",
      "mutated_line": "queue.append((source, -0, 0))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -0, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((source, -1, 0))  # (vertex, parent, depth)",
      "mutated_line": "queue.append((source, --1, 0))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, --1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited[neighbor] = 1",
      "mutated_line": "visited[neighbor] = 2",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 2\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited[neighbor] = 1",
      "mutated_line": "visited[neighbor] = 0",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 0\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited[neighbor] = 1",
      "mutated_line": "visited[neighbor] = 0",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 0\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited[neighbor] = 1",
      "mutated_line": "visited[neighbor] = -1",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = -1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif neighbor != parent:",
      "mutated_line": "elif neighbor == parent:",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor == parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "queue.append((neighbor, vertex, depth + 1))",
      "mutated_line": "queue.append((neighbor, vertex, depth - 1))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth - 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "queue.append((neighbor, vertex, depth + 1))",
      "mutated_line": "queue.append((neighbor, vertex, depth * 1))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth * 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "shortest = min(shortest, depth + 1)",
      "mutated_line": "shortest = min(shortest, depth - 1)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth - 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "shortest = min(shortest, depth + 1)",
      "mutated_line": "shortest = min(shortest, depth * 1)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth * 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((neighbor, vertex, depth + 1))",
      "mutated_line": "queue.append((neighbor, vertex, depth + 2))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 2))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((neighbor, vertex, depth + 1))",
      "mutated_line": "queue.append((neighbor, vertex, depth + 0))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 0))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((neighbor, vertex, depth + 1))",
      "mutated_line": "queue.append((neighbor, vertex, depth + 0))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 0))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((neighbor, vertex, depth + 1))",
      "mutated_line": "queue.append((neighbor, vertex, depth + -1))",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + -1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 1)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "shortest = min(shortest, depth + 1)",
      "mutated_line": "shortest = min(shortest, depth + 2)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 2)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "shortest = min(shortest, depth + 1)",
      "mutated_line": "shortest = min(shortest, depth + 0)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 0)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "shortest = min(shortest, depth + 1)",
      "mutated_line": "shortest = min(shortest, depth + 0)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + 0)\n    return -1 if shortest == float('inf') else shortest"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "shortest = min(shortest, depth + 1)",
      "mutated_line": "shortest = min(shortest, depth + -1)",
      "code": "from collections import deque\n\ndef shortest_cycle(graph):\n    shortest = float('inf')\n    for source in range(len(graph)):\n        queue = deque()\n        queue.append((source, -1, 0))\n        visited = [0] * len(graph)\n        visited[source] = 1\n        while queue:\n            (vertex, parent, depth) = queue.popleft()\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = 1\n                    queue.append((neighbor, vertex, depth + 1))\n                elif neighbor != parent:\n                    shortest = min(shortest, depth + -1)\n    return -1 if shortest == float('inf') else shortest"
    }
  ]
}