{
  "task_id": "cf_77885",
  "entry_point": "longestDupSubstring",
  "mutant_count": 125,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while l <= r:",
      "mutated_line": "while l < r:",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l < r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while l <= r:",
      "mutated_line": "while l > r:",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l > r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while l <= r:",
      "mutated_line": "while l == r:",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l == r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 1\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "h = 0",
      "mutated_line": "h = -1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = -1\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 1\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nums = [ord(c) - ord('a') for c in s]",
      "mutated_line": "nums = [ord(c) + ord('a') for c in s]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) + ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nums = [ord(c) - ord('a') for c in s]",
      "mutated_line": "nums = [ord(c) * ord('a') for c in s]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) * ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "l, r = 1, n",
      "mutated_line": "(l, r) = (2, n)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (2, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "l, r = 1, n",
      "mutated_line": "(l, r) = (0, n)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (0, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "l, r = 1, n",
      "mutated_line": "(l, r) = (0, n)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (0, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "l, r = 1, n",
      "mutated_line": "(l, r) = (-1, n)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (-1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (1, 2 ** 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (1, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (-1, 2 ** 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (-1, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (1, 2 ** 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (1, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 63 + 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 + 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 63 * 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 * 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) / 2",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) / 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) * 2",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) * 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if cur is not None:",
      "mutated_line": "if cur is None:",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h * 26 + nums[i]) * MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) * MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = h * 26 + nums[i] + MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = h * 26 + nums[i] + MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "aL = pow(26, m, MOD)",
      "mutated_line": "aL = pow(27, m, MOD)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(27, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "aL = pow(26, m, MOD)",
      "mutated_line": "aL = pow(25, m, MOD)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(25, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "aL = pow(26, m, MOD)",
      "mutated_line": "aL = pow(0, m, MOD)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(0, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "aL = pow(26, m, MOD)",
      "mutated_line": "aL = pow(1, m, MOD)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(1, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "aL = pow(26, m, MOD)",
      "mutated_line": "aL = pow(-26, m, MOD)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(-26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(2, n - m + 1):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(2, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(0, n - m + 1):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(0, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(0, n - m + 1):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(0, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(-1, n - m + 1):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(-1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(1, n - m - 1):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m - 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(1, (n - m) * 1):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, (n - m) * 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) * MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) * MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = h * 26 - nums[pos - 1] * aL + nums[pos + m - 1] + MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = h * 26 - nums[pos - 1] * aL + nums[pos + m - 1] + MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if h in s:",
      "mutated_line": "if h not in s:",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h not in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 * 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 * 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 + 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 + 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 63 - 2)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 2)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 63 - 0)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 0)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 63 - 0)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 0)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 63 - -1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - -1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l - r) // 2",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l - r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = l * r // 2",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = l * r // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 3",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 3\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 1\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 0",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 0\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 1\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // -2",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // -2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid - 1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid - 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid * 1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid * 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "r = mid - 1",
      "mutated_line": "r = mid + 1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid + 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "r = mid - 1",
      "mutated_line": "r = mid * 1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid * 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return s[pos:pos + l - 1]",
      "mutated_line": "return s[pos:pos + l + 1]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return s[pos:pos + l - 1]",
      "mutated_line": "return s[pos:(pos + l) * 1]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:(pos + l) * 1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h * 26 - nums[i]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 - nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = h * 26 * nums[i] % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = h * 26 * nums[i] % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(1, n + m + 1):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n + m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(1, n * m + 1):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n * m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(1, n - m + 2):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 2):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(1, n - m + 0):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 0):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(1, n - m + 0):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 0):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for pos in range(1, n - m + 1):",
      "mutated_line": "for pos in range(1, n - m + -1):",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + -1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL - nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL - nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL) * nums[pos + m - 1] % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL) * nums[pos + m - 1] % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nums = [ord(c) - ord('a') for c in s]",
      "mutated_line": "nums = [ord(c) - ord('') for c in s]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 3 ** 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 3 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 1 ** 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 1 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 0 ** 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 0 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 1 ** 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 1 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, -2 ** 63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, -2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 64 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 64 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 62 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 62 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 0 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 0 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** 1 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 1 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos, MOD = 0, 2**63-1",
      "mutated_line": "(pos, MOD) = (0, 2 ** -63 - 1)",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** -63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid + 2",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 2\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid + 0",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 0\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid + 0",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 0\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid + -1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + -1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r = mid - 1",
      "mutated_line": "r = mid - 2",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 2\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r = mid - 1",
      "mutated_line": "r = mid - 0",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 0\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r = mid - 1",
      "mutated_line": "r = mid - 0",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 0\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r = mid - 1",
      "mutated_line": "r = mid - -1",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - -1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return s[pos:pos + l - 1]",
      "mutated_line": "return s[pos:pos - l - 1]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos - l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return s[pos:pos + l - 1]",
      "mutated_line": "return s[pos:pos * l - 1]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos * l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return s[pos:pos + l - 1]",
      "mutated_line": "return s[pos:pos + l - 2]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 2]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return s[pos:pos + l - 1]",
      "mutated_line": "return s[pos:pos + l - 0]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return s[pos:pos + l - 1]",
      "mutated_line": "return s[pos:pos + l - 0]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return s[pos:pos + l - 1]",
      "mutated_line": "return s[pos:pos + l - -1]",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - -1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h / 26 + nums[i]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h / 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h + 26 + nums[i]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h + 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h ** 26 + nums[i]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h ** 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 + nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 + nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 * (nums[pos - 1] * aL) + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 * (nums[pos - 1] * aL) + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h * 27 + nums[i]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 27 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h * 25 + nums[i]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 25 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h * 0 + nums[i]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 0 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h * 1 + nums[i]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 1 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "h = (h * 26 + nums[i]) % MOD",
      "mutated_line": "h = (h * -26 + nums[i]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * -26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h / 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h / 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h + 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h + 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h ** 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h ** 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] / aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] / aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - (nums[pos - 1] + aL) + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - (nums[pos - 1] + aL) + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] ** aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] ** aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m + 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m + 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL + nums[(pos + m) * 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[(pos + m) * 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 27 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 27 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 25 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 25 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 0 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 0 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 1 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 1 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * -26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * -26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos - m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos - m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos * m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos * m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 2]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 2]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 0]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 0]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 0]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 0]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - -1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - -1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos + 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos + 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos * 1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos * 1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 2] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 2] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 0] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 0] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - 0] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - 0] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD",
      "mutated_line": "h = (h * 26 - nums[pos - -1] * aL + nums[pos + m - 1]) % MOD",
      "code": "def longestDupSubstring(s):\n\n    def search(m, MOD):\n        h = 0\n        for i in range(m):\n            h = (h * 26 + nums[i]) % MOD\n        s = {h}\n        aL = pow(26, m, MOD)\n        for pos in range(1, n - m + 1):\n            h = (h * 26 - nums[pos - -1] * aL + nums[pos + m - 1]) % MOD\n            if h in s:\n                return pos\n            s.add(h)\n    nums = [ord(c) - ord('a') for c in s]\n    n = len(nums)\n    (l, r) = (1, n)\n    (pos, MOD) = (0, 2 ** 63 - 1)\n    while l <= r:\n        mid = (l + r) // 2\n        cur = search(mid, MOD)\n        if cur is not None:\n            l = mid + 1\n            pos = cur\n        else:\n            r = mid - 1\n    return s[pos:pos + l - 1]"
    }
  ]
}