{
  "task_id": "cf_100074",
  "entry_point": "find_longest_consecutive_chain",
  "mutant_count": 30,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "longest_chain = \"\"",
      "mutated_line": "longest_chain = 'MUTATED'",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = 'MUTATED'\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(current_chain) > len(longest_chain):",
      "mutated_line": "if len(current_chain) >= len(longest_chain):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) >= len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(current_chain) > len(longest_chain):",
      "mutated_line": "if len(current_chain) <= len(longest_chain):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) <= len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(current_chain) > len(longest_chain):",
      "mutated_line": "if len(current_chain) != len(longest_chain):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) != len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "current_chain = letters[0]",
      "mutated_line": "current_chain = letters[1]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[1]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "current_chain = letters[0]",
      "mutated_line": "current_chain = letters[-1]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[-1]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "current_chain = letters[0]",
      "mutated_line": "current_chain = letters[1]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[1]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(letters)):",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(2, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(letters)):",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(0, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(letters)):",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(0, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(letters)):",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(-1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) != ord(letters[i - 1]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) != ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "current_chain += letters[i]",
      "mutated_line": "current_chain -= letters[i]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain -= letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) - 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) - 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) * 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) * 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(current_chain) > len(longest_chain):",
      "mutated_line": "if len(current_chain) >= len(longest_chain):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) >= len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(current_chain) > len(longest_chain):",
      "mutated_line": "if len(current_chain) <= len(longest_chain):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) <= len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(current_chain) > len(longest_chain):",
      "mutated_line": "if len(current_chain) != len(longest_chain):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) != len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "letters = [letter.text for letter in root.findall('letter')]",
      "mutated_line": "letters = [letter.text for letter in root.findall('')]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) + 2:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 2:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) + 0:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 0:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) + 0:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + 0:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 1]) + -1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 1]) + -1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i + 1]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i + 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i * 1]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i * 1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 2]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 2]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 0]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 0]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - 0]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - 0]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if ord(letters[i]) == ord(letters[i-1]) + 1:",
      "mutated_line": "if ord(letters[i]) == ord(letters[i - -1]) + 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_longest_consecutive_chain(xml_data):\n    \"\"\"\n    This function finds the longest consecutive chain of letters in alphabetical order in a given XML data sequence.\n    \n    Args:\n    xml_data (str): The input XML data sequence.\n    \n    Returns:\n    tuple: A tuple containing the longest consecutive chain of letters and its length.\n    \"\"\"\n    root = ET.fromstring(xml_data)\n    letters = [letter.text for letter in root.findall('letter')]\n    letters = sorted(set(letters))\n    longest_chain = ''\n    current_chain = letters[0]\n    for i in range(1, len(letters)):\n        if ord(letters[i]) == ord(letters[i - -1]) + 1:\n            current_chain += letters[i]\n        else:\n            if len(current_chain) > len(longest_chain):\n                longest_chain = current_chain\n            current_chain = letters[i]\n    if len(current_chain) > len(longest_chain):\n        longest_chain = current_chain\n    return (longest_chain, len(longest_chain))"
    }
  ]
}