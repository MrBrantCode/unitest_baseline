{
  "task_id": "cf_45960",
  "entry_point": "minArea",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) / (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) / (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return maxRowIndex - minRowIndex + 1 + (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return maxRowIndex - minRowIndex + 1 + (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) ** (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) ** (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "minRowIndex = float('inf')",
      "mutated_line": "minRowIndex = float('')",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "maxRowIndex = float('-inf')",
      "mutated_line": "maxRowIndex = float('')",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "minColumnIndex = float('inf')",
      "mutated_line": "minColumnIndex = float('')",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "maxColumnIndex = float('-inf')",
      "mutated_line": "maxColumnIndex = float('')",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 and rowIndex >= len(image) and (columnIndex < 0) and (columnIndex >= len(image[0])) and (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 and rowIndex >= len(image) and (columnIndex < 0) and (columnIndex >= len(image[0])) and (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "image[rowIndex][columnIndex] = '0'",
      "mutated_line": "image[rowIndex][columnIndex] = ''",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = ''\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex - 1) * (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex - 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex) * 1 * (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex) * 1 * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex - 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) * ((maxColumnIndex - minColumnIndex) * 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * ((maxColumnIndex - minColumnIndex) * 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(-1, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(-1, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 2), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 2), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, -1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, -1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (2, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (2, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (-1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (-1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, -1), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (-1, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, +1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, +1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (+1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (+1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (+1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (+1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, +1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, +1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (+1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (+1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 2), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 2), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 0), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 0), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 0), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 0), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, -1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, -1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (2, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (2, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (0, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (0, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (0, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (0, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (-1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (-1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, +1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, +1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (2, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (2, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (0, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (0, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (0, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (0, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (-1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 2)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 2)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 0)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 0)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 0)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 0)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, -1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, -1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex <= 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex <= 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex >= 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex >= 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex != 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex != 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex > len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex > len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex < len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex < len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex == len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex == len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex <= 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex <= 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex >= 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex >= 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex != 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex != 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex > len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex > len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex < len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex < len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex == len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex == len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] != '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] != '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex + minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex + minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex * minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex * minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 2) * (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 2) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 0) * (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 0) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 0) * (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 0) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + -1) * (maxColumnIndex - minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + -1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex + minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex + minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex * minColumnIndex + 1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex * minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 2)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 0)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 0)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)",
      "mutated_line": "return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + -1)",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -2), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -2), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, --1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, --1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-2, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-2, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (--1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (--1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-2, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-2, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-0, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-0, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-0, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-0, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (--1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (--1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -2), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -2), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -0), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -0), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -0), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -0), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, --1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, --1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-2, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-2, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-0, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-0, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-0, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-0, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (--1, 1), (1, -1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (--1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -2), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -2), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -0), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -0), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -0), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -0), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, --1), (1, 1)]",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, --1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 1 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 1 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < -1 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < -1 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 1 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 1 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 1 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 1 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < -1 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < -1 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 1 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 1 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == ''):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == ''):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex - direction[0], columnIndex + direction[1])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex - direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex * direction[0], columnIndex + direction[1])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex * direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex + direction[0], columnIndex - direction[1])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex - direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex + direction[0], columnIndex * direction[1])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex * direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[1])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[1])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[-1])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[-1])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or columnIndex >= len(image[0]) or image[rowIndex][columnIndex] == '0':",
      "mutated_line": "if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[1])) or (image[rowIndex][columnIndex] == '0'):",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[1])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex + direction[1], columnIndex + direction[1])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[1], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex + direction[-1], columnIndex + direction[1])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[-1], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex + direction[1], columnIndex + direction[1])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[1], columnIndex + direction[1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[2])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[2])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[0])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[0])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[0])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[0])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "newRow, newColumn = rowIndex + direction[0], columnIndex + direction[1]",
      "mutated_line": "(newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[-1])",
      "code": "from typing import List\n\ndef minArea(image: List[List[str]], x: int, y: int) -> int:\n    \"\"\"\n    This function returns the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n    \n    Parameters:\n    image (List[List[str]]): A binary matrix with '0' as a white pixel and '1' as a black pixel.\n    x (int): The row index of one of the black pixels.\n    y (int): The column index of one of the black pixels.\n    \n    Returns:\n    int: The area of the smallest rectangle that encloses all black pixels.\n    \"\"\"\n    minRowIndex = float('inf')\n    maxRowIndex = float('-inf')\n    minColumnIndex = float('inf')\n    maxColumnIndex = float('-inf')\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    def dfs(rowIndex, columnIndex):\n        nonlocal minRowIndex, maxRowIndex, minColumnIndex, maxColumnIndex\n        if rowIndex < 0 or rowIndex >= len(image) or columnIndex < 0 or (columnIndex >= len(image[0])) or (image[rowIndex][columnIndex] == '0'):\n            return\n        image[rowIndex][columnIndex] = '0'\n        minRowIndex = min(minRowIndex, rowIndex)\n        maxRowIndex = max(maxRowIndex, rowIndex)\n        minColumnIndex = min(minColumnIndex, columnIndex)\n        maxColumnIndex = max(maxColumnIndex, columnIndex)\n        for direction in directions:\n            (newRow, newColumn) = (rowIndex + direction[0], columnIndex + direction[-1])\n            dfs(newRow, newColumn)\n    dfs(x, y)\n    return (maxRowIndex - minRowIndex + 1) * (maxColumnIndex - minColumnIndex + 1)"
    }
  ]
}