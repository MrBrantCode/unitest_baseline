{
  "task_id": "cf_58108",
  "entry_point": "unique_BST_sort",
  "mutant_count": 4,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "'''",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def unique_BST_sort(lst):\n    \"\"\"\"\"\"\n    lst.sort()\n    result = []\n    while lst:\n        result.append(lst.pop(0))\n        if lst:\n            result.append(lst.pop())\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result.append(lst.pop(0))",
      "mutated_line": "result.append(lst.pop(1))",
      "code": "def unique_BST_sort(lst):\n    \"\"\"\n    Upon a mixed assemblage of integers and real numbers, restore the list arrayed in a peculiar order employing Binary Search Tree (BST) tactic.\n    The arraying sequence should adhere to the following progression:\n    - Initiate with the least number.\n    - Subsequently recognize the apex numeric from the remaining.\n    - Proceed to decipher the least numerical not yet included from the remaining, and maintain this sequence.\n    \n    Demonstrations:\n    unique_BST_sort([1, 2, 3, 4]) == [1, 4, 2, 3]\n    unique_BST_sort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    unique_BST_sort([]) == []\n    unique_BST_sort([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    \"\"\"\n    lst.sort()\n    result = []\n    while lst:\n        result.append(lst.pop(1))\n        if lst:\n            result.append(lst.pop())\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result.append(lst.pop(0))",
      "mutated_line": "result.append(lst.pop(-1))",
      "code": "def unique_BST_sort(lst):\n    \"\"\"\n    Upon a mixed assemblage of integers and real numbers, restore the list arrayed in a peculiar order employing Binary Search Tree (BST) tactic.\n    The arraying sequence should adhere to the following progression:\n    - Initiate with the least number.\n    - Subsequently recognize the apex numeric from the remaining.\n    - Proceed to decipher the least numerical not yet included from the remaining, and maintain this sequence.\n    \n    Demonstrations:\n    unique_BST_sort([1, 2, 3, 4]) == [1, 4, 2, 3]\n    unique_BST_sort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    unique_BST_sort([]) == []\n    unique_BST_sort([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    \"\"\"\n    lst.sort()\n    result = []\n    while lst:\n        result.append(lst.pop(-1))\n        if lst:\n            result.append(lst.pop())\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result.append(lst.pop(0))",
      "mutated_line": "result.append(lst.pop(1))",
      "code": "def unique_BST_sort(lst):\n    \"\"\"\n    Upon a mixed assemblage of integers and real numbers, restore the list arrayed in a peculiar order employing Binary Search Tree (BST) tactic.\n    The arraying sequence should adhere to the following progression:\n    - Initiate with the least number.\n    - Subsequently recognize the apex numeric from the remaining.\n    - Proceed to decipher the least numerical not yet included from the remaining, and maintain this sequence.\n    \n    Demonstrations:\n    unique_BST_sort([1, 2, 3, 4]) == [1, 4, 2, 3]\n    unique_BST_sort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    unique_BST_sort([]) == []\n    unique_BST_sort([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    \"\"\"\n    lst.sort()\n    result = []\n    while lst:\n        result.append(lst.pop(1))\n        if lst:\n            result.append(lst.pop())\n    return result"
    }
  ]
}