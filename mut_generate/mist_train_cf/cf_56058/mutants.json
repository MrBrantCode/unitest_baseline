{
  "task_id": "cf_56058",
  "entry_point": "nonagonal_numbers",
  "mutant_count": 136,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if isinstance(start, int) and start < 1:",
      "mutated_line": "if isinstance(start, int) or start < 1:",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) or start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if isinstance(start, list) and not all([isinstance(u, int) and u > 0 for u in start]):",
      "mutated_line": "if isinstance(start, list) or not all([isinstance(u, int) and u > 0 for u in start]):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) or not all([isinstance(u, int) and u > 0 for u in start]):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) or (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) or (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if end and (not isinstance(end, int) or end < start):",
      "mutated_line": "if end or (not isinstance(end, int) or end < start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end or (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "nonagonals = [0]",
      "mutated_line": "nonagonals = [1]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [1]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "nonagonals = [0]",
      "mutated_line": "nonagonals = [-1]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [-1]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "nonagonals = [0]",
      "mutated_line": "nonagonals = [1]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [1]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for m in range(1, 1001):",
      "mutated_line": "for m in range(2, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(2, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for m in range(1, 1001):",
      "mutated_line": "for m in range(0, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(0, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for m in range(1, 1001):",
      "mutated_line": "for m in range(0, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(0, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for m in range(1, 1001):",
      "mutated_line": "for m in range(-1, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(-1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for m in range(1, 1001):",
      "mutated_line": "for m in range(1, 1002):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1002):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for m in range(1, 1001):",
      "mutated_line": "for m in range(1, 1000):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1000):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for m in range(1, 1001):",
      "mutated_line": "for m in range(1, 0):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 0):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for m in range(1, 1001):",
      "mutated_line": "for m in range(1, 1):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for m in range(1, 1001):",
      "mutated_line": "for m in range(1, -1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, -1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sums = [0]",
      "mutated_line": "sums = [1]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [1]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sums = [0]",
      "mutated_line": "sums = [-1]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [-1]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sums = [0]",
      "mutated_line": "sums = [1]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [1]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(2, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(2, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(0, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(0, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(0, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(0, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(-1, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(-1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, 1002):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1002):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, 1000):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1000):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, 0):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 0):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, 1):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, -1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, -1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "products = [1]",
      "mutated_line": "products = [2]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [2]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "products = [1]",
      "mutated_line": "products = [0]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [0]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "products = [1]",
      "mutated_line": "products = [0]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [0]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "products = [1]",
      "mutated_line": "products = [-1]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [-1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(2, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(2, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(0, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(0, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(0, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(0, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(-1, 1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(-1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, 1002):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1002):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, 1000):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1000):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, 0):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 0):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, 1):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, 1001):",
      "mutated_line": "for n in range(1, -1001):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, -1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return \"Please provide either a positive integer, an array of positive integers or a range.\"",
      "mutated_line": "return ''",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return ''\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if isinstance(start, int) and start < 1:",
      "mutated_line": "if isinstance(start, int) and start <= 1:",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start <= 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if isinstance(start, int) and start < 1:",
      "mutated_line": "if isinstance(start, int) and start >= 1:",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start >= 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if isinstance(start, int) and start < 1:",
      "mutated_line": "if isinstance(start, int) and start != 1:",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start != 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return \"Please provide a positive integer.\"",
      "mutated_line": "return ''",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return ''\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return \"Array should contain only positive integers.\"",
      "mutated_line": "return ''",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return ''\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 1 and start.step != 1 and (start.stop < start.start)):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 and start.step != 1 and (start.stop < start.start)):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return \"Invalid range.\"",
      "mutated_line": "return ''",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return ''\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if end and (not isinstance(end, int) or end < start):",
      "mutated_line": "if end and (not isinstance(end, int) and end < start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) and end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return \"Invalid end of range.\"",
      "mutated_line": "return ''",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return ''\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 5) / 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) / 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 5) * 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) * 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sums.append(sums[-1] + nonagonals[n])",
      "mutated_line": "sums.append(sums[-1] - nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] - nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sums.append(sums[-1] + nonagonals[n])",
      "mutated_line": "sums.append(sums[-1] * nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] * nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "products.append(products[-1] * nonagonals[n])",
      "mutated_line": "products.append(products[-1] / nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] / nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "products.append(products[-1] * nonagonals[n])",
      "mutated_line": "products.append(products[-1] + nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] + nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "products.append(products[-1] * nonagonals[n])",
      "mutated_line": "products.append(products[-1] ** nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] ** nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if isinstance(start, int) and start < 1:",
      "mutated_line": "if isinstance(start, int) and start < 2:",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 2:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if isinstance(start, int) and start < 1:",
      "mutated_line": "if isinstance(start, int) and start < 0:",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 0:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if isinstance(start, int) and start < 1:",
      "mutated_line": "if isinstance(start, int) and start < 0:",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 0:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if isinstance(start, int) and start < 1:",
      "mutated_line": "if isinstance(start, int) and start < -1:",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < -1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start <= 1 or start.step != 1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start <= 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start >= 1 or start.step != 1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start >= 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start != 1 or start.step != 1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start != 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 1 or start.step == 1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step == 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop <= start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop <= start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop >= start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop >= start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop != start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop != start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if end and (not isinstance(end, int) or end < start):",
      "mutated_line": "if end and (not isinstance(end, int) or end <= start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end <= start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if end and (not isinstance(end, int) or end < start):",
      "mutated_line": "if end and (not isinstance(end, int) or end >= start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end >= start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if end and (not isinstance(end, int) or end < start):",
      "mutated_line": "if end and (not isinstance(end, int) or end != start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end != start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 1",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 2\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 1",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 0\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 1",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 0\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 1",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = -1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "total_product *= products[v]",
      "mutated_line": "total_product /= products[v]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product /= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 2",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 2\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 0",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 0\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 0",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 0\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = -1",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = -1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "total_product *= products[v]",
      "mutated_line": "total_product /= products[v]",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product /= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m / (7 * m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m / (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append((m + (7 * m - 5)) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append((m + (7 * m - 5)) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m ** (7 * m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m ** (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 5) // 3)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 3)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 5) // 1)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 1)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 5) // 0)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 0)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 5) // 1)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 1)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 5) // -2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // -2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 2 or start.step != 1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 2 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 0 or start.step != 1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 0 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 0 or start.step != 1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 0 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < -1 or start.step != 1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < -1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 1 or start.step != 2 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 2 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 1 or start.step != 0 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 0 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 1 or start.step != 0 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 0 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):",
      "mutated_line": "if isinstance(start, range) and (start.start < 1 or start.step != -1 or start.stop < start.start):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != -1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m + 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m + 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m * 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m * 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "sums.append(sums[-1] + nonagonals[n])",
      "mutated_line": "sums.append(sums[+1] + nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[+1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "products.append(products[-1] * nonagonals[n])",
      "mutated_line": "products.append(products[+1] * nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[+1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if isinstance(start, list) and not all([isinstance(u, int) and u > 0 for u in start]):",
      "mutated_line": "if isinstance(start, list) and (not all([isinstance(u, int) or u > 0 for u in start])):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) or u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 / m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 / m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 + m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 + m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 ** m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 ** m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 6) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 6) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 4) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 4) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 0) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 0) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - 1) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 1) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (7 * m - -5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - -5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sums.append(sums[-1] + nonagonals[n])",
      "mutated_line": "sums.append(sums[-2] + nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-2] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sums.append(sums[-1] + nonagonals[n])",
      "mutated_line": "sums.append(sums[-0] + nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-0] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sums.append(sums[-1] + nonagonals[n])",
      "mutated_line": "sums.append(sums[-0] + nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-0] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sums.append(sums[-1] + nonagonals[n])",
      "mutated_line": "sums.append(sums[--1] + nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[--1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "products.append(products[-1] * nonagonals[n])",
      "mutated_line": "products.append(products[-2] * nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-2] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "products.append(products[-1] * nonagonals[n])",
      "mutated_line": "products.append(products[-0] * nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-0] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "products.append(products[-1] * nonagonals[n])",
      "mutated_line": "products.append(products[-0] * nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-0] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "products.append(products[-1] * nonagonals[n])",
      "mutated_line": "products.append(products[--1] * nonagonals[n])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[--1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if isinstance(start, list) and not all([isinstance(u, int) and u > 0 for u in start]):",
      "mutated_line": "if isinstance(start, list) and (not all([isinstance(u, int) and u >= 0 for u in start])):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u >= 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if isinstance(start, list) and not all([isinstance(u, int) and u > 0 for u in start]):",
      "mutated_line": "if isinstance(start, list) and (not all([isinstance(u, int) and u <= 0 for u in start])):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u <= 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if isinstance(start, list) and not all([isinstance(u, int) and u > 0 for u in start]):",
      "mutated_line": "if isinstance(start, list) and (not all([isinstance(u, int) and u != 0 for u in start])):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u != 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return nonagonals[start:end+1], sums[end], products[end]",
      "mutated_line": "return (nonagonals[start:end - 1], sums[end], products[end])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end - 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return nonagonals[start:end+1], sums[end], products[end]",
      "mutated_line": "return (nonagonals[start:end * 1], sums[end], products[end])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end * 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (8 * m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (8 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (6 * m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (6 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (0 * m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (0 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (1 * m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (1 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nonagonals.append(m * (7 * m - 5) // 2)",
      "mutated_line": "nonagonals.append(m * (-7 * m - 5) // 2)",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (-7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if isinstance(start, list) and not all([isinstance(u, int) and u > 0 for u in start]):",
      "mutated_line": "if isinstance(start, list) and (not all([isinstance(u, int) and u > 1 for u in start])):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 1 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if isinstance(start, list) and not all([isinstance(u, int) and u > 0 for u in start]):",
      "mutated_line": "if isinstance(start, list) and (not all([isinstance(u, int) and u > -1 for u in start])):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > -1 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if isinstance(start, list) and not all([isinstance(u, int) and u > 0 for u in start]):",
      "mutated_line": "if isinstance(start, list) and (not all([isinstance(u, int) and u > 1 for u in start])):",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 1 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return nonagonals[start:end+1], sums[end], products[end]",
      "mutated_line": "return (nonagonals[start:end + 2], sums[end], products[end])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 2], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return nonagonals[start:end+1], sums[end], products[end]",
      "mutated_line": "return (nonagonals[start:end + 0], sums[end], products[end])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 0], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return nonagonals[start:end+1], sums[end], products[end]",
      "mutated_line": "return (nonagonals[start:end + 0], sums[end], products[end])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + 0], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return nonagonals[start:end+1], sums[end], products[end]",
      "mutated_line": "return (nonagonals[start:end + -1], sums[end], products[end])",
      "code": "def nonagonal_numbers(start, end=None):\n    nonagonals = [0]\n    for m in range(1, 1001):\n        nonagonals.append(m * (7 * m - 5) // 2)\n    sums = [0]\n    for n in range(1, 1001):\n        sums.append(sums[-1] + nonagonals[n])\n    products = [1]\n    for n in range(1, 1001):\n        products.append(products[-1] * nonagonals[n])\n    if not isinstance(start, (int, list, range)):\n        return 'Please provide either a positive integer, an array of positive integers or a range.'\n    if isinstance(start, int) and start < 1:\n        return 'Please provide a positive integer.'\n    if isinstance(start, list) and (not all([isinstance(u, int) and u > 0 for u in start])):\n        return 'Array should contain only positive integers.'\n    if isinstance(start, range) and (start.start < 1 or start.step != 1 or start.stop < start.start):\n        return 'Invalid range.'\n    if end and (not isinstance(end, int) or end < start):\n        return 'Invalid end of range.'\n    if isinstance(start, int):\n        if end:\n            return (nonagonals[start:end + -1], sums[end], products[end])\n        else:\n            return (nonagonals[start], sums[start], products[start])\n    elif isinstance(start, range):\n        start = list(start)\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)\n    else:\n        nonags = [nonagonals[v] for v in start]\n        total_sum = sum([sums[v] for v in start])\n        total_product = 1\n        for v in start:\n            total_product *= products[v]\n        return (nonags, total_sum, total_product)"
    }
  ]
}