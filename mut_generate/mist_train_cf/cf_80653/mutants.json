{
  "task_id": "cf_80653",
  "entry_point": "getFood",
  "mutant_count": 92,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "dist = [[float('inf')] / n for _ in range(m)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] / n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "dist = [[float('inf')] + n for _ in range(m)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] + n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "dist = [[float('inf')] ** n for _ in range(m)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] ** n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "return food_dist if food_dist != float('inf') else -1",
      "mutated_line": "return food_dist if food_dist == float('inf') else -1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist == float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "return food_dist if food_dist != float('inf') else -1",
      "mutated_line": "return food_dist if food_dist != float('inf') else +1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if grid[i][j] == '*':",
      "mutated_line": "if grid[i][j] != '*':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n or dist[nx][ny] == float('inf'):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m or 0 <= ny < n or dist[nx][ny] == float('inf'):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return food_dist if food_dist != float('inf') else -1",
      "mutated_line": "return food_dist if food_dist != float('inf') else -2",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return food_dist if food_dist != float('inf') else -1",
      "mutated_line": "return food_dist if food_dist != float('inf') else -0",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return food_dist if food_dist != float('inf') else -1",
      "mutated_line": "return food_dist if food_dist != float('inf') else -0",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return food_dist if food_dist != float('inf') else -1",
      "mutated_line": "return food_dist if food_dist != float('inf') else --1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else --1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[1]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[-1]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[1]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if grid[i][j] == '*':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist[i][j] = 0",
      "mutated_line": "dist[i][j] = 1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 1\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist[i][j] = 0",
      "mutated_line": "dist[i][j] = -1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = -1\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist[i][j] = 0",
      "mutated_line": "dist[i][j] = 1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 1\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 < ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 > ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 == ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] != float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] != float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if grid[nx][ny] == 'X':",
      "mutated_line": "if grid[nx][ny] != 'X':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] != 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "food_dist = min(dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#')",
      "mutated_line": "food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] != '#'))",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] != '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return food_dist if food_dist != float('inf') else -1",
      "mutated_line": "return food_dist if food_dist != float('') else -1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "dist = [[float('')] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and -1 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (dist[nx][ny] == float('inf')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if grid[nx][ny] == 'X':",
      "mutated_line": "if grid[nx][ny] == '':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == '':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':",
      "mutated_line": "elif grid[nx][ny] == 'O' and grid[nx][ny] == '#':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' and grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "food_dist = min(dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#')",
      "mutated_line": "food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == ''))",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == ''))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == float('inf'):",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('')):",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':",
      "mutated_line": "elif grid[nx][ny] != 'O' or grid[nx][ny] == '#':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] != 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':",
      "mutated_line": "elif grid[nx][ny] == 'O' or grid[nx][ny] != '#':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] != '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] - 1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] - 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] * 1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] * 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif grid[nx][ny] == 'T':",
      "mutated_line": "elif grid[nx][ny] != 'T':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] != 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':",
      "mutated_line": "elif grid[nx][ny] == '' or grid[nx][ny] == '#':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == '' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':",
      "mutated_line": "elif grid[nx][ny] == 'O' or grid[nx][ny] == '':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 2",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 0",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 0\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 0",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 0\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + -1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + -1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif grid[nx][ny] == 'T':",
      "mutated_line": "elif grid[nx][ny] == '':",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == '':\n                    dist[nx][ny] = dist[x][y] + 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[nx][ny] = dist[x][y] + 2",
      "mutated_line": "dist[nx][ny] = dist[x][y] - 2",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] - 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[nx][ny] = dist[x][y] + 2",
      "mutated_line": "dist[nx][ny] = dist[x][y] * 2",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] * 2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[nx][ny] = dist[x][y] + 2",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 3",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 3\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[nx][ny] = dist[x][y] + 2",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[nx][ny] = dist[x][y] + 2",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 0",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 0\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[nx][ny] = dist[x][y] + 2",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 1",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[nx][ny] = dist[x][y] + 2",
      "mutated_line": "dist[nx][ny] = dist[x][y] + -2",
      "code": "from collections import deque\n\ndef getFood(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[float('inf')] * n for _ in range(m)]\n    q = deque([])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '*':\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        (x, y) = q.popleft()\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == float('inf')):\n                if grid[nx][ny] == 'X':\n                    continue\n                elif grid[nx][ny] == 'O' or grid[nx][ny] == '#':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n                elif grid[nx][ny] == 'T':\n                    dist[nx][ny] = dist[x][y] + -2\n                    q.append((nx, ny))\n    food_dist = min((dist[i][j] for i in range(m) for j in range(n) if grid[i][j] == '#'))\n    return food_dist if food_dist != float('inf') else -1"
    }
  ]
}