{
  "task_id": "cf_27483",
  "entry_point": "find_path",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (x, y) == end:",
      "mutated_line": "if (x, y) != end:",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) != end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (x, y) in closed_set:",
      "mutated_line": "if (x, y) not in closed_set:",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) not in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "open_set = [(0, start, [])]  # (f, (x, y), path)",
      "mutated_line": "open_set = [(1, start, [])]",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(1, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "open_set = [(0, start, [])]  # (f, (x, y), path)",
      "mutated_line": "open_set = [(-1, start, [])]",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(-1, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "open_set = [(0, start, [])]  # (f, (x, y), path)",
      "mutated_line": "open_set = [(1, start, [])]",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(1, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return path + [(x, y)]",
      "mutated_line": "return path - [(x, y)]",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path - [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return path + [(x, y)]",
      "mutated_line": "return path * [(x, y)]",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path * [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(2, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(-1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, -1), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (+1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, -1), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (-1, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 2), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, -1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (-1, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, +1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x - dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x - dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x * dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x * dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x + dx, y - dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y - dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x + dx, y * dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y * dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_path = path + [(x, y)]",
      "mutated_line": "new_path = path - [(x, y)]",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path - [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_path = path + [(x, y)]",
      "mutated_line": "new_path = path * [(x, y)]",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path * [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "f = g + h",
      "mutated_line": "f = g - h",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g - h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "f = g + h",
      "mutated_line": "f = g * h",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g * h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-2, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (--1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -2)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "(new_x, new_y) = (x + dx, y + dy)",
      "code": "import heapq\n\ndef find_path(maze_map):\n    start = maze_map.get_start()\n    end = maze_map.get_end()\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (_, (x, y), path) = heapq.heappop(open_set)\n        if (x, y) == end:\n            return path + [(x, y)]\n        if (x, y) in closed_set:\n            continue\n        closed_set.add((x, y))\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, --1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if maze_map.is_valid(new_x, new_y):\n                new_path = path + [(x, y)]\n                g = len(new_path)\n                h = maze_map.heuristic(new_x, new_y)\n                f = g + h\n                heapq.heappush(open_set, (f, (new_x, new_y), new_path))\n    return []"
    }
  ]
}