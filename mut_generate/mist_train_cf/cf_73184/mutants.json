{
  "task_id": "cf_73184",
  "entry_point": "entrance",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def entrance(arr):\n    \"\"\"\"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))",
      "mutated_line": "return two_swap_bubble_sort(arr) or even_index_for_even_number(arr) or (len(arr) == 0 or first_element_constraint(arr))",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) or even_index_for_even_number(arr) or (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) and nums.count(min(nums)) > 2 and (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) and nums.count(min(nums)) > 2 and (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) != len([num for num in nums if num % 2 == 0])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) != len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) > len(nums) // 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) > len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) < len(nums) // 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) < len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) == len(nums) // 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) == len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))",
      "mutated_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 and first_element_constraint(arr))",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 and first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums != sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums != sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) >= 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) >= 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) <= 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) <= 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) != 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) != 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) or (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) or (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) / 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) / 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) * 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) * 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))",
      "mutated_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) != 0 or first_element_constraint(arr))",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) != 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 3 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 3 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 1 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 1 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 0 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 0 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 1 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 1 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > -2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > -2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) <= nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) <= nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) >= nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) >= nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) != nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) != nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 == 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 == 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 or num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 or num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 3",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 3\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 1",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 1\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 0",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 0\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 1",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 1\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // -2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // -2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))",
      "mutated_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 1 or first_element_constraint(arr))",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 1 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))",
      "mutated_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == -1 or first_element_constraint(arr))",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == -1 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))",
      "mutated_line": "return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 1 or first_element_constraint(arr))",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 1 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) * 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) * 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and nums[::-1].index(min(nums)) - nums.index(min(nums)) + 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and nums[::-1].index(min(nums)) - nums.index(min(nums)) + 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 1)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 1)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != -1)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != -1)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 1)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 1)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 != 0 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 != 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 != 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 != 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) + nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) + nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and nums[::-1].index(min(nums)) * nums.index(min(nums)) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and nums[::-1].index(min(nums)) * nums.index(min(nums)) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 3 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 3 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 1 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 1 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 0 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 0 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 1 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 1 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % -2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % -2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i * 2 == 0 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i * 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i + 2 == 0 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i + 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 1 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 1 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == -1 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == -1 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 1 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 1 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num * 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num * 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num + 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num + 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 1]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 1]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == -1]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == -1]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 1]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 1]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 != 0])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 != 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num <= nums[0]]) >= len(nums) // 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num <= nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num >= nums[0]]) >= len(nums) // 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num >= nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num != nums[0]]) >= len(nums) // 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num != nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 3 == 0 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 3 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 1 == 0 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 1 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 0 == 0 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 0 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 1 == 0 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 1 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % -2 == 0 and num % 2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % -2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 3 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 3 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 1 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 1 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 0 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 0 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 1 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 1 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "even_nums_in_even_index = [num for i, num in enumerate(nums) if i % 2 == 0 and num % 2 == 0]",
      "mutated_line": "even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % -2 == 0]",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % -2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num * 2 == 0])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num * 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num + 2 == 0])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num + 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 1])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 1])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == -1])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == -1])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 1])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 1])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 3 == 0])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 3 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 1 == 0])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 1 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 0 == 0])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 0 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 1 == 0])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 1 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])",
      "mutated_line": "return len(even_nums_in_even_index) == len([num for num in nums if num % -2 == 0])",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % -2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[1]]) >= len(nums) // 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[1]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[-1]]) >= len(nums) // 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[-1]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return len([num for num in nums if num < nums[0]]) >= len(nums) // 2",
      "mutated_line": "return len([num for num in nums if num < nums[1]]) >= len(nums) // 2",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[1]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::+1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::+1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-2].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-2].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-0].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-0].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-0].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-0].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::--1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::--1].index(min(nums)) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::+1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::+1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-2].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-2].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-0].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-0].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-0].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::-0].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or ((nums.index(min(nums)) < nums[::-1].index(min(nums))) and (nums[::-1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "mutated_line": "return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::--1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)",
      "code": "def entrance(arr):\n    \"\"\"\n    Check if an array can be modified to meet the three conditions within a maximum of two element swaps.\n    \"\"\"\n\n    def two_swap_bubble_sort(nums):\n        return nums == sorted(nums) or nums.count(min(nums)) > 2 or (nums.index(min(nums)) < nums[::-1].index(min(nums)) and (nums[::--1].index(min(nums)) - nums.index(min(nums))) % 2 != 0)\n\n    def even_index_for_even_number(nums):\n        even_nums_in_even_index = [num for (i, num) in enumerate(nums) if i % 2 == 0 and num % 2 == 0]\n        return len(even_nums_in_even_index) == len([num for num in nums if num % 2 == 0])\n\n    def first_element_constraint(nums):\n        return len([num for num in nums if num < nums[0]]) >= len(nums) // 2\n    return two_swap_bubble_sort(arr) and even_index_for_even_number(arr) and (len(arr) == 0 or first_element_constraint(arr))"
    }
  ]
}