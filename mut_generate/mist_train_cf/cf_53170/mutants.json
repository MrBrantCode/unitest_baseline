{
  "task_id": "cf_53170",
  "entry_point": "can_partition_with_same_product",
  "mutant_count": 60,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if len(nums) > 18: return \"Can't be parsed\"",
      "mutated_line": "if len(nums) >= 18:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) >= 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if len(nums) > 18: return \"Can't be parsed\"",
      "mutated_line": "if len(nums) <= 18:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) <= 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if len(nums) > 18: return \"Can't be parsed\"",
      "mutated_line": "if len(nums) != 18:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) != 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 2",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 2\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 0",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 0\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = 0",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 0\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "total_product = 1",
      "mutated_line": "total_product = -1",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = -1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "total_product *= num",
      "mutated_line": "total_product /= num",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product /= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if total_product & 1: return \"Not possible\"",
      "mutated_line": "return 'Not possible'",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product | 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "target_product = total_product // 2",
      "mutated_line": "n = len(nums)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product / 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "target_product = total_product // 2",
      "mutated_line": "n = len(nums)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product * 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(nums) > 18: return \"Can't be parsed\"",
      "mutated_line": "if len(nums) > 19:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 19:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(nums) > 18: return \"Can't be parsed\"",
      "mutated_line": "if len(nums) > 17:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 17:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(nums) > 18: return \"Can't be parsed\"",
      "mutated_line": "if len(nums) > 0:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 0:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(nums) > 18: return \"Can't be parsed\"",
      "mutated_line": "if len(nums) > 1:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 1:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(nums) > 18: return \"Can't be parsed\"",
      "mutated_line": "if len(nums) > -18:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > -18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(nums) > 18: return \"Can't be parsed\"",
      "mutated_line": "if len(nums) > 18:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return ''\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if total_product & 1: return \"Not possible\"",
      "mutated_line": "return 'Not possible'",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 2:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if total_product & 1: return \"Not possible\"",
      "mutated_line": "return 'Not possible'",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 0:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if total_product & 1: return \"Not possible\"",
      "mutated_line": "return 'Not possible'",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 0:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if total_product & 1: return \"Not possible\"",
      "mutated_line": "return 'Not possible'",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & -1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if total_product & 1: return \"Not possible\"",
      "mutated_line": "return ''",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return ''\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "target_product = total_product // 2",
      "mutated_line": "n = len(nums)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 3\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "target_product = total_product // 2",
      "mutated_line": "n = len(nums)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 1\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "target_product = total_product // 2",
      "mutated_line": "n = len(nums)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 0\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "target_product = total_product // 2",
      "mutated_line": "n = len(nums)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 1\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "target_product = total_product // 2",
      "mutated_line": "n = len(nums)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // -2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if target_product == 1: return True",
      "mutated_line": "if target_product != 1:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product != 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if target_product < nums[start]: return False",
      "mutated_line": "return True",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product <= nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if target_product < nums[start]: return False",
      "mutated_line": "return True",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product >= nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if target_product < nums[start]: return False",
      "mutated_line": "return True",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product != nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return True\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return can_partition(0, target_product)",
      "mutated_line": "return can_partition(1, target_product)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(1, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return can_partition(0, target_product)",
      "mutated_line": "return can_partition(-1, target_product)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(-1, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return can_partition(0, target_product)",
      "mutated_line": "return can_partition(1, target_product)",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(1, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if target_product == 1: return True",
      "mutated_line": "if target_product == 2:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 2:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if target_product == 1: return True",
      "mutated_line": "if target_product == 0:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 0:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if target_product == 1: return True",
      "mutated_line": "if target_product == 0:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 0:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if target_product == 1: return True",
      "mutated_line": "if target_product == -1:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == -1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if target_product == 1: return True",
      "mutated_line": "if target_product == 1:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return False\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if target_product < nums[start]: return False",
      "mutated_line": "return True",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return True\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nums[i] > target_product: break",
      "mutated_line": "if nums[i] >= target_product:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] >= target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nums[i] > target_product: break",
      "mutated_line": "if nums[i] <= target_product:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] <= target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nums[i] > target_product: break",
      "mutated_line": "if nums[i] != target_product:",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] != target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 or can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] != 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return True",
      "mutated_line": "if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return False\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product * nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product + nums[i] == 0 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 1 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == -1 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 1 and can_partition(i + 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i - 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i * 1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product / nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 1, target_product * nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 2, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 0, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + 0, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if target_product % nums[i] == 0 and can_partition(i+1, target_product//nums[i]):",
      "mutated_line": "break",
      "code": "def can_partition_with_same_product(nums):\n    if len(nums) > 18:\n        return \"Can't be parsed\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n    if total_product & 1:\n        return 'Not possible'\n    nums.sort()\n    target_product = total_product // 2\n    n = len(nums)\n\n    def can_partition(start, target_product):\n        if target_product == 1:\n            return True\n        if target_product < nums[start]:\n            return False\n        for i in range(start, n):\n            if nums[i] > target_product:\n                break\n            if target_product % nums[i] == 0 and can_partition(i + -1, target_product // nums[i]):\n                return True\n        return False\n    return can_partition(0, target_product)"
    }
  ]
}