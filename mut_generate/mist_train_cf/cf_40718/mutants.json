{
  "task_id": "cf_40718",
  "entry_point": "calculate_particle_positions",
  "mutant_count": 34,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = 2 * math.pi * inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi * inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = 2 * math.pi // inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi // inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = 2 / math.pi / inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 / math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = (2 + math.pi) / inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = (2 + math.pi) / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = 2 ** math.pi / inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 ** math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = 3 * math.pi / inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 3 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = 1 * math.pi / inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 1 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = 0 * math.pi / inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 0 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = 1 * math.pi / inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 1 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "angular_velocity = 2 * math.pi / inputs.time_interval",
      "mutated_line": "angular_velocity = -2 * math.pi / inputs.time_interval",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = -2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(1, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(1, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(-1, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(-1, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(1, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(1, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius / math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius / math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius + math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius + math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius ** math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius ** math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius / math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius / math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius + math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius + math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius ** math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius ** math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(1, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(1, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(-1, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(-1, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(1, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(1, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval - 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval - 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval * 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval * 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity / t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity / t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity + t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity + t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity ** t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity ** t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity / t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity / t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity + t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity + t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity ** t)) for t in range(0, inputs.time_interval + 1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity ** t)) for t in range(0, inputs.time_interval + 1)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 2)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 2)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 0)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 0)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 0)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 0)]\n        positions.append(particle_positions)\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + 1)]",
      "mutated_line": "particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + -1)]",
      "code": "import math\n\ndef calculate_particle_positions(inputs):\n    positions = []\n    for j in range(inputs.per_circ):\n        angular_velocity = 2 * math.pi / inputs.time_interval\n        particle_positions = [(0, inputs.radius * math.cos(angular_velocity * t), inputs.radius * math.sin(angular_velocity * t)) for t in range(0, inputs.time_interval + -1)]\n        positions.append(particle_positions)\n    return positions"
    }
  ]
}