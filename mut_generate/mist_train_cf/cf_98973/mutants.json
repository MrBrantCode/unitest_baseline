{
  "task_id": "cf_98973",
  "entry_point": "find_subset",
  "mutant_count": 28,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if len(current_subset) == subset_size and current_sum == target_sum:",
      "mutated_line": "if len(current_subset) == subset_size or current_sum == target_sum:",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size or current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if current_sum > target_sum or start >= len(numbers):",
      "mutated_line": "if current_sum > target_sum and start >= len(numbers):",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum and start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return backtrack(0, 0, [])",
      "mutated_line": "return backtrack(1, 0, [])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(1, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return backtrack(0, 0, [])",
      "mutated_line": "return backtrack(-1, 0, [])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(-1, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return backtrack(0, 0, [])",
      "mutated_line": "return backtrack(1, 0, [])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(1, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return backtrack(0, 0, [])",
      "mutated_line": "return backtrack(0, 1, [])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return backtrack(0, 0, [])",
      "mutated_line": "return backtrack(0, -1, [])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, -1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return backtrack(0, 0, [])",
      "mutated_line": "return backtrack(0, 1, [])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(current_subset) == subset_size and current_sum == target_sum:",
      "mutated_line": "if len(current_subset) != subset_size and current_sum == target_sum:",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) != subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(current_subset) == subset_size and current_sum == target_sum:",
      "mutated_line": "if len(current_subset) == subset_size and current_sum != target_sum:",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum != target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if current_sum > target_sum or start >= len(numbers):",
      "mutated_line": "if current_sum >= target_sum or start >= len(numbers):",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum >= target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if current_sum > target_sum or start >= len(numbers):",
      "mutated_line": "if current_sum <= target_sum or start >= len(numbers):",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum <= target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if current_sum > target_sum or start >= len(numbers):",
      "mutated_line": "if current_sum != target_sum or start >= len(numbers):",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum != target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if current_sum > target_sum or start >= len(numbers):",
      "mutated_line": "if current_sum > target_sum or start > len(numbers):",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start > len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if current_sum > target_sum or start >= len(numbers):",
      "mutated_line": "if current_sum > target_sum or start < len(numbers):",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start < len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if current_sum > target_sum or start >= len(numbers):",
      "mutated_line": "if current_sum > target_sum or start == len(numbers):",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start == len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if numbers[i] in current_subset:",
      "mutated_line": "if numbers[i] not in current_subset:",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] not in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i - 1, current_sum + numbers[i], current_subset + [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i - 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i * 1, current_sum + numbers[i], current_subset + [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i * 1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i + 1, current_sum - numbers[i], current_subset + [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum - numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i + 1, current_sum * numbers[i], current_subset + [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum * numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i + 1, current_sum + numbers[i], current_subset - [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset - [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i + 1, current_sum + numbers[i], current_subset * [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 1, current_sum + numbers[i], current_subset * [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i + 2, current_sum + numbers[i], current_subset + [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 2, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i + 0, current_sum + numbers[i], current_subset + [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 0, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i + 0, current_sum + numbers[i], current_subset + [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + 0, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = backtrack(i+1, current_sum+numbers[i], current_subset+[numbers[i]])",
      "mutated_line": "result = backtrack(i + -1, current_sum + numbers[i], current_subset + [numbers[i]])",
      "code": "def find_subset(numbers, target_sum, subset_size):\n    \"\"\"\n    Find a subset of numbers that sums up to target_sum, using each number only once\n    and using at least subset_size numbers in the subset.\n    \"\"\"\n\n    def backtrack(start, current_sum, current_subset):\n        if len(current_subset) == subset_size and current_sum == target_sum:\n            return current_subset\n        if current_sum > target_sum or start >= len(numbers):\n            return None\n        for i in range(start, len(numbers)):\n            if numbers[i] in current_subset:\n                continue\n            result = backtrack(i + -1, current_sum + numbers[i], current_subset + [numbers[i]])\n            if result:\n                return result\n        return None\n    return backtrack(0, 0, [])"
    }
  ]
}