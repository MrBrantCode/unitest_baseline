{
  "task_id": "cf_30203",
  "entry_point": "calculate_shortest_path",
  "mutant_count": 23,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if start not in graph or end not in graph:",
      "mutated_line": "if start not in graph and end not in graph:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph and end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 1\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = -1",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = -1\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 1\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while current_node != start:",
      "mutated_line": "while current_node == start:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node == start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if start not in graph or end not in graph:",
      "mutated_line": "if start in graph or end not in graph:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if start not in graph or end not in graph:",
      "mutated_line": "if start not in graph or end in graph:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path.insert(0, start)",
      "mutated_line": "path.insert(1, start)",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(1, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path.insert(0, start)",
      "mutated_line": "path.insert(-1, start)",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(-1, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path.insert(0, start)",
      "mutated_line": "path.insert(1, start)",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(1, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distances = {node: float('inf') for node in graph}",
      "mutated_line": "distances = {node: float('') for node in graph}",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "new_distance = distances[current_node] + weight",
      "mutated_line": "new_distance = distances[current_node] - weight",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] - weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "new_distance = distances[current_node] + weight",
      "mutated_line": "new_distance = distances[current_node] * weight",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] * weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if new_distance < distances[neighbor]:",
      "mutated_line": "if new_distance <= distances[neighbor]:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance <= distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if new_distance < distances[neighbor]:",
      "mutated_line": "if new_distance >= distances[neighbor]:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance >= distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if new_distance < distances[neighbor]:",
      "mutated_line": "if new_distance != distances[neighbor]:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance != distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path.insert(0, current_node)",
      "mutated_line": "path.insert(1, current_node)",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(1, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path.insert(0, current_node)",
      "mutated_line": "path.insert(-1, current_node)",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(-1, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path.insert(0, current_node)",
      "mutated_line": "path.insert(1, current_node)",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(1, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if distances[current_node] == distances[neighbor] + weight:",
      "mutated_line": "if distances[current_node] != distances[neighbor] + weight:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] != distances[neighbor] + weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if distances[current_node] == distances[neighbor] + weight:",
      "mutated_line": "if distances[current_node] == distances[neighbor] - weight:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] - weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if distances[current_node] == distances[neighbor] + weight:",
      "mutated_line": "if distances[current_node] == distances[neighbor] * weight:",
      "code": "def calculate_shortest_path(graph, start, end):\n    \"\"\"\n    This function calculates the shortest path in a graph using Dijkstra's algorithm.\n    \n    Args:\n    graph (dict): A dictionary representing the graph where each key is a node and its corresponding value is another dictionary containing the neighboring nodes and their respective edge weights.\n    start (str): The starting location.\n    end (str): The ending location.\n    \n    Returns:\n    list: A list of locations representing the shortest path from the start to the end location. If the start or end location is not in the graph, an empty list is returned.\n    \"\"\"\n    if start not in graph or end not in graph:\n        return []\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    unvisited_nodes = set(graph)\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            new_distance = distances[current_node] + weight\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    path = []\n    current_node = end\n    while current_node != start:\n        path.insert(0, current_node)\n        for (neighbor, weight) in graph[current_node].items():\n            if distances[current_node] == distances[neighbor] * weight:\n                current_node = neighbor\n                break\n    path.insert(0, start)\n    return path"
    }
  ]
}