{
  "task_id": "cf_77233",
  "entry_point": "size",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if node is None:",
      "mutated_line": "if node is not None:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is not None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if node is None:",
      "mutated_line": "if node is not None:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is not None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if node is None:",
      "mutated_line": "if node is not None:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is not None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "mid = len(arr) // 2",
      "mutated_line": "mid = len(arr) / 2",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) / 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "mid = len(arr) // 2",
      "mutated_line": "mid = len(arr) * 2",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) * 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if size(tree1) < size(tree2):",
      "mutated_line": "if size(tree1) <= size(tree2):",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) <= size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if size(tree1) < size(tree2):",
      "mutated_line": "if size(tree1) >= size(tree2):",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) >= size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if size(tree1) < size(tree2):",
      "mutated_line": "if size(tree1) != size(tree2):",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) != size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 1\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return -1\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 1\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return(size(node.left) + 1 + size(node.right))",
      "mutated_line": "return size(node.left) + 1 - size(node.right)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 - size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return(size(node.left) + 1 + size(node.right))",
      "mutated_line": "return (size(node.left) + 1) * size(node.right)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return (size(node.left) + 1) * size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if node.data > data:",
      "mutated_line": "node.left = insert(node.left, data)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data >= data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if node.data > data:",
      "mutated_line": "node.left = insert(node.left, data)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data <= data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if node.data > data:",
      "mutated_line": "node.left = insert(node.left, data)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data != data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mid = len(arr) // 2",
      "mutated_line": "mid = len(arr) // 3",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 3\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mid = len(arr) // 2",
      "mutated_line": "mid = len(arr) // 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 1\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mid = len(arr) // 2",
      "mutated_line": "mid = len(arr) // 0",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 0\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mid = len(arr) // 2",
      "mutated_line": "mid = len(arr) // 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 1\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mid = len(arr) // 2",
      "mutated_line": "mid = len(arr) // -2",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // -2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return(size(node.left) + 1 + size(node.right))",
      "mutated_line": "return size(node.left) - 1 + size(node.right)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) - 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return(size(node.left) + 1 + size(node.right))",
      "mutated_line": "return size(node.left) * 1 + size(node.right)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) * 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return(size(node.left) + 1 + size(node.right))",
      "mutated_line": "return size(node.left) + 2 + size(node.right)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 2 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return(size(node.left) + 1 + size(node.right))",
      "mutated_line": "return size(node.left) + 0 + size(node.right)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 0 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return(size(node.left) + 1 + size(node.right))",
      "mutated_line": "return size(node.left) + 0 + size(node.right)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 0 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return(size(node.left) + 1 + size(node.right))",
      "mutated_line": "return size(node.left) + -1 + size(node.right)",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + -1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "root.right = sortedArrayToBST(arr[mid+1:])",
      "mutated_line": "root.right = sortedArrayToBST(arr[mid - 1:])",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid - 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "root.right = sortedArrayToBST(arr[mid+1:])",
      "mutated_line": "root.right = sortedArrayToBST(arr[mid * 1:])",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid * 1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "root.right = sortedArrayToBST(arr[mid+1:])",
      "mutated_line": "root.right = sortedArrayToBST(arr[mid + 2:])",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 2:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "root.right = sortedArrayToBST(arr[mid+1:])",
      "mutated_line": "root.right = sortedArrayToBST(arr[mid + 0:])",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 0:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "root.right = sortedArrayToBST(arr[mid+1:])",
      "mutated_line": "root.right = sortedArrayToBST(arr[mid + 0:])",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + 0:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "root.right = sortedArrayToBST(arr[mid+1:])",
      "mutated_line": "root.right = sortedArrayToBST(arr[mid + -1:])",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef size(node):\n    if node is None:\n        return 0\n    else:\n        return size(node.left) + 1 + size(node.right)\n\ndef insert(node, data):\n    if node is None:\n        return Node(data)\n    elif node.data > data:\n        node.left = insert(node.left, data)\n    else:\n        node.right = insert(node.right, data)\n    return node\n\ndef inorderTraversal(node, inorder):\n    if node is None:\n        return\n    inorderTraversal(node.left, inorder)\n    inorder.append(node.data)\n    inorderTraversal(node.right, inorder)\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid + -1:])\n    return root\n\ndef mergeTrees(tree1, tree2):\n    if size(tree1) < size(tree2):\n        (tree1, tree2) = (tree2, tree1)\n    inorder = []\n    inorderTraversal(tree1, inorder)\n    inorderTraversal(tree2, inorder)\n    sortedArr = sorted(inorder)\n    return sortedArrayToBST(sortedArr)"
    }
  ]
}