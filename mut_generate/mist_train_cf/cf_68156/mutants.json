{
  "task_id": "cf_68156",
  "entry_point": "minMedianEnergy",
  "mutant_count": 173,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) != (n - 1, n - 1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) != (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([1, 0, 1], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([1, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([-1, 0, 1], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([-1, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([1, 0, 1], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([1, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 1, 1], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 1, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, -1, 1], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, -1, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 1, 1], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 1, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 2], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 2], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 0], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 0], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 0], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 0], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, -1], [0, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, -1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [1, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [1, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [-1, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [-1, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [1, 1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [1, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 2, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 2, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 0, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 0, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 0, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 0, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, -1, 0], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, -1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 1], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 1], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, -1], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, -1], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 1], [1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 1], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [2, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [2, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [0, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [0, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [0, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [0, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [-1, 0, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [-1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 1, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 1, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, -1, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, -1, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 1, 0])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 1, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 1])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 1])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, -1])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, -1])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx, dy, dz = [0,0,1], [0,1,0], [1,0,0]",
      "mutated_line": "(dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 1])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 1])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prev = {(0, 0, 0): None}",
      "mutated_line": "prev = {(1, 0, 0): None}",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(1, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prev = {(0, 0, 0): None}",
      "mutated_line": "prev = {(-1, 0, 0): None}",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(-1, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prev = {(0, 0, 0): None}",
      "mutated_line": "prev = {(1, 0, 0): None}",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(1, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prev = {(0, 0, 0): None}",
      "mutated_line": "prev = {(0, 1, 0): None}",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 1, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prev = {(0, 0, 0): None}",
      "mutated_line": "prev = {(0, -1, 0): None}",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, -1, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prev = {(0, 0, 0): None}",
      "mutated_line": "prev = {(0, 1, 0): None}",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 1, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prev = {(0, 0, 0): None}",
      "mutated_line": "prev = {(0, 0, 1): None}",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 1): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prev = {(0, 0, 0): None}",
      "mutated_line": "prev = {(0, 0, -1): None}",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, -1): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prev = {(0, 0, 0): None}",
      "mutated_line": "prev = {(0, 0, 1): None}",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 1): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(3):",
      "mutated_line": "(nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(4):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(3):",
      "mutated_line": "(nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(2):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(3):",
      "mutated_line": "(nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(0):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(3):",
      "mutated_line": "(nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(1):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(3):",
      "mutated_line": "(nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(-3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n or ny < n or nz < n or (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) or ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n or ny < n or nz < n or (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) or ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][1], (0, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][1], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][-1], (0, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][-1], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][1], (0, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][1], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][0], (1, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (1, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][0], (-1, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (-1, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][0], (1, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (1, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][0], (0, 1, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 1, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][0], (0, -1, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, -1, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][0], (0, 1, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 1, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][0], (0, 0, 1))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 1))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][0], (0, 0, -1))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, -1))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][0][0], (0, 0, 1))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 1))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = set([(0,0,0)])",
      "mutated_line": "visited = set([(1, 0, 0)])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(1, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = set([(0,0,0)])",
      "mutated_line": "visited = set([(-1, 0, 0)])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(-1, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = set([(0,0,0)])",
      "mutated_line": "visited = set([(1, 0, 0)])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(1, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = set([(0,0,0)])",
      "mutated_line": "visited = set([(0, 1, 0)])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 1, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = set([(0,0,0)])",
      "mutated_line": "visited = set([(0, -1, 0)])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, -1, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = set([(0,0,0)])",
      "mutated_line": "visited = set([(0, 1, 0)])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 1, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = set([(0,0,0)])",
      "mutated_line": "visited = set([(0, 0, 1)])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 1)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = set([(0,0,0)])",
      "mutated_line": "visited = set([(0, 0, -1)])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, -1)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = set([(0,0,0)])",
      "mutated_line": "visited = set([(0, 0, 1)])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 1)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n + 1, n - 1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n + 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n * 1, n - 1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n * 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n + 1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n + 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n * 1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n * 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - 1, n + 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n + 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - 1, n * 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n * 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 != 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 != 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) * 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) * 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) // 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) // 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny, nz = x + dx[i], y + dy[i], z + dz[i]",
      "mutated_line": "(nx, ny, nz) = (x - dx[i], y + dy[i], z + dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x - dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny, nz = x + dx[i], y + dy[i], z + dz[i]",
      "mutated_line": "(nx, ny, nz) = (x * dx[i], y + dy[i], z + dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x * dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny, nz = x + dx[i], y + dy[i], z + dz[i]",
      "mutated_line": "(nx, ny, nz) = (x + dx[i], y - dy[i], z + dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y - dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny, nz = x + dx[i], y + dy[i], z + dz[i]",
      "mutated_line": "(nx, ny, nz) = (x + dx[i], y * dy[i], z + dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y * dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny, nz = x + dx[i], y + dy[i], z + dz[i]",
      "mutated_line": "(nx, ny, nz) = (x + dx[i], y + dy[i], z - dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z - dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny, nz = x + dx[i], y + dy[i], z + dz[i]",
      "mutated_line": "(nx, ny, nz) = (x + dx[i], y + dy[i], z * dz[i])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z * dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx <= n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx <= n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx >= n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx >= n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx != n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx != n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny <= n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny <= n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny >= n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny >= n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny != n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny != n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz <= n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz <= n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz >= n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz >= n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz != n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz != n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) < 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) < 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) > 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) > 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) == 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) == 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][1][0], (0, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][1][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][-1][0], (0, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][-1][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[0][1][0], (0, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][1][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 2, n - 1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 2, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 0, n - 1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 0, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 0, n - 1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 0, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - -1, n - 1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - -1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - 2, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 2, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - 0, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 0, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - 0, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 0, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - -1, n - 1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - -1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - 1, n - 2):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 2):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - 1, n - 0):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 0):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - 1, n - 0):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 0):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (x, y, z) == (n-1, n-1, n-1):",
      "mutated_line": "if (x, y, z) == (n - 1, n - 1, n - -1):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - -1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while prev[path[0]]:",
      "mutated_line": "while prev[path[1]]:",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[1]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while prev[path[0]]:",
      "mutated_line": "while prev[path[-1]]:",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[-1]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while prev[path[0]]:",
      "mutated_line": "while prev[path[1]]:",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[1]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path.insert(0, prev[path[0]])",
      "mutated_line": "path.insert(1, prev[path[0]])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(1, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path.insert(0, prev[path[0]])",
      "mutated_line": "path.insert(-1, prev[path[0]])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(-1, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path.insert(0, prev[path[0]])",
      "mutated_line": "path.insert(1, prev[path[0]])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(1, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m * 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m * 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m + 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m + 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 1 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 1 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == -1 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == -1 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 1 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 1 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] - energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] - energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = energy_list[(m - 1) // 2] * energy_list[m // 2] / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = energy_list[(m - 1) // 2] * energy_list[m // 2] / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 3 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 3 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 1 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 1 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 0 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 0 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 1 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 1 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / -2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / -2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m / 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m / 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m * 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m * 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 11) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 11) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 9) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 9) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 0) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 0) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 1) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 1) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= -10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= -10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[1][0][0], (0, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[1][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[-1][0][0], (0, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[-1][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(cube[0][0][0], (0, 0, 0))]",
      "mutated_line": "heap = [(cube[1][0][0], (0, 0, 0))]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[1][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 3 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 3 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 1 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 1 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 0 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 0 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 1 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 1 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % -2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % -2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 3]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 3]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 1]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 1]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 0]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 0]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 1]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 1]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // -2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // -2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] + cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] + cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if nx < n and ny < n and nz < n and abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10 and (nx, ny, nz) not in visited:",
      "mutated_line": "if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] * cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] * cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path.insert(0, prev[path[0]])",
      "mutated_line": "path.insert(0, prev[path[1]])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[1]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path.insert(0, prev[path[0]])",
      "mutated_line": "path.insert(0, prev[path[-1]])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[-1]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path.insert(0, prev[path[0]])",
      "mutated_line": "path.insert(0, prev[path[1]])",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[1]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) / 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) / 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) * 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) * 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m / 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m / 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m * 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m * 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m + 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m + 1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[m * 1 // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[m * 1 // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 3] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 3] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 1] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 1] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 0] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 0] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 1] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 1] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // -2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // -2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 3]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 3]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 1]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 1]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 0]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 0]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // 1]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // 1]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 1) // 2] + energy_list[m // -2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 1) // 2] + energy_list[m // -2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 2) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 2) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 0) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 0) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - 0) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - 0) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "median = (energy_list[(m-1)//2] + energy_list[m//2]) / 2 if m % 2 == 0 else energy_list[m//2]",
      "mutated_line": "median = (energy_list[(m - -1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]",
      "code": "import heapq\n\ndef minMedianEnergy(cube):\n    n = len(cube)\n    heap = [(cube[0][0][0], (0, 0, 0))]\n    visited = set([(0, 0, 0)])\n    (dx, dy, dz) = ([0, 0, 1], [0, 1, 0], [1, 0, 0])\n    prev = {(0, 0, 0): None}\n    while heap:\n        (energy, (x, y, z)) = heapq.heappop(heap)\n        if (x, y, z) == (n - 1, n - 1, n - 1):\n            path = [(x, y, z)]\n            while prev[path[0]]:\n                path.insert(0, prev[path[0]])\n            energy_list = [cube[x][y][z] for (x, y, z) in path]\n            m = len(energy_list)\n            median = (energy_list[(m - -1) // 2] + energy_list[m // 2]) / 2 if m % 2 == 0 else energy_list[m // 2]\n            return median\n        for i in range(3):\n            (nx, ny, nz) = (x + dx[i], y + dy[i], z + dz[i])\n            if nx < n and ny < n and (nz < n) and (abs(cube[nx][ny][nz] - cube[x][y][z]) <= 10) and ((nx, ny, nz) not in visited):\n                heapq.heappush(heap, (cube[nx][ny][nz], (nx, ny, nz)))\n                visited.add((nx, ny, nz))\n                prev[nx, ny, nz] = (x, y, z)\n    return None"
    }
  ]
}