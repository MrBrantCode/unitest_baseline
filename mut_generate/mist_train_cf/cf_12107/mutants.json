{
  "task_id": "cf_12107",
  "entry_point": "avoid_deadlock",
  "mutant_count": 26,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'': 0, 'B': 1, 'C': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, '': 1, 'C': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, '': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': 1, '': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, '': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 1, 'B': 1, 'C': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 1, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': -1, 'B': 1, 'C': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': -1, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 1, 'B': 1, 'C': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 1, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': 2, 'C': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 2, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': 0, 'C': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 0, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': 0, 'C': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 0, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': -1, 'C': 2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': -1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': 1, 'C': 3}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 3}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': 1, 'C': 1}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 1}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': 1, 'C': 0}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 0}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': 1, 'C': 1}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 1}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "resource_order = {'A': 0, 'B': 1, 'C': 2}",
      "mutated_line": "resource_order = {'A': 0, 'B': 1, 'C': -2}",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': -2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result.append([thread[0], thread[1]])",
      "mutated_line": "result.append([thread[1], thread[1]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[1], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result.append([thread[0], thread[1]])",
      "mutated_line": "result.append([thread[-1], thread[1]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[-1], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result.append([thread[0], thread[1]])",
      "mutated_line": "result.append([thread[1], thread[1]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[1], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result.append([thread[0], thread[1]])",
      "mutated_line": "result.append([thread[0], thread[2]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[2]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result.append([thread[0], thread[1]])",
      "mutated_line": "result.append([thread[0], thread[0]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[0]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result.append([thread[0], thread[1]])",
      "mutated_line": "result.append([thread[0], thread[0]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[0]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result.append([thread[0], thread[1]])",
      "mutated_line": "result.append([thread[0], thread[-1]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[-1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])",
      "mutated_line": "sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[1]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[1]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])",
      "mutated_line": "sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[-1]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[-1]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[0]])",
      "mutated_line": "sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[1]])",
      "code": "from typing import List\n\ndef avoid_deadlock(threads: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    This function takes a list of threads, where each thread is represented as a list of two resources.\n    The first resource in the list is the one that the thread requires, and the second resource is the one that the thread holds.\n    The function returns the order in which the threads should acquire the resources to prevent deadlock.\n\n    :param threads: A list of threads, where each thread is a list of two resources.\n    :return: The order in which the threads should acquire the resources to prevent deadlock.\n    \"\"\"\n    resource_order = {'A': 0, 'B': 1, 'C': 2}\n    sorted_threads = sorted(threads, key=lambda thread: resource_order[thread[1]])\n    result = []\n    for thread in sorted_threads:\n        result.append([thread[0], thread[1]])\n    return result"
    }
  ]
}