{
  "task_id": "cf_85976",
  "entry_point": "getMaximumGold",
  "mutant_count": 85,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxGold, steps, ans = 0, 0, []",
      "mutated_line": "(maxGold, steps, ans) = (1, 0, [])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (1, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxGold, steps, ans = 0, 0, []",
      "mutated_line": "(maxGold, steps, ans) = (-1, 0, [])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (-1, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxGold, steps, ans = 0, 0, []",
      "mutated_line": "(maxGold, steps, ans) = (1, 0, [])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (1, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxGold, steps, ans = 0, 0, []",
      "mutated_line": "(maxGold, steps, ans) = (0, 1, [])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 1, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxGold, steps, ans = 0, 0, []",
      "mutated_line": "(maxGold, steps, ans) = (0, -1, [])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, -1, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxGold, steps, ans = 0, 0, []",
      "mutated_line": "(maxGold, steps, ans) = (0, 1, [])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 1, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited = [[False]*n for _ in range(m)]",
      "mutated_line": "visited = [[False] / n for _ in range(m)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] / n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited = [[False]*n for _ in range(m)]",
      "mutated_line": "visited = [[False] + n for _ in range(m)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] + n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited = [[False]*n for _ in range(m)]",
      "mutated_line": "visited = [[False] ** n for _ in range(m)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] ** n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if gold > maxGold or (gold == maxGold and len(path) < steps):",
      "mutated_line": "if gold > maxGold and (gold == maxGold and len(path) < steps):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold and (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(1, -1), (-1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(1, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(-1, -1), (-1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(-1, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(1, -1), (-1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(1, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, +1), (-1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, +1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (+1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (+1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 1), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 1), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, -1), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, -1), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 1), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 1), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (1, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (1, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (-1, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (-1, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (1, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (1, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 2), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 2), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 0), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 0), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 0), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 0), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, -1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, -1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 1), (2, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (2, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 1), (0, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (0, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 1), (0, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (0, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 1), (-1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (-1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 1)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 1)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, -1)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, -1)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 1)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 1)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if gold > maxGold or (gold == maxGold and len(path) < steps):",
      "mutated_line": "if gold >= maxGold or (gold == maxGold and len(path) < steps):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold >= maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if gold > maxGold or (gold == maxGold and len(path) < steps):",
      "mutated_line": "if gold <= maxGold or (gold == maxGold and len(path) < steps):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold <= maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if gold > maxGold or (gold == maxGold and len(path) < steps):",
      "mutated_line": "if gold != maxGold or (gold == maxGold and len(path) < steps):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold != maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if gold > maxGold or (gold == maxGold and len(path) < steps):",
      "mutated_line": "if gold > maxGold or (gold == maxGold or len(path) < steps):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold or len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n or (not visited[nx][ny]) or (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m or 0 <= ny < n or (not visited[nx][ny]) or (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if grid[i][j] != 0:",
      "mutated_line": "if grid[i][j] == 0:",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -2), (-1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -2), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -0), (-1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -0), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -0), (-1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -0), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, --1), (-1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, --1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-2, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-2, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-0, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-0, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-0, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-0, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (--1, 0), (0, 1), (1, 0)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (--1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[1]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[-1]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[1]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited = [[False]*n for _ in range(m)]",
      "mutated_line": "visited = [[True] * n for _ in range(m)]",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[True] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if gold > maxGold or (gold == maxGold and len(path) < steps):",
      "mutated_line": "if gold > maxGold or (gold != maxGold and len(path) < steps):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold != maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if gold > maxGold or (gold == maxGold and len(path) < steps):",
      "mutated_line": "if gold > maxGold or (gold == maxGold and len(path) <= steps):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) <= steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if gold > maxGold or (gold == maxGold and len(path) < steps):",
      "mutated_line": "if gold > maxGold or (gold == maxGold and len(path) >= steps):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) >= steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if gold > maxGold or (gold == maxGold and len(path) < steps):",
      "mutated_line": "if gold > maxGold or (gold == maxGold and len(path) != steps):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) != steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 < ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 > ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 == ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visited[nx][ny] = True",
      "mutated_line": "visited[nx][ny] = False",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = False\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[nx][ny] = False",
      "mutated_line": "visited[nx][ny] = True",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = True\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if grid[i][j] != 0:",
      "mutated_line": "if grid[i][j] != 1:",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 1:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if grid[i][j] != 0:",
      "mutated_line": "if grid[i][j] != -1:",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != -1:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if grid[i][j] != 0:",
      "mutated_line": "if grid[i][j] != 1:",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 1:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[i][j] = True",
      "mutated_line": "visited[i][j] = False",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = False\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[i][j] = False",
      "mutated_line": "visited[i][j] = True",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = True\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and -1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 1):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 1):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != -1):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != -1):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0<= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 1):",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 1):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])",
      "mutated_line": "dfs(nx, ny, gold - grid[nx][ny], path + [grid[nx][ny]])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold - grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])",
      "mutated_line": "dfs(nx, ny, gold * grid[nx][ny], path + [grid[nx][ny]])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold * grid[nx][ny], path + [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])",
      "mutated_line": "dfs(nx, ny, gold + grid[nx][ny], path - [grid[nx][ny]])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path - [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dfs(nx, ny, gold + grid[nx][ny], path + [grid[nx][ny]])",
      "mutated_line": "dfs(nx, ny, gold + grid[nx][ny], path * [grid[nx][ny]])",
      "code": "from typing import List\n\ndef getMaximumGold(grid: List[List[int]]) -> List[int]:\n    (maxGold, steps, ans) = (0, 0, [])\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y, gold, path):\n        nonlocal maxGold, steps, ans\n        if gold > maxGold or (gold == maxGold and len(path) < steps):\n            (maxGold, steps, ans) = (gold, len(path), path)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                visited[nx][ny] = True\n                dfs(nx, ny, gold + grid[nx][ny], path * [grid[nx][ny]])\n                visited[nx][ny] = False\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                visited[i][j] = True\n                dfs(i, j, grid[i][j], [grid[i][j]])\n                visited[i][j] = False\n    return [maxGold, ans]"
    }
  ]
}