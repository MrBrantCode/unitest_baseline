{
  "task_id": "cf_68522",
  "entry_point": "dict_operations",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if operation == 'merge':",
      "mutated_line": "if operation != 'merge':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation != 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if operation == 'merge':",
      "mutated_line": "if operation == '':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == '':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif operation == 'common_keys':",
      "mutated_line": "elif operation != 'common_keys':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation != 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "elif operation == 'common_keys':",
      "mutated_line": "elif operation == '':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == '':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif operation == 'unique_keys':",
      "mutated_line": "elif operation != 'unique_keys':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation != 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif operation == 'unique_keys':",
      "mutated_line": "elif operation == '':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == '':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if dict1 == dict2:",
      "mutated_line": "if dict1 != dict2:",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 != dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif operation == 'sort_by_value':",
      "mutated_line": "elif operation != 'sort_by_value':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation != 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "result = {k: dict1[k] for k in dict1 if k in dict2}",
      "mutated_line": "result = {k: dict1[k] for k in dict1 if k not in dict2}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return \"Error: Dictionaries are identical, no unique keys.\"",
      "mutated_line": "return ''",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return ''\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif operation == 'sort_by_value':",
      "mutated_line": "elif operation == '':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == '':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif operation == 'sort_by_key':",
      "mutated_line": "elif operation != 'sort_by_key':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation != 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "result = {k: dict1[k] for k in dict1 if k not in dict2}",
      "mutated_line": "result = {k: dict1[k] for k in dict1 if k in dict2}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif operation == 'sort_by_key':",
      "mutated_line": "elif operation == '':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == '':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif operation == 'value_difference':",
      "mutated_line": "elif operation != 'value_difference':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation != 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return {k: v for k, v in sorted(result.items(), key=lambda item: item[0])}",
      "mutated_line": "return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return {k: v for k, v in sorted(result.items(), key=lambda item: item[0])}",
      "mutated_line": "return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[-1])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[-1])}"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return {k: v for k, v in sorted(result.items(), key=lambda item: item[0])}",
      "mutated_line": "return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "result.update({k: dict2[k] for k in dict2 if k not in dict1})",
      "mutated_line": "result.update({k: dict2[k] for k in dict2 if k in dict1})",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif operation == 'value_difference':",
      "mutated_line": "elif operation == '':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == '':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif operation == 'key_intersection':",
      "mutated_line": "elif operation != 'key_intersection':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation != 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif operation == 'key_intersection':",
      "mutated_line": "elif operation == '':",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == '':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return \"Error: Invalid operation.\"",
      "mutated_line": "return ''",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return ''\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, 0) + dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) + dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, 0) * dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) * dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) & set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) & set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) ^ set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) ^ set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = {k: dict1[k] for k in set(dict1) & set(dict2)}",
      "mutated_line": "result = {k: dict1[k] for k in set(dict1) | set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) | set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "result = {k: v for k, v in sorted(result.items(), key=lambda item: item[1])}",
      "mutated_line": "result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[2])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[2])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "result = {k: v for k, v in sorted(result.items(), key=lambda item: item[1])}",
      "mutated_line": "result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "result = {k: v for k, v in sorted(result.items(), key=lambda item: item[1])}",
      "mutated_line": "result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "result = {k: v for k, v in sorted(result.items(), key=lambda item: item[1])}",
      "mutated_line": "result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[-1])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[-1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, 1) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 1) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, -1) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, -1) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, 1) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 1) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 1)) for k in set(dict1) | set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 1)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, -1)) for k in set(dict1) | set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, -1)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}",
      "mutated_line": "result = {k: abs(dict1.get(k, 0) - dict2.get(k, 1)) for k in set(dict1) | set(dict2)}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 1)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result = {k: v for k, v in sorted(result.items(), key=lambda item: item[0])}",
      "mutated_line": "result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result = {k: v for k, v in sorted(result.items(), key=lambda item: item[0])}",
      "mutated_line": "result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[-1])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[-1])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result = {k: v for k, v in sorted(result.items(), key=lambda item: item[0])}",
      "mutated_line": "result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}",
      "code": "def dict_operations(dict1, dict2, operations):\n    result = {}\n    for operation in operations:\n        if operation == 'merge':\n            result = {**dict1, **dict2}\n        elif operation == 'common_keys':\n            result = {k: dict1[k] for k in dict1 if k in dict2}\n        elif operation == 'unique_keys':\n            if dict1 == dict2:\n                return 'Error: Dictionaries are identical, no unique keys.'\n            result = {k: dict1[k] for k in dict1 if k not in dict2}\n            result.update({k: dict2[k] for k in dict2 if k not in dict1})\n        elif operation == 'sort_by_value':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'sort_by_key':\n            result = {k: v for (k, v) in sorted(result.items(), key=lambda item: item[1])}\n        elif operation == 'value_difference':\n            result = {k: abs(dict1.get(k, 0) - dict2.get(k, 0)) for k in set(dict1) | set(dict2)}\n        elif operation == 'key_intersection':\n            result = {k: dict1[k] for k in set(dict1) & set(dict2)}\n        else:\n            return 'Error: Invalid operation.'\n    return {k: v for (k, v) in sorted(result.items(), key=lambda item: item[0])}"
    }
  ]
}