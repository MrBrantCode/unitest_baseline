{
  "task_id": "cf_27033",
  "entry_point": "non_maximum_suppression",
  "mutant_count": 109,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) / max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) / max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) + max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) + max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) ** max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) ** max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) / (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) / (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = box1[2] - box1[0] + (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = box1[2] - box1[0] + (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) ** (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) ** (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) / (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) / (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = box2[2] - box2[0] + (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = box2[2] - box2[0] + (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) ** (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) ** (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "union = area1 + area2 - intersection",
      "mutated_line": "union = area1 + area2 + intersection",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 + intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "union = area1 + area2 - intersection",
      "mutated_line": "union = (area1 + area2) * intersection",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = (area1 + area2) * intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "overlap = intersection / union",
      "mutated_line": "overlap = intersection * union",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection * union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "overlap = intersection / union",
      "mutated_line": "overlap = intersection // union",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection // union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] + box1[0]) * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] + box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = box1[2] * box1[0] * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = box1[2] * box1[0] * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] + box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] + box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] * box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] * box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] + box2[0]) * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] + box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = box2[2] * box2[0] * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = box2[2] * box2[0] * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] + box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] + box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] * box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] * box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "union = area1 + area2 - intersection",
      "mutated_line": "union = area1 - area2 - intersection",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 - area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "union = area1 + area2 - intersection",
      "mutated_line": "union = area1 * area2 - intersection",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 * area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)",
      "mutated_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=False)",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=False)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(1, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(1, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(-1, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(-1, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(1, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(1, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) + max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) + max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) * max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) * max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(1, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(1, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(-1, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(-1, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(1, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(1, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) + max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) + max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) * max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) * max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[3] - box1[0]) * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[3] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[1] - box1[0]) * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[1] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[0] - box1[0]) * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[0] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[1] - box1[0]) * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[1] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[-2] - box1[0]) * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[-2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[1]) * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[1]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[-1]) * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[-1]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[1]) * (box1[3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[1]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[4] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[4] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[2] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[2] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[0] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[0] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[1] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[1] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[-3] - box1[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[-3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[2])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[2])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[0])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[0])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[0])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[0])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[-1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[-1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[3] - box2[0]) * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[3] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[1] - box2[0]) * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[1] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[0] - box2[0]) * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[0] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[1] - box2[0]) * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[1] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[-2] - box2[0]) * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[-2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[1]) * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[1]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[-1]) * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[-1]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[1]) * (box2[3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[1]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[4] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[4] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[2] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[2] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[0] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[0] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[1] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[1] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[-3] - box2[1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[-3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[2])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[2])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[0])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[0])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[0])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[0])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[-1])",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[-1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)",
      "mutated_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[2], reverse=True)",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[2], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)",
      "mutated_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[0], reverse=True)",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[0], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)",
      "mutated_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[0], reverse=True)",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[0], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)",
      "mutated_line": "sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[-1], reverse=True)",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[-1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if not any(overlap > overlap_threshold for overlap in overlaps):",
      "mutated_line": "if not any((overlap >= overlap_threshold for overlap in overlaps)):",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap >= overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if not any(overlap > overlap_threshold for overlap in overlaps):",
      "mutated_line": "if not any((overlap <= overlap_threshold for overlap in overlaps)):",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap <= overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if not any(overlap > overlap_threshold for overlap in overlaps):",
      "mutated_line": "if not any((overlap != overlap_threshold for overlap in overlaps)):",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap != overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[3], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[3], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[1], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[1], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[0], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[0], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[1], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[1], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[-2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[-2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[3]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[3]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[1]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[1]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[0]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[0]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[1]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[1]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[-2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[-2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[1], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[1], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[-1], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[-1], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[1], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[1], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[1])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[1])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[-1])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[-1])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[1])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[1])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[4], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[4], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[2], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[2], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[0], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[0], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[1], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[1], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[-3], box2[3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[-3], box2[3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[4]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[4]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[2]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[2]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[0]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[0]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[1]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[1]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[-3]) - max(box1[1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[-3]) - max(box1[1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[2], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[2], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[0], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[0], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[0], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[0], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[-1], box2[1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[-1], box2[1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[2]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[2]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[0]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[0]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[0]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[0]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[1]))",
      "mutated_line": "intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[-1]))",
      "code": "def non_maximum_suppression(bounding_boxes, confidence_scores, overlap_threshold):\n\n    def calculate_overlap(box1, box2):\n        intersection = max(0, min(box1[2], box2[2]) - max(box1[0], box2[0])) * max(0, min(box1[3], box2[3]) - max(box1[1], box2[-1]))\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        overlap = intersection / union\n        return overlap\n    boxes_with_scores = [(box, score) for (box, score) in zip(bounding_boxes, confidence_scores)]\n    sorted_boxes = sorted(boxes_with_scores, key=lambda x: x[1], reverse=True)\n    selected_boxes = []\n    for (box, score) in sorted_boxes:\n        overlaps = [calculate_overlap(box, sel_box) for sel_box in selected_boxes]\n        if not any((overlap > overlap_threshold for overlap in overlaps)):\n            selected_boxes.append(box)\n    return selected_boxes"
    }
  ]
}