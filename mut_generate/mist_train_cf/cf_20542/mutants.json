{
  "task_id": "cf_20542",
  "entry_point": "multiply_without_operator",
  "mutant_count": 38,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "product = 0",
      "mutated_line": "product = 1",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 1\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "product = 0",
      "mutated_line": "product = -1",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = -1\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "product = 0",
      "mutated_line": "product = 1",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 1\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while M > 0:",
      "mutated_line": "while M >= 0:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M >= 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while M > 0:",
      "mutated_line": "while M <= 0:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M <= 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while M > 0:",
      "mutated_line": "while M != 0:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M != 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while M > 0:",
      "mutated_line": "while M > 1:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 1:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while M > 0:",
      "mutated_line": "while M > -1:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > -1:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while M > 0:",
      "mutated_line": "while M > 1:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 1:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if M & 1:",
      "mutated_line": "if M | 1:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M | 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "product += N",
      "mutated_line": "product -= N",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product -= N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N <<= 1",
      "mutated_line": "N <<= 2",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 2\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N <<= 1",
      "mutated_line": "N <<= 0",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 0\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N <<= 1",
      "mutated_line": "N <<= 0",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 0\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N <<= 1",
      "mutated_line": "N <<= -1",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= -1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M >>= 1",
      "mutated_line": "M >>= 2",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 2\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M >>= 1",
      "mutated_line": "M >>= 0",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 0\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M >>= 1",
      "mutated_line": "M >>= 0",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 0\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M >>= 1",
      "mutated_line": "M >>= -1",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= -1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < 0) | (b < 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) | (b < 0) else product"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return +product if (a < 0) ^ (b < 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return +product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if M & 1:",
      "mutated_line": "if M & 2:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 2:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if M & 1:",
      "mutated_line": "if M & 0:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 0:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if M & 1:",
      "mutated_line": "if M & 0:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 0:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if M & 1:",
      "mutated_line": "if M & -1:",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & -1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 0) else product"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a <= 0) ^ (b < 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a <= 0) ^ (b < 0) else product"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a >= 0) ^ (b < 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a >= 0) ^ (b < 0) else product"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a != 0) ^ (b < 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a != 0) ^ (b < 0) else product"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < 0) ^ (b <= 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b <= 0) else product"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < 0) ^ (b >= 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b >= 0) else product"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < 0) ^ (b != 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b != 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < 1) ^ (b < 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 1) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < -1) ^ (b < 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < -1) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < 1) ^ (b < 0) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 1) ^ (b < 0) else product"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < 0) ^ (b < 1) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 1) else product"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < 0) ^ (b < -1) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < -1) else product"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -product if (a < 0) ^ (b < 0) else product",
      "mutated_line": "return -product if (a < 0) ^ (b < 1) else product",
      "code": "def multiply_without_operator(a, b):\n    \"\"\"\n    This function multiplies two integers without using the multiplication operator.\n    \n    It uses a binary multiplication algorithm, iterating through the bits of the smaller number,\n    adding the larger number to the product for each set bit, and doubling the larger number in each iteration.\n    \n    The function has a time complexity of O(log N), where N is the larger of the two numbers,\n    and a space complexity of O(1) because it only uses a single product variable for computation.\n    \"\"\"\n    N = max(abs(a), abs(b))\n    M = min(abs(a), abs(b))\n    product = 0\n    while M > 0:\n        if M & 1:\n            product += N\n        N <<= 1\n        M >>= 1\n    return -product if (a < 0) ^ (b < 1) else product"
    }
  ]
}