{
  "task_id": "cf_18413",
  "entry_point": "analyze_complexity",
  "mutant_count": 19,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if \"loop\" in algorithm_description:",
      "mutated_line": "theta_notation = 'Θ(n)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' not in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if \"loop\" in algorithm_description:",
      "mutated_line": "theta_notation = 'Θ(n)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if '' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "big_o_notation = \"O(n)\"",
      "mutated_line": "elif 'recursion' in algorithm_description:",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = ''\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "omega_notation = \"Ω(1)\"",
      "mutated_line": "big_o_notation = 'O(2^n)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = ''\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "theta_notation = \"Θ(n)\"",
      "mutated_line": "omega_notation = 'Ω(n)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = ''\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif \"recursion\" in algorithm_description:",
      "mutated_line": "theta_notation = 'Θ(2^n)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' not in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f\"Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}\"",
      "mutated_line": "return f'{big_o_notation}, {omega_notation}, {theta_notation}'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'{big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f\"Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}\"",
      "mutated_line": "return f'Time Complexity: {big_o_notation}{omega_notation}, {theta_notation}'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}{omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f\"Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}\"",
      "mutated_line": "return f'Time Complexity: {big_o_notation}, {omega_notation}{theta_notation}'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}{theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif \"recursion\" in algorithm_description:",
      "mutated_line": "theta_notation = 'Θ(2^n)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif '' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "big_o_notation = \"O(2^n)\"",
      "mutated_line": "elif 'parallelism' in algorithm_description:",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = ''\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "omega_notation = \"Ω(n)\"",
      "mutated_line": "big_o_notation = 'O(n/p)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = ''\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "theta_notation = \"Θ(2^n)\"",
      "mutated_line": "omega_notation = 'Ω(n/p)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = ''\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif \"parallelism\" in algorithm_description:",
      "mutated_line": "theta_notation = 'Θ(n/p)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' not in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif \"parallelism\" in algorithm_description:",
      "mutated_line": "theta_notation = 'Θ(n/p)'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif '' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "big_o_notation = \"O(n/p)\"",
      "mutated_line": "return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = ''\n        omega_notation = 'Ω(n/p)'\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "omega_notation = \"Ω(n/p)\"",
      "mutated_line": "return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = ''\n        theta_notation = 'Θ(n/p)'\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "theta_notation = \"Θ(n/p)\"",
      "mutated_line": "return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'",
      "code": "def analyze_complexity(algorithm_description):\n    \"\"\"\n    Analyze the time and space complexity of an algorithm based on its description.\n\n    Args:\n    algorithm_description (str): A descriptive string outlining the steps of the algorithm.\n\n    Returns:\n    str: A string describing the time and space complexity in big O, omega, and theta notation.\n    \"\"\"\n    big_o_notation = None\n    omega_notation = None\n    theta_notation = None\n    if 'loop' in algorithm_description:\n        big_o_notation = 'O(n)'\n        omega_notation = 'Ω(1)'\n        theta_notation = 'Θ(n)'\n    elif 'recursion' in algorithm_description:\n        big_o_notation = 'O(2^n)'\n        omega_notation = 'Ω(n)'\n        theta_notation = 'Θ(2^n)'\n    elif 'parallelism' in algorithm_description:\n        big_o_notation = 'O(n/p)'\n        omega_notation = 'Ω(n/p)'\n        theta_notation = ''\n    return f'Time Complexity: {big_o_notation}, {omega_notation}, {theta_notation}'"
    }
  ]
}