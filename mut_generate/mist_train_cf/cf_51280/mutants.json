{
  "task_id": "cf_51280",
  "entry_point": "summarize_by_class",
  "mutant_count": 66,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(2 * np.pi) * std) / exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) / exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(2 * np.pi) * std) + exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) + exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return (1 / (np.sqrt(2 * np.pi) * std)) ** exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return (1 / (np.sqrt(2 * np.pi) * std)) ** exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(+((x - mean) ** 2 / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(+((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 * (np.sqrt(2 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 * (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 // (np.sqrt(2 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 // (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "probabilities[class_value] = len(class_summaries) / float(total_rows)",
      "mutated_line": "probabilities[class_value] = len(class_summaries) * float(total_rows)",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) * float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "probabilities[class_value] = len(class_summaries) / float(total_rows)",
      "mutated_line": "probabilities[class_value] = len(class_summaries) // float(total_rows)",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) // float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)",
      "mutated_line": "probabilities[class_value] /= gaussian_pdf(x_test[i], mean, std)",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] /= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "best_label, best_prob = None, -1",
      "mutated_line": "(best_label, best_prob) = (None, +1)",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, +1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if best_label is None or probability > best_prob:",
      "mutated_line": "if best_label is None and probability > best_prob:",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None and probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 * (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 * (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 // (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 // (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 2 / (np.sqrt(2 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 2 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 0 / (np.sqrt(2 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 0 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 0 / (np.sqrt(2 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 0 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return -1 / (np.sqrt(2 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return -1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(2 * np.pi) / std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) / std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(2 * np.pi) + std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) + std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / np.sqrt(2 * np.pi) ** std * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / np.sqrt(2 * np.pi) ** std * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "best_label, best_prob = None, -1",
      "mutated_line": "(best_label, best_prob) = (None, -2)",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -2)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "best_label, best_prob = None, -1",
      "mutated_line": "(best_label, best_prob) = (None, -0)",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -0)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "best_label, best_prob = None, -1",
      "mutated_line": "(best_label, best_prob) = (None, -0)",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -0)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "best_label, best_prob = None, -1",
      "mutated_line": "(best_label, best_prob) = (None, --1)",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, --1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if best_label is None or probability > best_prob:",
      "mutated_line": "if best_label is not None or probability > best_prob:",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is not None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if best_label is None or probability > best_prob:",
      "mutated_line": "if best_label is None or probability >= best_prob:",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability >= best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if best_label is None or probability > best_prob:",
      "mutated_line": "if best_label is None or probability <= best_prob:",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability <= best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if best_label is None or probability > best_prob:",
      "mutated_line": "if best_label is None or probability != best_prob:",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability != best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) * 2 / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) * 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean + 2) / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean + 2) / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (2 / std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 / std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (2 + std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 + std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / 2 ** std ** 2))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / 2 ** std ** 2))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x + mean) ** 2 / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x + mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x * mean) ** 2 / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x * mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 3 / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 3 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 1 / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 1 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 0 / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 0 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 1 / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 1 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** -2 / (2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** -2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (3 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (3 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (1 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (1 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (0 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (0 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (1 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (1 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (-2 * std ** 2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (-2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (2 * (std * 2))))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * (std * 2))))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (2 * (std + 2))))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * (std + 2))))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(2 / np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 / np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(2 + np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 + np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(2 ** np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 ** np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]",
      "mutated_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[2])]",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[2])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]",
      "mutated_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[0])]",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[0])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]",
      "mutated_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[0])]",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[0])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]",
      "mutated_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[-1])]",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[-1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 3)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 3)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 1)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 1)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 0)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 0)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 1)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 1)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "exponent = np.exp(-((x-mean)**2 / (2 * std**2)))",
      "mutated_line": "exponent = np.exp(-((x - mean) ** 2 / (2 * std ** -2)))",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** -2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(3 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(3 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(1 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(1 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(0 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(0 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(1 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(1 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (1 / (np.sqrt(2 * np.pi) * std)) * exponent",
      "mutated_line": "return 1 / (np.sqrt(-2 * np.pi) * std) * exponent",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(-2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]",
      "mutated_line": "summaries[cls] = [(np.mean(X[y != cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y != cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y == cls, i])) for i in range(X.shape[1])]",
      "mutated_line": "summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y != cls, i])) for i in range(X.shape[1])]",
      "code": "import numpy as np\n\ndef summarize_by_class(X, y):\n    classes = np.unique(y)\n    summaries = {}\n    for cls in classes:\n        summaries[cls] = [(np.mean(X[y == cls, i]), np.std(X[y != cls, i])) for i in range(X.shape[1])]\n    return summaries\n\ndef gaussian_pdf(x, mean, std):\n    exponent = np.exp(-((x - mean) ** 2 / (2 * std ** 2)))\n    return 1 / (np.sqrt(2 * np.pi) * std) * exponent\n\ndef class_probabilities(summaries, x_test):\n    total_rows = sum([len(summaries[label]) for label in summaries])\n    probabilities = {}\n    for (class_value, class_summaries) in summaries.items():\n        probabilities[class_value] = len(class_summaries) / float(total_rows)\n        for i in range(len(class_summaries)):\n            (mean, std) = class_summaries[i]\n            probabilities[class_value] *= gaussian_pdf(x_test[i], mean, std)\n    return probabilities\n\ndef predict(summaries, x_test):\n    probabilities = class_probabilities(summaries, x_test)\n    (best_label, best_prob) = (None, -1)\n    for (cls, probability) in probabilities.items():\n        if best_label is None or probability > best_prob:\n            best_prob = probability\n            best_label = cls\n    return best_label\n\ndef NaiveBayes(X_train, y_train):\n    summaries = summarize_by_class(X_train, y_train)\n    return lambda x_test: predict(summaries, x_test)"
    }
  ]
}