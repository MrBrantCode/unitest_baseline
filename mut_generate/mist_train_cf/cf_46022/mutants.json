{
  "task_id": "cf_46022",
  "entry_point": "correct_decimal_places",
  "mutant_count": 47,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if '.' not in number_str:",
      "mutated_line": "if '.' in number_str:",
      "code": "def correct_decimal_places(number_str):\n    if '.' in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if '.' not in number_str:",
      "mutated_line": "if '' not in number_str:",
      "code": "def correct_decimal_places(number_str):\n    if '' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return number_str + '.0000'",
      "mutated_line": "return number_str - '.0000'",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str - '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return number_str + '.0000'",
      "mutated_line": "return number_str * '.0000'",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str * '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(decimal_part) > 4:",
      "mutated_line": "if len(decimal_part) >= 4:",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) >= 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(decimal_part) > 4:",
      "mutated_line": "if len(decimal_part) <= 4:",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) <= 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(decimal_part) > 4:",
      "mutated_line": "if len(decimal_part) != 4:",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) != 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return number_str + '.0000'",
      "mutated_line": "return number_str + ''",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + ''\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "decimal_part = number_str.split('.')[1]",
      "mutated_line": "decimal_part = number_str.split('.')[2]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[2]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "decimal_part = number_str.split('.')[1]",
      "mutated_line": "decimal_part = number_str.split('.')[0]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[0]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "decimal_part = number_str.split('.')[1]",
      "mutated_line": "decimal_part = number_str.split('.')[0]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[0]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "decimal_part = number_str.split('.')[1]",
      "mutated_line": "decimal_part = number_str.split('.')[-1]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[-1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(decimal_part) > 4:",
      "mutated_line": "if len(decimal_part) > 5:",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 5:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(decimal_part) > 4:",
      "mutated_line": "if len(decimal_part) > 3:",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 3:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(decimal_part) > 4:",
      "mutated_line": "if len(decimal_part) > 0:",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 0:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(decimal_part) > 4:",
      "mutated_line": "if len(decimal_part) > 1:",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 1:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(decimal_part) > 4:",
      "mutated_line": "if len(decimal_part) > -4:",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > -4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif len(decimal_part) < 4:",
      "mutated_line": "return number_str + '0' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) <= 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif len(decimal_part) < 4:",
      "mutated_line": "return number_str + '0' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) >= 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif len(decimal_part) < 4:",
      "mutated_line": "return number_str + '0' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) != 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "decimal_part = number_str.split('.')[1]",
      "mutated_line": "decimal_part = number_str.split('')[1]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif len(decimal_part) < 4:",
      "mutated_line": "return number_str + '0' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 5:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif len(decimal_part) < 4:",
      "mutated_line": "return number_str + '0' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 3:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif len(decimal_part) < 4:",
      "mutated_line": "return number_str + '0' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 0:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif len(decimal_part) < 4:",
      "mutated_line": "return number_str + '0' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 1:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif len(decimal_part) < 4:",
      "mutated_line": "return number_str + '0' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < -4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str - '0' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str - '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str * ('0' * (4 - len(decimal_part)))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str * ('0' * (4 - len(decimal_part)))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return number_str[:number_str.index('.')+5]",
      "mutated_line": "return number_str[:number_str.index('.') - 5]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') - 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return number_str[:number_str.index('.')+5]",
      "mutated_line": "return number_str[:number_str.index('.') * 5]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') * 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '0' / (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' / (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + ('0' + (4 - len(decimal_part)))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + ('0' + (4 - len(decimal_part)))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '0' ** (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' ** (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return number_str[:number_str.index('.')+5]",
      "mutated_line": "return number_str[:number_str.index('.') + 6]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 6]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return number_str[:number_str.index('.')+5]",
      "mutated_line": "return number_str[:number_str.index('.') + 4]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 4]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return number_str[:number_str.index('.')+5]",
      "mutated_line": "return number_str[:number_str.index('.') + 0]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 0]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return number_str[:number_str.index('.')+5]",
      "mutated_line": "return number_str[:number_str.index('.') + 1]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 1]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return number_str[:number_str.index('.')+5]",
      "mutated_line": "return number_str[:number_str.index('.') + -5]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + -5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '' * (4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '0' * (4 + len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 + len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '0' * (4 * len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 * len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return number_str[:number_str.index('.')+5]",
      "mutated_line": "return number_str[:number_str.index('') + 5]",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (4 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '0' * (5 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (5 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '0' * (3 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (3 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '0' * (0 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (0 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '0' * (1 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (1 - len(decimal_part))\n        else:\n            return number_str"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return number_str + '0'*(4-len(decimal_part))",
      "mutated_line": "return number_str + '0' * (-4 - len(decimal_part))",
      "code": "def correct_decimal_places(number_str):\n    if '.' not in number_str:\n        return number_str + '.0000'\n    else:\n        decimal_part = number_str.split('.')[1]\n        if len(decimal_part) > 4:\n            return number_str[:number_str.index('.') + 5]\n        elif len(decimal_part) < 4:\n            return number_str + '0' * (-4 - len(decimal_part))\n        else:\n            return number_str"
    }
  ]
}