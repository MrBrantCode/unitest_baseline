{
  "task_id": "cf_68840",
  "entry_point": "maxSumPath",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return max(map(max, paths))*-1",
      "mutated_line": "return max(map(max, paths)) / -1",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) / -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return max(map(max, paths))*-1",
      "mutated_line": "return max(map(max, paths)) + -1",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) + -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return max(map(max, paths))*-1",
      "mutated_line": "return max(map(max, paths)) ** (-1)",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) ** (-1)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "paths = [[-1]*n for _ in range(n)]",
      "mutated_line": "paths = [[-1] / n for _ in range(n)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] / n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "paths = [[-1]*n for _ in range(n)]",
      "mutated_line": "paths = [[-1] + n for _ in range(n)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] + n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "paths = [[-1]*n for _ in range(n)]",
      "mutated_line": "paths = [[-1] ** n for _ in range(n)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] ** n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if steps > paths[y][x]:",
      "mutated_line": "if steps >= paths[y][x]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps >= paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if steps > paths[y][x]:",
      "mutated_line": "if steps <= paths[y][x]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps <= paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if steps > paths[y][x]:",
      "mutated_line": "if steps != paths[y][x]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps != paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return max(map(max, paths))*-1",
      "mutated_line": "return max(map(max, paths)) * +1",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * +1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(+grid[0][0], 1, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(+grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], 2, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 2, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], 0, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 0, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], 0, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 0, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], -1, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], -1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], 1, 1, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 1, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], 1, -1, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, -1, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], 1, 1, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 1, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], 1, 0, 1)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 1)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], 1, 0, -1)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, -1)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][0], 1, 0, 1)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 1)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return max(map(max, paths))*-1",
      "mutated_line": "return max(map(max, paths)) * -2",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return max(map(max, paths))*-1",
      "mutated_line": "return max(map(max, paths)) * -0",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return max(map(max, paths))*-1",
      "mutated_line": "return max(map(max, paths)) * -0",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return max(map(max, paths))*-1",
      "mutated_line": "return max(map(max, paths)) * --1",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * --1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "paths = [[-1]*n for _ in range(n)]",
      "mutated_line": "paths = [[+1] * n for _ in range(n)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[+1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n or 0 <= newy < n or steps < k:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n or 0 <= newy < n or steps < k:\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "paths = [[-1]*n for _ in range(n)]",
      "mutated_line": "paths = [[-2] * n for _ in range(n)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-2] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "paths = [[-1]*n for _ in range(n)]",
      "mutated_line": "paths = [[-0] * n for _ in range(n)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-0] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "paths = [[-1]*n for _ in range(n)]",
      "mutated_line": "paths = [[-0] * n for _ in range(n)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-0] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "paths = [[-1]*n for _ in range(n)]",
      "mutated_line": "paths = [[--1] * n for _ in range(n)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[--1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][1], 1, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][1], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][-1], 1, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][-1], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[0][1], 1, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][1], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "newx, newy = x + dx, y + dy",
      "mutated_line": "(newx, newy) = (x - dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x - dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "newx, newy = x + dx, y + dy",
      "mutated_line": "(newx, newy) = (x * dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x * dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "newx, newy = x + dx, y + dy",
      "mutated_line": "(newx, newy) = (x + dx, y - dy)",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y - dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "newx, newy = x + dx, y + dy",
      "mutated_line": "(newx, newy) = (x + dx, y * dy)",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y * dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 < newx < n and 0 <= newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 < newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 > newx < n and 0 <= newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 > newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 == newx < n and 0 <= newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 == newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n and 0 < newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 < newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n and 0 > newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 > newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n and 0 == newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 == newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n and 0 <= newy < n and (steps <= k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps <= k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n and 0 <= newy < n and (steps >= k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps >= k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n and 0 <= newy < n and (steps != k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps != k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[1][0], 1, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[1][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[-1][0], 1, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[-1][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(-grid[0][0], 1, 0, 0)]",
      "mutated_line": "heap = [(-grid[1][0], 1, 0, 0)]",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[1][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 1 <= newx < n and 0 <= newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 1 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if -1 <= newx < n and 0 <= newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if -1 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 1 <= newx < n and 0 <= newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 1 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n and 1 <= newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 1 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n and -1 <= newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and -1 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if 0 <= newx < n and 0 <= newy < n and steps < k:",
      "mutated_line": "if 0 <= newx < n and 1 <= newy < n and (steps < k):",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 1 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))",
      "mutated_line": "heapq.heappush(heap, (sum_so_far + grid[newy][newx], steps + 1, newy, newx))",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far + grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))",
      "mutated_line": "heapq.heappush(heap, (sum_so_far * grid[newy][newx], steps + 1, newy, newx))",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far * grid[newy][newx], steps + 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))",
      "mutated_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps - 1, newy, newx))",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps - 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))",
      "mutated_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps * 1, newy, newx))",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps * 1, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))",
      "mutated_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 2, newy, newx))",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 2, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))",
      "mutated_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 0, newy, newx))",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 0, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))",
      "mutated_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 0, newy, newx))",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 0, newy, newx))\n    return max(map(max, paths)) * -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + 1, newy, newx))",
      "mutated_line": "heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + -1, newy, newx))",
      "code": "def maxSumPath(grid, k):\n    import heapq\n    n = len(grid)\n    paths = [[-1] * n for _ in range(n)]\n    heap = [(-grid[0][0], 1, 0, 0)]\n    while heap:\n        (sum_so_far, steps, y, x) = heapq.heappop(heap)\n        if steps > paths[y][x]:\n            paths[y][x] = steps\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < n and 0 <= newy < n and (steps < k):\n                    heapq.heappush(heap, (sum_so_far - grid[newy][newx], steps + -1, newy, newx))\n    return max(map(max, paths)) * -1"
    }
  ]
}