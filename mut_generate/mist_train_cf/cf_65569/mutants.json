{
  "task_id": "cf_65569",
  "entry_point": "numberOfSubarrays",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 1\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = -1\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 1\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % 2 != 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 != 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(odd_indices) == k:",
      "mutated_line": "if len(odd_indices) != k:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) != k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] * 2 == 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] * 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] + 2 == 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] + 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % 2 == 2:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 2:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % 2 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 0:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % 2 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 0:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % 2 == -1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == -1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "left_count = 1",
      "mutated_line": "left_count = 2",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 2\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "left_count = 1",
      "mutated_line": "left_count = 0",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 0\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "left_count = 1",
      "mutated_line": "left_count = 0",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 0\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "left_count = 1",
      "mutated_line": "left_count = -1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = -1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(odd_indices) > 1:",
      "mutated_line": "if len(odd_indices) >= 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) >= 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(odd_indices) > 1:",
      "mutated_line": "if len(odd_indices) <= 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) <= 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(odd_indices) > 1:",
      "mutated_line": "if len(odd_indices) != 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) != 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n or nums[start] % 2 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n or nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "start += 1",
      "mutated_line": "start -= 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start -= 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "right_count = start - i",
      "mutated_line": "right_count = start + i",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start + i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "right_count = start - i",
      "mutated_line": "right_count = start * i",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start * i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 or len(subarray) <= 2 * k or sum_squares_subarray % k == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 or len(subarray) <= 2 * k or sum_squares_subarray % k == 0:\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "count += left_count * right_count",
      "mutated_line": "count -= left_count * right_count",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count -= left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % 3 == 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 3 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % 1 == 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 1 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % 0 == 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 0 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % 1 == 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 1 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if nums[i] % 2 == 1:",
      "mutated_line": "if nums[i] % -2 == 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % -2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(odd_indices) > 1:",
      "mutated_line": "if len(odd_indices) > 2:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 2:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(odd_indices) > 1:",
      "mutated_line": "if len(odd_indices) > 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 0:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(odd_indices) > 1:",
      "mutated_line": "if len(odd_indices) > 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 0:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(odd_indices) > 1:",
      "mutated_line": "if len(odd_indices) > -1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > -1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd - odd_indices[0] - 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] - 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = (previous_odd - odd_indices[0]) * 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = (previous_odd - odd_indices[0]) * 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start <= n and nums[start] % 2 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start <= n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start >= n and nums[start] % 2 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start >= n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start != n and nums[start] % 2 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start != n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] % 2 != 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 != 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "start += 1",
      "mutated_line": "start += 2",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 2\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "start += 1",
      "mutated_line": "start += 0",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 0\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "start += 1",
      "mutated_line": "start += 0",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 0\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "start += 1",
      "mutated_line": "start += -1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += -1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k != 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k != 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) < 2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) < 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) > 2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) > 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) == 2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) == 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k != 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k != 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "count += left_count * right_count",
      "mutated_line": "count += left_count / right_count",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count / right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "count += left_count * right_count",
      "mutated_line": "count += left_count + right_count",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count + right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "count += left_count * right_count",
      "mutated_line": "count += left_count ** right_count",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count ** right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd + odd_indices[0] + 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd + odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd * odd_indices[0] + 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd * odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd - odd_indices[0] + 2",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 2\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd - odd_indices[0] + 0",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 0\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd - odd_indices[0] + 0",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 0\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd - odd_indices[0] + -1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + -1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] * 2 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] * 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] + 2 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] + 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] % 2 == 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 1:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] % 2 == -1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == -1:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] % 2 == 1:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 1:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "subarray = nums[odd_indices[0]:start + 1]",
      "mutated_line": "subarray = nums[odd_indices[0]:start - 1]",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start - 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "subarray = nums[odd_indices[0]:start + 1]",
      "mutated_line": "subarray = nums[odd_indices[0]:start * 1]",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start * 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sum_squares_subarray = sum([num * num for num in subarray])",
      "mutated_line": "sum_squares_subarray = sum([num / num for num in subarray])",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num / num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sum_squares_subarray = sum([num * num for num in subarray])",
      "mutated_line": "sum_squares_subarray = sum([num + num for num in subarray])",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num + num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sum_squares_subarray = sum([num * num for num in subarray])",
      "mutated_line": "sum_squares_subarray = sum([num ** num for num in subarray])",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num ** num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray * k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray * k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray + k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray + k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 1 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 1 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == -1 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == -1 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 1 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 1 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 2 / k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 / k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 2 + k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 + k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 2 ** k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 ** k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray * k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray * k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray + k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray + k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 1):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 1):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == -1):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == -1):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 1):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 1):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] % 3 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 3 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] % 1 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 1 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] % 0 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 0 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] % 1 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 1 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while start < n and nums[start] % 2 == 0:",
      "mutated_line": "while start < n and nums[start] % -2 == 0:",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % -2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "subarray = nums[odd_indices[0]:start + 1]",
      "mutated_line": "subarray = nums[odd_indices[1]:start + 1]",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[1]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "subarray = nums[odd_indices[0]:start + 1]",
      "mutated_line": "subarray = nums[odd_indices[-1]:start + 1]",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[-1]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "subarray = nums[odd_indices[0]:start + 1]",
      "mutated_line": "subarray = nums[odd_indices[1]:start + 1]",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[1]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "subarray = nums[odd_indices[0]:start + 1]",
      "mutated_line": "subarray = nums[odd_indices[0]:start + 2]",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 2]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "subarray = nums[odd_indices[0]:start + 1]",
      "mutated_line": "subarray = nums[odd_indices[0]:start + 0]",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 0]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "subarray = nums[odd_indices[0]:start + 1]",
      "mutated_line": "subarray = nums[odd_indices[0]:start + 0]",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 0]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "subarray = nums[odd_indices[0]:start + 1]",
      "mutated_line": "subarray = nums[odd_indices[0]:start + -1]",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + -1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 3 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 3 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 1 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 1 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 0 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 0 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= 1 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 1 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_subarray % k == 0 and len(subarray) <= 2 * k and sum_squares_subarray % k == 0:",
      "mutated_line": "if sum_subarray % k == 0 and len(subarray) <= -2 * k and (sum_squares_subarray % k == 0):",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[0] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= -2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd - odd_indices[1] + 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[1] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd - odd_indices[-1] + 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[-1] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "left_count = previous_odd - odd_indices[0] + 1",
      "mutated_line": "left_count = previous_odd - odd_indices[1] + 1",
      "code": "from collections import deque\n\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    odd_indices = deque()\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 1:\n            odd_indices.append(i)\n        if len(odd_indices) == k:\n            start = i\n            left_count = 1\n            if len(odd_indices) > 1:\n                previous_odd = odd_indices.popleft()\n                left_count = previous_odd - odd_indices[1] + 1\n            while start < n and nums[start] % 2 == 0:\n                start += 1\n            right_count = start - i\n            subarray = nums[odd_indices[0]:start + 1]\n            sum_subarray = sum(subarray)\n            sum_squares_subarray = sum([num * num for num in subarray])\n            if sum_subarray % k == 0 and len(subarray) <= 2 * k and (sum_squares_subarray % k == 0):\n                count += left_count * right_count\n    return count"
    }
  ]
}