{
  "task_id": "cf_42208",
  "entry_point": "decode_message",
  "mutant_count": 36,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if unique_mark is None:",
      "mutated_line": "return 'No unique mark found in the encoded message'",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is not None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if encoded_message.count(char) == 1:",
      "mutated_line": "if encoded_message.count(char) != 1:",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) != 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return \"No unique mark found in the encoded message\"",
      "mutated_line": "return ''",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return ''\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index - 2, len(encoded_message) - 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index - 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index * 2, len(encoded_message) - 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index * 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) + 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) + 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) * 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) * 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index + 3, 0)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index + 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index * 3, 0)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index * 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index - 3, 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 1)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index - 3, -1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, -1)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index - 3, 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 1)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if encoded_message.count(char) == 1:",
      "mutated_line": "if encoded_message.count(char) == 2:",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 2:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if encoded_message.count(char) == 1:",
      "mutated_line": "if encoded_message.count(char) == 0:",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 0:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if encoded_message.count(char) == 1:",
      "mutated_line": "if encoded_message.count(char) == 0:",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 0:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if encoded_message.count(char) == 1:",
      "mutated_line": "if encoded_message.count(char) == -1:",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == -1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 3, len(encoded_message) - 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 3, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 1, len(encoded_message) - 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 1, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 0, len(encoded_message) - 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 0, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 1, len(encoded_message) - 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 1, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + -2, len(encoded_message) - 1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + -2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 2)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 2)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 0)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 0)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 0)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 0)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)",
      "mutated_line": "forward_index = min(unique_mark_index + 2, len(encoded_message) - -1)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - -1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index - 4, 0)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 4, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index - 2, 0)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 2, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index - 0, 0)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 0, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index - 1, 0)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 1, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "backward_index = max(unique_mark_index - 3, 0)",
      "mutated_line": "backward_index = max(unique_mark_index - -3, 0)",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - -3, 0)\n    return encoded_message[backward_index:forward_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return encoded_message[backward_index:forward_index+1]",
      "mutated_line": "return encoded_message[backward_index:forward_index - 1]",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return encoded_message[backward_index:forward_index+1]",
      "mutated_line": "return encoded_message[backward_index:forward_index * 1]",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index * 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return encoded_message[backward_index:forward_index+1]",
      "mutated_line": "return encoded_message[backward_index:forward_index + 2]",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 2]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return encoded_message[backward_index:forward_index+1]",
      "mutated_line": "return encoded_message[backward_index:forward_index + 0]",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return encoded_message[backward_index:forward_index+1]",
      "mutated_line": "return encoded_message[backward_index:forward_index + 0]",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return encoded_message[backward_index:forward_index+1]",
      "mutated_line": "return encoded_message[backward_index:forward_index + -1]",
      "code": "def decode_message(encoded_message: str) -> str:\n    unique_mark = None\n    for char in encoded_message:\n        if encoded_message.count(char) == 1:\n            unique_mark = char\n            break\n    if unique_mark is None:\n        return 'No unique mark found in the encoded message'\n    unique_mark_index = encoded_message.index(unique_mark)\n    forward_index = min(unique_mark_index + 2, len(encoded_message) - 1)\n    backward_index = max(unique_mark_index - 3, 0)\n    return encoded_message[backward_index:forward_index + -1]"
    }
  ]
}