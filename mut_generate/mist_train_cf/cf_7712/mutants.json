{
  "task_id": "cf_7712",
  "entry_point": "find_combinations",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(combination) == 4:",
      "mutated_line": "if len(combination) != 4:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) != 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "backtrack([], 0, target)",
      "mutated_line": "return result",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 1, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "backtrack([], 0, target)",
      "mutated_line": "return result",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], -1, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "backtrack([], 0, target)",
      "mutated_line": "return result",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 1, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(combination) == 4:",
      "mutated_line": "if len(combination) == 5:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 5:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(combination) == 4:",
      "mutated_line": "if len(combination) == 3:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 3:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(combination) == 4:",
      "mutated_line": "if len(combination) == 0:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 0:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(combination) == 4:",
      "mutated_line": "if len(combination) == 1:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 1:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(combination) == 4:",
      "mutated_line": "if len(combination) == -4:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == -4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if sum(combination) == target:",
      "mutated_line": "if sum(combination) != target:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) != target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start_index or nums[i] == nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index or nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i >= start_index and nums[i] == nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i >= start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i <= start_index and nums[i] == nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i <= start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i != start_index and nums[i] == nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i != start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start_index and nums[i] != nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] != nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "backtrack(combination, i+1, target - nums[i])",
      "mutated_line": "backtrack(combination, i - 1, target - nums[i])",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i - 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "backtrack(combination, i+1, target - nums[i])",
      "mutated_line": "backtrack(combination, i * 1, target - nums[i])",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i * 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "backtrack(combination, i+1, target - nums[i])",
      "mutated_line": "backtrack(combination, i + 1, target + nums[i])",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target + nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "backtrack(combination, i+1, target - nums[i])",
      "mutated_line": "backtrack(combination, i + 1, target * nums[i])",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target * nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "backtrack(combination, i+1, target - nums[i])",
      "mutated_line": "backtrack(combination, i + 2, target - nums[i])",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 2, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "backtrack(combination, i+1, target - nums[i])",
      "mutated_line": "backtrack(combination, i + 0, target - nums[i])",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 0, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "backtrack(combination, i+1, target - nums[i])",
      "mutated_line": "backtrack(combination, i + 0, target - nums[i])",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 0, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "backtrack(combination, i+1, target - nums[i])",
      "mutated_line": "backtrack(combination, i + -1, target - nums[i])",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + -1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start_index and nums[i] == nums[i + 1]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i + 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start_index and nums[i] == nums[i * 1]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i * 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start_index and nums[i] == nums[i - 2]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 2]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start_index and nums[i] == nums[i - 0]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 0]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start_index and nums[i] == nums[i - 0]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - 0]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i > start_index and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start_index and nums[i] == nums[i - -1]:",
      "code": "def find_combinations(nums, target):\n    nums.sort()\n    result = []\n\n    def backtrack(combination, start_index, target):\n        if len(combination) == 4:\n            if sum(combination) == target:\n                result.append(combination[:])\n            return\n        for i in range(start_index, len(nums)):\n            if i > start_index and nums[i] == nums[i - -1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, i + 1, target - nums[i])\n            combination.pop()\n    backtrack([], 0, target)\n    return result"
    }
  ]
}