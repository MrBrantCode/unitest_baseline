{
  "task_id": "cf_74983",
  "entry_point": "min_operations_to_target",
  "mutant_count": 50,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if current == target:",
      "mutated_line": "if current != target:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current != target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "visited = set([0])",
      "mutated_line": "visited = set([1])",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([1])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "visited = set([0])",
      "mutated_line": "visited = set([-1])",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([-1])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "visited = set([0])",
      "mutated_line": "visited = set([1])",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([1])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current - 1, current - 1, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current - 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current * 1, current - 1, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current * 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current + 1, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current + 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current * 1, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current * 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current / 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current / 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current + 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current + 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current ** 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current ** 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 2, current / 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current / 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 2, current * 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current * 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if next_num not in visited:",
      "mutated_line": "if next_num in visited:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue = deque([(0, 0)])",
      "mutated_line": "queue = deque([(1, 0)])",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(1, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue = deque([(0, 0)])",
      "mutated_line": "queue = deque([(-1, 0)])",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(-1, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue = deque([(0, 0)])",
      "mutated_line": "queue = deque([(1, 0)])",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(1, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue = deque([(0, 0)])",
      "mutated_line": "queue = deque([(0, 1)])",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 1)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue = deque([(0, 0)])",
      "mutated_line": "queue = deque([(0, -1)])",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, -1)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue = deque([(0, 0)])",
      "mutated_line": "queue = deque([(0, 1)])",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 1)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 2, current - 1, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 2, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 0, current - 1, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 0, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 0, current - 1, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 0, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + -1, current - 1, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + -1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 2, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 2, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 0, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 0, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 0, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 0, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - -1, current * 2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - -1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 3, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 3, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 1, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 1, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 0, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 0, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 1, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 1, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * -2, current // 2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * -2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 2, current // 3]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 3]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 2, current // 1]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 1]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 2, current // 0]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 0]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 2, current // 1]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 1]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for next_num in [current + 1, current - 1, current * 2, current // 2]:",
      "mutated_line": "for next_num in [current + 1, current - 1, current * 2, current // -2]:",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // -2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "queue.append((next_num, steps + 1))",
      "mutated_line": "queue.append((next_num, steps - 1))",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps - 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "queue.append((next_num, steps + 1))",
      "mutated_line": "queue.append((next_num, steps * 1))",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps * 1))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue.append((next_num, steps + 1))",
      "mutated_line": "queue.append((next_num, steps + 2))",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 2))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue.append((next_num, steps + 1))",
      "mutated_line": "queue.append((next_num, steps + 0))",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 0))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue.append((next_num, steps + 1))",
      "mutated_line": "queue.append((next_num, steps + 0))",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + 0))\n                visited.add(next_num)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue.append((next_num, steps + 1))",
      "mutated_line": "queue.append((next_num, steps + -1))",
      "code": "from collections import deque\n\ndef min_operations_to_target(target):\n    \"\"\"\n    This function calculates the least number of steps needed to reach a target number \n    starting from 0 using the arithmetic operations addition, subtraction, multiplication, \n    and division. The division operation performs integer division, discarding the decimal part.\n\n    Args:\n    target (int): The target number to be reached.\n\n    Returns:\n    int: The minimum number of operations required to reach the target.\n    \"\"\"\n    queue = deque([(0, 0)])\n    visited = set([0])\n    while queue:\n        (current, steps) = queue.popleft()\n        if current == target:\n            return steps\n        for next_num in [current + 1, current - 1, current * 2, current // 2]:\n            if next_num not in visited:\n                queue.append((next_num, steps + -1))\n                visited.add(next_num)\n    return -1"
    }
  ]
}