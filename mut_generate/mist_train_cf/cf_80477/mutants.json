{
  "task_id": "cf_80477",
  "entry_point": "is_palindrome",
  "mutant_count": 39,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\"\"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(cleaned_input) <= 1:",
      "mutated_line": "if len(cleaned_input) < 1:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) < 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(cleaned_input) <= 1:",
      "mutated_line": "if len(cleaned_input) > 1:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) > 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(cleaned_input) <= 1:",
      "mutated_line": "if len(cleaned_input) == 1:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) == 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if cleaned_input[0] != cleaned_input[-1]:",
      "mutated_line": "if cleaned_input[0] == cleaned_input[-1]:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] == cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "\"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"\"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ''",
      "mutated_line": "return 'MUTATED'",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return 'MUTATED'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(cleaned_input) <= 1:",
      "mutated_line": "if len(cleaned_input) <= 2:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 2:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(cleaned_input) <= 1:",
      "mutated_line": "if len(cleaned_input) <= 0:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 0:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(cleaned_input) <= 1:",
      "mutated_line": "if len(cleaned_input) <= 0:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 0:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(cleaned_input) <= 1:",
      "mutated_line": "if len(cleaned_input) <= -1:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= -1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return False\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return True\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if cleaned_input[0] != cleaned_input[-1]:",
      "mutated_line": "if cleaned_input[1] != cleaned_input[-1]:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[1] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if cleaned_input[0] != cleaned_input[-1]:",
      "mutated_line": "if cleaned_input[-1] != cleaned_input[-1]:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[-1] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if cleaned_input[0] != cleaned_input[-1]:",
      "mutated_line": "if cleaned_input[1] != cleaned_input[-1]:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[1] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "if cleaned_input[0] != cleaned_input[-1]:",
      "mutated_line": "if cleaned_input[0] != cleaned_input[+1]:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[+1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return cleaned_input + cleaned_input[:i][::-1]",
      "mutated_line": "return cleaned_input - cleaned_input[:i][::-1]",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input - cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return cleaned_input + cleaned_input[:i][::-1]",
      "mutated_line": "return cleaned_input * cleaned_input[:i][::-1]",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input * cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if cleaned_input[0] != cleaned_input[-1]:",
      "mutated_line": "if cleaned_input[0] != cleaned_input[-2]:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-2]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if cleaned_input[0] != cleaned_input[-1]:",
      "mutated_line": "if cleaned_input[0] != cleaned_input[-0]:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-0]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if cleaned_input[0] != cleaned_input[-1]:",
      "mutated_line": "if cleaned_input[0] != cleaned_input[-0]:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-0]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if cleaned_input[0] != cleaned_input[-1]:",
      "mutated_line": "if cleaned_input[0] != cleaned_input[--1]:",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[--1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(cleaned_input[1:-1])",
      "mutated_line": "return is_palindrome(cleaned_input[2:-1])",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[2:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(cleaned_input[1:-1])",
      "mutated_line": "return is_palindrome(cleaned_input[0:-1])",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[0:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(cleaned_input[1:-1])",
      "mutated_line": "return is_palindrome(cleaned_input[0:-1])",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[0:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(cleaned_input[1:-1])",
      "mutated_line": "return is_palindrome(cleaned_input[-1:-1])",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[-1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "return is_palindrome(cleaned_input[1:-1])",
      "mutated_line": "return is_palindrome(cleaned_input[1:+1])",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:+1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cleaned_input = ''.join(ch for ch in string if ch.isalnum()).lower()",
      "mutated_line": "cleaned_input = 'MUTATED'.join((ch for ch in string if ch.isalnum())).lower()",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = 'MUTATED'.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(cleaned_input[1:-1])",
      "mutated_line": "return is_palindrome(cleaned_input[1:-2])",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-2])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(cleaned_input[1:-1])",
      "mutated_line": "return is_palindrome(cleaned_input[1:-0])",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-0])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(cleaned_input[1:-1])",
      "mutated_line": "return is_palindrome(cleaned_input[1:-0])",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-0])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return is_palindrome(cleaned_input[1:-1])",
      "mutated_line": "return is_palindrome(cleaned_input[1:--1])",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:--1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "cleaned_input = ''.join(ch for ch in string if ch.isalnum()).lower()",
      "mutated_line": "cleaned_input = 'MUTATED'.join((ch for ch in string if ch.isalnum())).lower()",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = 'MUTATED'.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-1]\n    return ''"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return cleaned_input + cleaned_input[:i][::-1]",
      "mutated_line": "return cleaned_input + cleaned_input[:i][::+1]",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::+1]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return cleaned_input + cleaned_input[:i][::-1]",
      "mutated_line": "return cleaned_input + cleaned_input[:i][::-2]",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-2]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return cleaned_input + cleaned_input[:i][::-1]",
      "mutated_line": "return cleaned_input + cleaned_input[:i][::-0]",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-0]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return cleaned_input + cleaned_input[:i][::-1]",
      "mutated_line": "return cleaned_input + cleaned_input[:i][::-0]",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::-0]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return cleaned_input + cleaned_input[:i][::-1]",
      "mutated_line": "return cleaned_input + cleaned_input[:i][::--1]",
      "code": "def is_palindrome(string: str) -> bool:\n    \"\"\" A recursive function checking if a given string is a palindrome by considering spaces among words and disregarding case and non-alphanumeric characters \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    if len(cleaned_input) <= 1:\n        return True\n    if cleaned_input[0] != cleaned_input[-1]:\n        return False\n    return is_palindrome(cleaned_input[1:-1])\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Build the shortest palindrome beginning with the given string within O(n) time complexity, considering spaces between words, and ignoring case and non-alphanumeric characters.\n    - Discern the longest postfix of the supplied string which forms a palindrome.\n    - Join to the string's end, the reverse of the string prefix identified before the palindromic suffix.\n    \"\"\"\n    cleaned_input = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(cleaned_input)):\n        if is_palindrome(cleaned_input[i:]):\n            return cleaned_input + cleaned_input[:i][::--1]\n    return ''"
    }
  ]
}