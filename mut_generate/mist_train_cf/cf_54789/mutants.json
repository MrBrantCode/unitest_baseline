{
  "task_id": "cf_54789",
  "entry_point": "median",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 or new_element > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 or new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(min_heap) > len(max_heap):",
      "mutated_line": "if len(min_heap) >= len(max_heap):",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) >= len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(min_heap) > len(max_heap):",
      "mutated_line": "if len(min_heap) <= len(max_heap):",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) <= len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(min_heap) > len(max_heap):",
      "mutated_line": "if len(min_heap) != len(max_heap):",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) != len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(min_heap) == len(max_heap):",
      "mutated_line": "if len(min_heap) != len(max_heap):",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) != len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 or num > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 or num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(min_heap) > len(max_heap):",
      "mutated_line": "if len(min_heap) >= len(max_heap):",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) >= len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(min_heap) > len(max_heap):",
      "mutated_line": "if len(min_heap) <= len(max_heap):",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) <= len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(min_heap) > len(max_heap):",
      "mutated_line": "if len(min_heap) != len(max_heap):",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) != len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) >= 0 and new_element > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) >= 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) <= 0 and new_element > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) <= 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) != 0 and new_element > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) != 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and new_element >= -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element >= -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and new_element <= -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element <= -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and new_element != -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element != -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) >= len(min_heap) + 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) >= len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) <= len(min_heap) + 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) <= len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) != len(min_heap) + 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) != len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) * 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) * 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) // 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) // 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return +max_heap[0]",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return +max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) >= 0 and num > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) >= 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) <= 0 and num > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) <= 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) != 0 and num > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) != 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and num >= -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num >= -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and num <= -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num <= -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and num != -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num != -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) >= len(min_heap) + 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) >= len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) <= len(min_heap) + 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) <= len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) != len(min_heap) + 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) != len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 1 and new_element > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 1 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > -1 and new_element > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > -1 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 1 and new_element > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 1 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and new_element > +max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > +max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "heapq.heappush(max_heap, -new_element)",
      "mutated_line": "heapq.heappush(max_heap, +new_element)",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, +new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "heapq.heappush(max_heap, -heapq.heappop(min_heap))",
      "mutated_line": "heapq.heappush(max_heap, +heapq.heappop(min_heap))",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, +heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) - 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) - 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) * 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) * 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] - min_heap[0]) / 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] - min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return -max_heap[0] * min_heap[0] / 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return -max_heap[0] * min_heap[0] / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 3.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 3.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 1.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 1.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 1",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 1\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / -2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / -2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 1 and num > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 1 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > -1 and num > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > -1 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 1 and num > -max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 1 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and num > +max_heap[0]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > +max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "heapq.heappush(max_heap, -num)",
      "mutated_line": "heapq.heappush(max_heap, +num)",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, +num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "heapq.heappush(max_heap, -heapq.heappop(min_heap))",
      "mutated_line": "heapq.heappush(max_heap, +heapq.heappop(min_heap))",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, +heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) - 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) - 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) * 1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) * 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + 2:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 2:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 0:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 0:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + -1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + -1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "heapq.heappush(min_heap, -heapq.heappop(max_heap))",
      "mutated_line": "heapq.heappush(min_heap, +heapq.heappop(max_heap))",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, +heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (+max_heap[0] + min_heap[0]) / 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (+max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return -max_heap[1]",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return -max_heap[-1]",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return -max_heap[1]",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + 2:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 2:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 0:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 0:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + -1:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + -1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, -heapq.heappop(max_heap))",
      "mutated_line": "heapq.heappush(min_heap, +heapq.heappop(max_heap))",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, +heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and new_element > -max_heap[1]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[1]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and new_element > -max_heap[-1]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[-1]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(max_heap) > 0 and new_element > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and new_element > -max_heap[1]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[1]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[1]) / 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[1]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[-1]) / 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[-1]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[0] + min_heap[1]) / 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[1]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and num > -max_heap[1]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[1]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and num > -max_heap[-1]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[-1]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(max_heap) > 0 and num > -max_heap[0]:",
      "mutated_line": "if len(max_heap) > 0 and num > -max_heap[1]:",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[1]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[0] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[1] + min_heap[0]) / 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[1] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[-1] + min_heap[0]) / 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[-1] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2.0",
      "mutated_line": "return (-max_heap[1] + min_heap[0]) / 2.0",
      "code": "import heapq\n\ndef median(my_list, new_element):\n    max_heap = []\n    min_heap = []\n    for num in my_list:\n        if len(max_heap) > 0 and num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(max_heap) > 0 and new_element > -max_heap[0]:\n        heapq.heappush(min_heap, new_element)\n    else:\n        heapq.heappush(max_heap, -new_element)\n    if len(min_heap) > len(max_heap):\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    elif len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap))\n    if len(min_heap) == len(max_heap):\n        return (-max_heap[1] + min_heap[0]) / 2.0\n    else:\n        return -max_heap[0]"
    }
  ]
}