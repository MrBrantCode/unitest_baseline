{
  "task_id": "cf_22976",
  "entry_point": "knapsack",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def knapsack(items, capacity):\n    \"\"\"\"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp[i][w] != -1:",
      "mutated_line": "if dp[i][w] == -1:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] == -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if i == 0 or w == 0:",
      "mutated_line": "if i == 0 and w == 0:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 and w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[+1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[+1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "if dp[i][w] != -1:",
      "mutated_line": "if dp[i][w] != +1:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != +1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i == 0 or w == 0:",
      "mutated_line": "if i != 0 or w == 0:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i != 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i == 0 or w == 0:",
      "mutated_line": "if i == 0 or w != 0:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w != 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "result = 0",
      "mutated_line": "result = 0",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 1\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "result = 0",
      "mutated_line": "result = 0",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = -1\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "result = 0",
      "mutated_line": "result = 0",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 1\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - 1][0] >= w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] >= w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - 1][0] <= w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] <= w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - 1][0] != w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] != w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-2 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-2 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-0 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-0 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[--1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[--1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n - 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n - 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n * 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n * 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp[i][w] != -1:",
      "mutated_line": "if dp[i][w] != -2:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -2:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp[i][w] != -1:",
      "mutated_line": "if dp[i][w] != -0:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -0:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp[i][w] != -1:",
      "mutated_line": "if dp[i][w] != -0:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -0:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp[i][w] != -1:",
      "mutated_line": "if dp[i][w] != --1:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != --1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i == 0 or w == 0:",
      "mutated_line": "if i == 1 or w == 0:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 1 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i == 0 or w == 0:",
      "mutated_line": "if i == -1 or w == 0:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == -1 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i == 0 or w == 0:",
      "mutated_line": "if i == 1 or w == 0:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 1 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i == 0 or w == 0:",
      "mutated_line": "if i == 0 or w == 1:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 1:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i == 0 or w == 0:",
      "mutated_line": "if i == 0 or w == -1:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == -1:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i == 0 or w == 0:",
      "mutated_line": "if i == 0 or w == 1:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 1:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 1\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result = 0",
      "mutated_line": "result = -1",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = -1\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 1\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] - knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] * knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity - 1)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity - 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity * 1)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity * 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 2)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 2)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 0)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 0)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 0)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 0)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + -1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + -1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - 1][1] > w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][1] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - 1][-1] > w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][-1] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - 1][1] > w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][1] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "exclude_item = knapsackHelper(i-1, w)",
      "mutated_line": "exclude_item = knapsackHelper(i + 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i + 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "exclude_item = knapsackHelper(i-1, w)",
      "mutated_line": "exclude_item = knapsackHelper(i * 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i * 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + 2)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 2)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + 0)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 0)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + 0)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 0)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(capacity + -1)] for _ in range(n + 1)]",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + -1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i + 1][0] > w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i + 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i * 1][0] > w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i * 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][2] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][0] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][0] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][-1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i + 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i * 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w + items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w * items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "exclude_item = knapsackHelper(i-1, w)",
      "mutated_line": "exclude_item = knapsackHelper(i - 2, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 2, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "exclude_item = knapsackHelper(i-1, w)",
      "mutated_line": "exclude_item = knapsackHelper(i - 0, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 0, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "exclude_item = knapsackHelper(i-1, w)",
      "mutated_line": "exclude_item = knapsackHelper(i - 0, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 0, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "exclude_item = knapsackHelper(i-1, w)",
      "mutated_line": "exclude_item = knapsackHelper(i - -1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - -1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - 2][0] > w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 2][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - 0][0] > w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 0][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - 0][0] > w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 0][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif items[i-1][0] > w:",
      "mutated_line": "elif items[i - -1][0] > w:",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - -1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i + 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i * 1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 2, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 0, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 0, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - -1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 2][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 0][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 0][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - -1][1] + knapsackHelper(i - 1, w - items[i - 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][1])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][-1])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 1][1])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i + 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i * 1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 2][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 0][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - 0][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "include_item = items[i-1][1] + knapsackHelper(i-1, w-items[i-1][0])",
      "mutated_line": "exclude_item = knapsackHelper(i - 1, w)",
      "code": "def knapsack(items, capacity):\n    \"\"\"\n    This function implements the 0/1 Knapsack problem using the Bottom-Up Dynamic Programming approach with memoization.\n    \n    Parameters:\n    items (list): A list of items, where each item is a tuple of its weight and value.\n    capacity (int): The maximum weight capacity of the knapsack.\n    \n    Returns:\n    int: The maximum value that can be obtained without exceeding the weight capacity.\n    \"\"\"\n    n = len(items)\n    dp = [[-1 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    def knapsackHelper(i, w):\n        if dp[i][w] != -1:\n            return dp[i][w]\n        if i == 0 or w == 0:\n            result = 0\n        elif items[i - 1][0] > w:\n            result = 0\n        else:\n            include_item = items[i - 1][1] + knapsackHelper(i - 1, w - items[i - -1][0])\n            exclude_item = knapsackHelper(i - 1, w)\n            result = max(include_item, exclude_item)\n        dp[i][w] = result\n        return result\n    return knapsackHelper(n, capacity)"
    }
  ]
}