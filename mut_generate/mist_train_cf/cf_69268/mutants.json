{
  "task_id": "cf_69268",
  "entry_point": "longest_common_subsequence",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "max_length = -1",
      "mutated_line": "max_length = +1",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = +1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 0 and k < 1:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 and k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_length = -1",
      "mutated_line": "max_length = -2",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -2\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_length = -1",
      "mutated_line": "max_length = -0",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -0\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_length = -1",
      "mutated_line": "max_length = -0",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -0\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_length = -1",
      "mutated_line": "max_length = --1",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = --1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n != 0 or k < 1:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n != 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 0 or k <= 1:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k <= 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 0 or k >= 1:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k >= 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 0 or k != 1:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k != 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 1 or k < 1:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 1 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == -1 or k < 1:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == -1 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 1 or k < 1:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 1 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 0 or k < 2:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 2:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 0 or k < 0:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 0:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 0 or k < 0:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 0:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n == 0 or k < 1:",
      "mutated_line": "if n == 0 or k < -1:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < -1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i - 1, len(string) + 1):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i - 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i * 1, len(string) + 1):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i * 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + 1, len(string) - 1):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) - 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + 1, len(string) * 1):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) * 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if substring not in checked:",
      "mutated_line": "if substring in checked:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "common[substring] += 1",
      "mutated_line": "common[substring] -= 1",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] -= 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + 2, len(string) + 1):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 2, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + 0, len(string) + 1):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 0, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + 0, len(string) + 1):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 0, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + -1, len(string) + 1):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + -1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + 1, len(string) + 2):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 2):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + 1, len(string) + 0):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 0):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + 1, len(string) + 0):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 0):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, len(string) + 1):",
      "mutated_line": "for j in range(i + 1, len(string) + -1):",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + -1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "common[substring] += 1",
      "mutated_line": "common[substring] += 2",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 2\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "common[substring] += 1",
      "mutated_line": "common[substring] += 0",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 0\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "common[substring] += 1",
      "mutated_line": "common[substring] += 0",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 0\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "common[substring] += 1",
      "mutated_line": "common[substring] += -1",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += -1\n                        if common[substring] >= k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if common[substring] >= k:",
      "mutated_line": "if common[substring] > k:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] > k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if common[substring] >= k:",
      "mutated_line": "if common[substring] < k:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] < k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if common[substring] >= k:",
      "mutated_line": "if common[substring] == k:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] == k:\n                            if j - i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if j - i > max_length:",
      "mutated_line": "if j - i >= max_length:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i >= max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if j - i > max_length:",
      "mutated_line": "if j - i <= max_length:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i <= max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if j - i > max_length:",
      "mutated_line": "if j - i != max_length:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j - i != max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if j - i > max_length:",
      "mutated_line": "if j + i > max_length:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j + i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if j - i > max_length:",
      "mutated_line": "if j * i > max_length:",
      "code": "from typing import List, Optional\nfrom collections import defaultdict\n\ndef longest_common_subsequence(strings: List[str], k: int) -> Optional[str]:\n    \"\"\"\n    This function finds the longest shared subsequence string in a list of strings \n    that appears at least k times. If no such string exists or the list is empty, \n    it returns None. In case of a tie, it returns the first earliest occurring string.\n\n    Args:\n        strings (List[str]): A list of strings.\n        k (int): The minimum frequency of the subsequence.\n\n    Returns:\n        Optional[str]: The longest shared subsequence string or None.\n    \"\"\"\n    n = len(strings)\n    common = defaultdict(int)\n    longest_str = None\n    max_length = -1\n    if n == 0 or k < 1:\n        return None\n    else:\n        for string in strings:\n            checked = set()\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if substring not in checked:\n                        checked.add(substring)\n                        common[substring] += 1\n                        if common[substring] >= k:\n                            if j * i > max_length:\n                                longest_str = substring\n                                max_length = len(substring)\n    return longest_str"
    }
  ]
}