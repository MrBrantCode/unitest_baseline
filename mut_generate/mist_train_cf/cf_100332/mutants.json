{
  "task_id": "cf_100332",
  "entry_point": "find_median",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 != 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) != 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) != 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n * 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n + 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 2:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 0:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 0:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == -1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) * 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) * 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) // 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) // 2"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) == 2:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 2:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) == 0:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 0:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) == 0:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 0:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) == -1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == -1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if k < len(left):",
      "mutated_line": "if k <= len(left):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k <= len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if k < len(left):",
      "mutated_line": "if k >= len(left):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k >= len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if k < len(left):",
      "mutated_line": "if k != len(left):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k != len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 3 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 1 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 0 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 1 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % -2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return kth_smallest(values, n//2)",
      "mutated_line": "return kth_smallest(values, n / 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n / 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return kth_smallest(values, n//2)",
      "mutated_line": "return kth_smallest(values, n * 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n * 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) - kth_smallest(values, n // 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) - kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return kth_smallest(values, n // 2) * kth_smallest(values, n // 2 - 1) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return kth_smallest(values, n // 2) * kth_smallest(values, n // 2 - 1) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 3",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 1",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 0",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 1",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / -2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / -2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "values = [int(value.text) for value in root.findall('value')]",
      "mutated_line": "values = [int(value.text) for value in root.findall('')]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return arr[0]",
      "mutated_line": "return arr[1]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[1]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return arr[0]",
      "mutated_line": "return arr[-1]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[-1]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return arr[0]",
      "mutated_line": "return arr[1]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[1]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pivot = kth_smallest(medians, len(medians)//2)",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) / 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) / 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pivot = kth_smallest(medians, len(medians)//2)",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) * 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) * 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif k < len(arr) - len(right):",
      "mutated_line": "elif k <= len(arr) - len(right):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k <= len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif k < len(arr) - len(right):",
      "mutated_line": "elif k >= len(arr) - len(right):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k >= len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif k < len(arr) - len(right):",
      "mutated_line": "elif k != len(arr) - len(right):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k != len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return kth_smallest(values, n//2)",
      "mutated_line": "return kth_smallest(values, n // 3)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 3)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return kth_smallest(values, n//2)",
      "mutated_line": "return kth_smallest(values, n // 1)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 1)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return kth_smallest(values, n//2)",
      "mutated_line": "return kth_smallest(values, n // 0)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 0)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return kth_smallest(values, n//2)",
      "mutated_line": "return kth_smallest(values, n // 1)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 1)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return kth_smallest(values, n//2)",
      "mutated_line": "return kth_smallest(values, n // -2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // -2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "medians = [sorted(sublist)[len(sublist)//2] for sublist in sublists]",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) / 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "medians = [sorted(sublist)[len(sublist)//2] for sublist in sublists]",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) * 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pivot = kth_smallest(medians, len(medians)//2)",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 3)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 3)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pivot = kth_smallest(medians, len(medians)//2)",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 1)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 1)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pivot = kth_smallest(medians, len(medians)//2)",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 0)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 0)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pivot = kth_smallest(medians, len(medians)//2)",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 1)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 1)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pivot = kth_smallest(medians, len(medians)//2)",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // -2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // -2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "left = [elem for elem in arr if elem < pivot]",
      "mutated_line": "left = [elem for elem in arr if elem <= pivot]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem <= pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "left = [elem for elem in arr if elem < pivot]",
      "mutated_line": "left = [elem for elem in arr if elem >= pivot]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem >= pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "left = [elem for elem in arr if elem < pivot]",
      "mutated_line": "left = [elem for elem in arr if elem != pivot]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem != pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "right = [elem for elem in arr if elem > pivot]",
      "mutated_line": "right = [elem for elem in arr if elem >= pivot]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem >= pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "right = [elem for elem in arr if elem > pivot]",
      "mutated_line": "right = [elem for elem in arr if elem <= pivot]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem <= pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "right = [elem for elem in arr if elem > pivot]",
      "mutated_line": "right = [elem for elem in arr if elem != pivot]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem != pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif k < len(arr) - len(right):",
      "mutated_line": "elif k < len(arr) + len(right):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) + len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif k < len(arr) - len(right):",
      "mutated_line": "elif k < len(arr) * len(right):",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) * len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n / 2) + kth_smallest(values, n // 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n / 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n * 2) + kth_smallest(values, n // 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n * 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 + 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 + 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 * 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 * 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i - 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i * 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(1, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(-1, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(1, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 6)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 4)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 0)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 1)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), -5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "medians = [sorted(sublist)[len(sublist)//2] for sublist in sublists]",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 3] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "medians = [sorted(sublist)[len(sublist)//2] for sublist in sublists]",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 1] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "medians = [sorted(sublist)[len(sublist)//2] for sublist in sublists]",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 0] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "medians = [sorted(sublist)[len(sublist)//2] for sublist in sublists]",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 1] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "medians = [sorted(sublist)[len(sublist)//2] for sublist in sublists]",
      "mutated_line": "pivot = kth_smallest(medians, len(medians) // 2)",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // -2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return kth_smallest(right, k - (len(arr) - len(right)))",
      "mutated_line": "return kth_smallest(right, k + (len(arr) - len(right)))",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k + (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return kth_smallest(right, k - (len(arr) - len(right)))",
      "mutated_line": "return kth_smallest(right, k * (len(arr) - len(right)))",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k * (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 3) + kth_smallest(values, n // 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 3) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 1) + kth_smallest(values, n // 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 1) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 0) + kth_smallest(values, n // 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 0) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 1) + kth_smallest(values, n // 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 1) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // -2) + kth_smallest(values, n // 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // -2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n / 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n / 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n * 2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n * 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 2)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 2)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 0)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 0)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 0)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 0)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - -1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - -1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 6] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 4] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 0] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 1] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sublists = [arr[i:i+5] for i in range(0, len(arr), 5)]",
      "mutated_line": "medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + -5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return kth_smallest(right, k - (len(arr) - len(right)))",
      "mutated_line": "return kth_smallest(right, k - (len(arr) + len(right)))",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) + len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return kth_smallest(right, k - (len(arr) - len(right)))",
      "mutated_line": "return kth_smallest(right, k - len(arr) * len(right))",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - len(arr) * len(right))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 2 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 3 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 3 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 1 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 1 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 0 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 0 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // 1 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // 1 - 1)) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (kth_smallest(values, n//2) + kth_smallest(values, n//2 - 1)) / 2",
      "mutated_line": "return (kth_smallest(values, n // 2) + kth_smallest(values, n // -2 - 1)) / 2",
      "code": "import xml.etree.ElementTree as ET\n\ndef find_median(xml_data):\n    root = ET.fromstring(xml_data)\n    values = [int(value.text) for value in root.findall('value')]\n\n    def kth_smallest(arr, k):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            sublists = [arr[i:i + 5] for i in range(0, len(arr), 5)]\n            medians = [sorted(sublist)[len(sublist) // 2] for sublist in sublists]\n            pivot = kth_smallest(medians, len(medians) // 2)\n            left = [elem for elem in arr if elem < pivot]\n            right = [elem for elem in arr if elem > pivot]\n            if k < len(left):\n                return kth_smallest(left, k)\n            elif k < len(arr) - len(right):\n                return pivot\n            else:\n                return kth_smallest(right, k - (len(arr) - len(right)))\n    n = len(values)\n    if n % 2 == 1:\n        return kth_smallest(values, n // 2)\n    else:\n        return (kth_smallest(values, n // 2) + kth_smallest(values, n // -2 - 1)) / 2"
    }
  ]
}