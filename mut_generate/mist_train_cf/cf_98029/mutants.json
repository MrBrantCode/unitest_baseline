{
  "task_id": "cf_98029",
  "entry_point": "convert_to_decimal",
  "mutant_count": 107,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "EARTH_RADIUS = 6371  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017",
      "code": "import math\nEARTH_RADIUS = 6372\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "EARTH_RADIUS = 6371  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017",
      "code": "import math\nEARTH_RADIUS = 6370\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "EARTH_RADIUS = 6371  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017",
      "code": "import math\nEARTH_RADIUS = 0\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "EARTH_RADIUS = 6371  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017",
      "code": "import math\nEARTH_RADIUS = 1\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "EARTH_RADIUS = 6371  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017",
      "code": "import math\nEARTH_RADIUS = -6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = 40076.017",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40076.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = 40074.017",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40074.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = 0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 0\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = 1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 1\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "EQUATORIAL_CIRCUMFERENCE = 40075.017  # km",
      "mutated_line": "EQUATORIAL_CIRCUMFERENCE = -40075.017",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = -40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "DEG_TO_RAD = math.pi / 180.0",
      "mutated_line": "DEG_TO_RAD = math.pi * 180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi * 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "DEG_TO_RAD = math.pi / 180.0",
      "mutated_line": "DEG_TO_RAD = math.pi // 180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi // 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "RAD_TO_DEG = 180.0 / math.pi",
      "mutated_line": "RAD_TO_DEG = 180.0 * math.pi",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 * math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "RAD_TO_DEG = 180.0 / math.pi",
      "mutated_line": "RAD_TO_DEG = 180.0 // math.pi",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 // math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord /= math.pi * EARTH_RADIUS / 180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord /= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DEG_TO_RAD = math.pi / 180.0",
      "mutated_line": "DEG_TO_RAD = math.pi / 181.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 181.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DEG_TO_RAD = math.pi / 180.0",
      "mutated_line": "DEG_TO_RAD = math.pi / 179.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 179.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DEG_TO_RAD = math.pi / 180.0",
      "mutated_line": "DEG_TO_RAD = math.pi / 0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DEG_TO_RAD = math.pi / 180.0",
      "mutated_line": "DEG_TO_RAD = math.pi / 1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 1\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DEG_TO_RAD = math.pi / 180.0",
      "mutated_line": "DEG_TO_RAD = math.pi / -180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / -180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "RAD_TO_DEG = 180.0 / math.pi",
      "mutated_line": "RAD_TO_DEG = 181.0 / math.pi",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 181.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "RAD_TO_DEG = 180.0 / math.pi",
      "mutated_line": "RAD_TO_DEG = 179.0 / math.pi",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 179.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "RAD_TO_DEG = 180.0 / math.pi",
      "mutated_line": "RAD_TO_DEG = 0 / math.pi",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "RAD_TO_DEG = 180.0 / math.pi",
      "mutated_line": "RAD_TO_DEG = 1 / math.pi",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 1 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "RAD_TO_DEG = 180.0 / math.pi",
      "mutated_line": "RAD_TO_DEG = -180.0 / math.pi",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = -180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 60.0 - seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 - seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = (degrees + minutes / 60.0) * (seconds / 3600.0)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = (degrees + minutes / 60.0) * (seconds / 3600.0)\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if direction in ['N', 'S']:",
      "mutated_line": "if direction not in ['N', 'S']:",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction not in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= math.pi * EARTH_RADIUS * 180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS * 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= math.pi * EARTH_RADIUS // 180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS // 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees - minutes / 60.0 + seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees - minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees * (minutes / 60.0) + seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees * (minutes / 60.0) + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 60.0 + seconds * 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds * 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 60.0 + seconds // 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds // 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 1 if direction not in ['N', 'E'] else -1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction not in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 2 if direction in ['N', 'E'] else -1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 2 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 0 if direction in ['N', 'E'] else -1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 0 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 0 if direction in ['N', 'E'] else -1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 0 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = -1 if direction in ['N', 'E'] else -1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = -1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 1 if direction in ['N', 'E'] else +1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else +1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "circumference = EQUATORIAL_CIRCUMFERENCE / math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE / math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "circumference = EQUATORIAL_CIRCUMFERENCE + math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE + math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "circumference = EQUATORIAL_CIRCUMFERENCE ** math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE ** math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference * 360.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference * 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference // 360.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference // 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 / math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 / math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 + math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 + math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = (sign * decimal_degrees * circumference / 360.0) ** math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = (sign * decimal_degrees * circumference / 360.0) ** math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= math.pi / EARTH_RADIUS / 180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi / EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= (math.pi + EARTH_RADIUS) / 180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= (math.pi + EARTH_RADIUS) / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= math.pi ** EARTH_RADIUS / 180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi ** EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= math.pi * EARTH_RADIUS / 181.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 181.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= math.pi * EARTH_RADIUS / 179.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 179.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= math.pi * EARTH_RADIUS / 0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= math.pi * EARTH_RADIUS / 1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 1\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "decimal_coord *= math.pi * EARTH_RADIUS / 180.0",
      "mutated_line": "decimal_coord *= math.pi * EARTH_RADIUS / -180.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / -180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes * 60.0 + seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes * 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes // 60.0 + seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes // 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 60.0 + seconds / 3601.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3601.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 60.0 + seconds / 3599.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3599.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 60.0 + seconds / 0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 60.0 + seconds / 1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 1\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 60.0 + seconds / -3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / -3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 1 if direction in ['N', 'E'] else -2",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -2\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 1 if direction in ['N', 'E'] else -0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -0\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 1 if direction in ['N', 'E'] else -0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -0\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 1 if direction in ['N', 'E'] else --1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else --1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if direction in ['N', 'S']:",
      "mutated_line": "if direction in ['', 'S']:",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if direction in ['N', 'S']:",
      "mutated_line": "if direction in ['N', '']:",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', '']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign * decimal_degrees / circumference / 360.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees / circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = (sign * decimal_degrees + circumference) / 360.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = (sign * decimal_degrees + circumference) / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = (sign * decimal_degrees) ** circumference / 360.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = (sign * decimal_degrees) ** circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 361.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 361.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 359.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 359.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 1\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / -360.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / -360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference * 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference * 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference // 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference // 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 61.0 + seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 61.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 59.0 + seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 59.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 0 + seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / 1 + seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 1 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decimal_degrees = degrees + minutes/60.0 + seconds/3600.0",
      "mutated_line": "decimal_degrees = degrees + minutes / -60.0 + seconds / 3600.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / -60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 1 if direction in ['', 'E'] else -1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sign = 1 if direction in ['N', 'E'] else -1",
      "mutated_line": "sign = 1 if direction in ['N', ''] else -1",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', ''] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude / DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude / DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude + DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude + DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude ** DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude ** DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign / decimal_degrees * circumference / 360.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign / decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = (sign + decimal_degrees) * circumference / 360.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = (sign + decimal_degrees) * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0",
      "mutated_line": "decimal_coord = sign ** decimal_degrees * circumference / 360.0",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign ** decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees / circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees / circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = (sign * decimal_degrees + circumference) / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = (sign * decimal_degrees + circumference) / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = (sign * decimal_degrees) ** circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = (sign * decimal_degrees) ** circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 361.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 361.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 359.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 359.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 1 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 1 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / -360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / -360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude / DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude / DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude + DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude + DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude ** DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude ** DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign / decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign / decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = (sign + decimal_degrees) * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = (sign + decimal_degrees) * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "decimal_coord = sign * decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "mutated_line": "decimal_coord = sign ** decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)",
      "code": "import math\nEARTH_RADIUS = 6371\nEQUATORIAL_CIRCUMFERENCE = 40075.017\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\n\ndef convert_to_decimal(degrees, minutes, seconds, direction, observer_latitude):\n    \"\"\"\n    Converts coordinates in degrees, minutes, and seconds to decimal format\n    using the observer's position relative to the Equator and Prime Meridian.\n    \"\"\"\n    decimal_degrees = degrees + minutes / 60.0 + seconds / 3600.0\n    sign = 1 if direction in ['N', 'E'] else -1\n    if direction in ['N', 'S']:\n        circumference = EQUATORIAL_CIRCUMFERENCE * math.cos(observer_latitude * DEG_TO_RAD)\n        decimal_coord = sign * decimal_degrees * circumference / 360.0\n    else:\n        circumference = EQUATORIAL_CIRCUMFERENCE\n        decimal_coord = sign ** decimal_degrees * circumference / 360.0 * math.cos(observer_latitude * DEG_TO_RAD)\n    decimal_coord *= math.pi * EARTH_RADIUS / 180.0\n    return decimal_coord"
    }
  ]
}