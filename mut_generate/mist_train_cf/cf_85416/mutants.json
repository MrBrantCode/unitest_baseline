{
  "task_id": "cf_85416",
  "entry_point": "entrance",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "cur -= a",
      "mutated_line": "cur += a",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur += a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cur < m:",
      "mutated_line": "if cur <= m:",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur <= m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cur < m:",
      "mutated_line": "if cur >= m:",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur >= m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cur < m:",
      "mutated_line": "if cur != m:",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur != m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "res += m - cur",
      "mutated_line": "res -= m - cur",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res -= m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res += m - cur",
      "mutated_line": "res += m + cur",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m + cur\n            cur = m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res += m - cur",
      "mutated_line": "res += m * cur",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m * cur\n            cur = m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] + x[0], -x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] + x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] * x[0], -x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] * x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] - x[0], +x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], +x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[2] - x[0], -x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[2] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[0] - x[0], -x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[0] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[0] - x[0], -x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[0] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[-1] - x[0], -x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[-1] - x[0], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] - x[1], -x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[1], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] - x[-1], -x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[-1], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] - x[1], -x[1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[1], -x[1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] - x[0], -x[2]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[2]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] - x[0], -x[0]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[0]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] - x[0], -x[0]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[0]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tasks.sort(key=lambda x:(x[1]-x[0], -x[1]))",
      "mutated_line": "tasks.sort(key=lambda x: (x[1] - x[0], -x[-1]))",
      "code": "import heapq\n\ndef entrance(tasks):\n    tasks.sort(key=lambda x: (x[1] - x[0], -x[-1]))\n    res = cur = sum((a for (a, m) in tasks))\n    for (a, m) in tasks:\n        cur -= a\n        if cur < m:\n            res += m - cur\n            cur = m\n    return res"
    }
  ]
}