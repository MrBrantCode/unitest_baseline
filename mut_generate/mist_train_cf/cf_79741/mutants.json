{
  "task_id": "cf_79741",
  "entry_point": "shortest_path",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "return -1  # return -1 if no possible path",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if point == dest:",
      "mutated_line": "if point != dest:",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point != dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1  # return -1 if no possible path",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1  # return -1 if no possible path",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1  # return -1 if no possible path",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1  # return -1 if no possible path",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(1, -1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(1, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(-1, -1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(-1, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(1, -1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(1, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, +1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, +1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (1, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (1, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (-1, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (1, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (1, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 2), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 2), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 0), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 0), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 0), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 0), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, -1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (+1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (+1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 1), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 1), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, -1), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, -1), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 1), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 1), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (2, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (2, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (0, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (0, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (0, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (0, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (-1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 1)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 1)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, -1)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 1)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 1)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows or 0 <= next_point[1] < num_cols or maze[next_point[0]][next_point[1]] == 0 or (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows or 0 <= next_point[1] < num_cols or maze[next_point[0]][next_point[1]] == 0 or (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "num_rows, num_cols = len(maze), len(maze[0])",
      "mutated_line": "(num_rows, num_cols) = (len(maze), len(maze[1]))",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[1]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "num_rows, num_cols = len(maze), len(maze[0])",
      "mutated_line": "(num_rows, num_cols) = (len(maze), len(maze[-1]))",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[-1]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "num_rows, num_cols = len(maze), len(maze[0])",
      "mutated_line": "(num_rows, num_cols) = (len(maze), len(maze[1]))",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[1]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -2), (0, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -2), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -0), (0, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -0), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -0), (0, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -0), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, --1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, --1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-2, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-2, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-0, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-0, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-0, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-0, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (--1, 0), (1, 0)]",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (--1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue = deque([(src, 0)])",
      "mutated_line": "queue = deque([(src, 1)])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 1)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue = deque([(src, 0)])",
      "mutated_line": "queue = deque([(src, -1)])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, -1)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue = deque([(src, 0)])",
      "mutated_line": "queue = deque([(src, 1)])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 1)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] - direction[0], point[1] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] - direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] * direction[0], point[1] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] * direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[1] - direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] - direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[1] * direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] * direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 < next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 < next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 > next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 > next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 == next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 == next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 < next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 < next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 > next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 > next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 == next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 == next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] != 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] != 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 1 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 1 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if -1 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if -1 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 1 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 1 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 1 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 1 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and -1 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and -1 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 1 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 1 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 1) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 1) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == -1) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == -1) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 1) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 1) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[1] + direction[0], point[1] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[1] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[-1] + direction[0], point[1] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[-1] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[1] + direction[0], point[1] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[1] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[1], point[1] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[1], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[-1], point[1] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[-1], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[1], point[1] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[1], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[2] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[2] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[0] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[0] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[0] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[0] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[-1] + direction[1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[-1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[1] + direction[2])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[2])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[1] + direction[0])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[0])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[1] + direction[0])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[0])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_point = (point[0]+direction[0], point[1]+direction[1])",
      "mutated_line": "next_point = (point[0] + direction[0], point[1] + direction[-1])",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[-1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[1] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[1] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[-1] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[-1] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[1] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[1] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[2] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[2] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[0] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[0] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[0] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[0] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[-1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[-1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((next_point, dist+1))",
      "mutated_line": "queue.append((next_point, dist - 1))",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist - 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((next_point, dist+1))",
      "mutated_line": "queue.append((next_point, dist * 1))",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist * 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[2]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[2]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[0]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[0]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[0]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[0]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[-1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[-1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((next_point, dist+1))",
      "mutated_line": "queue.append((next_point, dist + 2))",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 2))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((next_point, dist+1))",
      "mutated_line": "queue.append((next_point, dist + 0))",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 0))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((next_point, dist+1))",
      "mutated_line": "queue.append((next_point, dist + 0))",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 0))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((next_point, dist+1))",
      "mutated_line": "queue.append((next_point, dist + -1))",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[0]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + -1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[1]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[1]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[-1]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[-1]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and maze[next_point[0]][next_point[1]] == 0 and next_point not in visited):",
      "mutated_line": "if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[1]][next_point[1]] == 0) and (next_point not in visited):",
      "code": "from collections import deque\n\ndef shortest_path(maze, src, dest):\n    (num_rows, num_cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    queue = deque([(src, 0)])\n    visited = set()\n    while queue:\n        (point, dist) = queue.popleft()\n        if point == dest:\n            return dist\n        for direction in directions:\n            next_point = (point[0] + direction[0], point[1] + direction[1])\n            if 0 <= next_point[0] < num_rows and 0 <= next_point[1] < num_cols and (maze[next_point[1]][next_point[1]] == 0) and (next_point not in visited):\n                queue.append((next_point, dist + 1))\n                visited.add(next_point)\n    return -1"
    }
  ]
}