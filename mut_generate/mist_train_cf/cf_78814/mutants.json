{
  "task_id": "cf_78814",
  "entry_point": "minPath",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(path) == k:",
      "mutated_line": "if len(path) != k:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) != k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 1, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 1, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], -1, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], -1, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 1, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 1, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 0, 1, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 1, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 0, -1, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, -1, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 0, 1, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 1, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < N or 0 <= y < N or (x, y) not in visited:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N or 0 <= y < N or (x, y) not in visited:\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][1], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][1], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][-1], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][-1], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][1], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][1], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = set([(0, 0)])",
      "mutated_line": "visited = set([(1, 0)])",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(1, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = set([(0, 0)])",
      "mutated_line": "visited = set([(-1, 0)])",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(-1, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = set([(0, 0)])",
      "mutated_line": "visited = set([(1, 0)])",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(1, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = set([(0, 0)])",
      "mutated_line": "visited = set([(0, 1)])",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 1)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = set([(0, 0)])",
      "mutated_line": "visited = set([(0, -1)])",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, -1)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = set([(0, 0)])",
      "mutated_line": "visited = set([(0, 1)])",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 1)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i - 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i * 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i + 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i * 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j - 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j * 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j + 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j * 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 < x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 < x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 > x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 > x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 == x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 == x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < N and 0 < y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 < y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < N and 0 > y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 > y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < N and 0 == y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 == y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new_cost = cost + grid[x][y]",
      "mutated_line": "new_cost = cost - grid[x][y]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost - grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new_cost = cost + grid[x][y]",
      "mutated_line": "new_cost = cost * grid[x][y]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost * grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "new_path = path + [grid[x][y]]",
      "mutated_line": "new_path = path - [grid[x][y]]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path - [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "new_path = path + [grid[x][y]]",
      "mutated_line": "new_path = path * [grid[x][y]]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path * [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[1][0], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[1][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[-1][0], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[-1][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[1][0], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[1][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 0, 0, [grid[0][1]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][1]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 0, 0, [grid[0][-1]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][-1]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 0, 0, [grid[0][1]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][1]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 2, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + -1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 2, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - -1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 2), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + -1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 2)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:",
      "mutated_line": "if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - -1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 1 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 1 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if -1 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if -1 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 1 <= x < N and 0 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 1 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < N and 1 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 1 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < N and -1 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and -1 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < N and 0 <= y < N and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < N and 1 <= y < N and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 1 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 0, 0, [grid[1][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[1][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 0, 0, [grid[-1][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[-1][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "minheap = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "minheap = [(grid[0][0], 0, 0, [grid[1][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[1][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        (cost, i, j, path) = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
    }
  ]
}