{
  "task_id": "cf_61675",
  "entry_point": "held_karp_tsp",
  "mutant_count": 77,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return min_cost + distance_matrix[0][0]",
      "mutated_line": "return min_cost - distance_matrix[0][0]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost - distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return min_cost + distance_matrix[0][0]",
      "mutated_line": "return min_cost * distance_matrix[0][0]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost * distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][1 << i][i] = 0",
      "mutated_line": "dp[i][1 << i][i] = 1",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 1\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][1 << i][i] = 0",
      "mutated_line": "dp[i][1 << i][i] = -1",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = -1\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][1 << i][i] = 0",
      "mutated_line": "dp[i][1 << i][i] = 1",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 1\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for mask in range(1, 1 << n):",
      "mutated_line": "for mask in range(2, 1 << n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(2, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for mask in range(1, 1 << n):",
      "mutated_line": "for mask in range(0, 1 << n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(0, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for mask in range(1, 1 << n):",
      "mutated_line": "for mask in range(0, 1 << n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(0, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for mask in range(1, 1 << n):",
      "mutated_line": "for mask in range(-1, 1 << n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(-1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "min_cost = float('inf')",
      "mutated_line": "min_cost = float('')",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for node in range(1, n):",
      "mutated_line": "for node in range(2, n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(2, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for node in range(1, n):",
      "mutated_line": "for node in range(0, n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(0, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for node in range(1, n):",
      "mutated_line": "for node in range(0, n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(0, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for node in range(1, n):",
      "mutated_line": "for node in range(-1, n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(-1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]",
      "mutated_line": "dp = [[[float('inf')] / n for _ in range(1 << n)] for _ in range(n)]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] / n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]",
      "mutated_line": "dp = [[[float('inf')] + n for _ in range(1 << n)] for _ in range(n)]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] + n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]",
      "mutated_line": "dp = [[[float('inf')] ** n for _ in range(1 << n)] for _ in range(n)]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] ** n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for mask in range(1, 1 << n):",
      "mutated_line": "for mask in range(1, 2 << n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 2 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for mask in range(1, 1 << n):",
      "mutated_line": "for mask in range(1, 0 << n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 0 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for mask in range(1, 1 << n):",
      "mutated_line": "for mask in range(1, 0 << n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 0 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for mask in range(1, 1 << n):",
      "mutated_line": "for mask in range(1, -1 << n):",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, -1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] - distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] - distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] * distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] * distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return min_cost + distance_matrix[0][0]",
      "mutated_line": "return min_cost + distance_matrix[0][1]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return min_cost + distance_matrix[0][0]",
      "mutated_line": "return min_cost + distance_matrix[0][-1]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return min_cost + distance_matrix[0][0]",
      "mutated_line": "return min_cost + distance_matrix[0][1]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if not (mask & (1 << node)):",
      "mutated_line": "if not mask | 1 << node:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask | 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if node == node2:",
      "mutated_line": "if node != node2:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node != node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if (mask & (1 << node2)) == 0:",
      "mutated_line": "if mask & 1 << node2 != 0:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 != 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "new_mask = mask ^ (1 << node)",
      "mutated_line": "new_mask = mask | 1 << node",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask | 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return min_cost + distance_matrix[0][0]",
      "mutated_line": "return min_cost + distance_matrix[1][0]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return min_cost + distance_matrix[0][0]",
      "mutated_line": "return min_cost + distance_matrix[-1][0]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[-1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return min_cost + distance_matrix[0][0]",
      "mutated_line": "return min_cost + distance_matrix[1][0]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][1 << i][i] = 0",
      "mutated_line": "dp[i][2 << i][i] = 0",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][2 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][1 << i][i] = 0",
      "mutated_line": "dp[i][0 << i][i] = 0",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][0 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][1 << i][i] = 0",
      "mutated_line": "dp[i][0 << i][i] = 0",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][0 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][1 << i][i] = 0",
      "mutated_line": "dp[i][-1 << i][i] = 0",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][-1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if (mask & (1 << node2)) == 0:",
      "mutated_line": "if mask | 1 << node2 == 0:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask | 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (mask & (1 << node2)) == 0:",
      "mutated_line": "if mask & 1 << node2 == 1:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 1:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (mask & (1 << node2)) == 0:",
      "mutated_line": "if mask & 1 << node2 == -1:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == -1:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (mask & (1 << node2)) == 0:",
      "mutated_line": "if mask & 1 << node2 == 1:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 1:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])",
      "mutated_line": "dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] - distance_matrix[node2][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] - distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])",
      "mutated_line": "dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] * distance_matrix[node2][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] * distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][1] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][1] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][-1] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][-1] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][1] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][1] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]",
      "mutated_line": "dp = [[[float('')] * n for _ in range(1 << n)] for _ in range(n)]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]",
      "mutated_line": "dp = [[[float('inf')] * n for _ in range(2 << n)] for _ in range(n)]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(2 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]",
      "mutated_line": "dp = [[[float('inf')] * n for _ in range(0 << n)] for _ in range(n)]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(0 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]",
      "mutated_line": "dp = [[[float('inf')] * n for _ in range(0 << n)] for _ in range(n)]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(0 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]",
      "mutated_line": "dp = [[[float('inf')] * n for _ in range(-1 << n)] for _ in range(n)]",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(-1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if not (mask & (1 << node)):",
      "mutated_line": "if not mask & 2 << node:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 2 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if not (mask & (1 << node)):",
      "mutated_line": "if not mask & 0 << node:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 0 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if not (mask & (1 << node)):",
      "mutated_line": "if not mask & 0 << node:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 0 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if not (mask & (1 << node)):",
      "mutated_line": "if not mask & -1 << node:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & -1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_mask = mask ^ (1 << node)",
      "mutated_line": "new_mask = mask ^ 2 << node",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 2 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_mask = mask ^ (1 << node)",
      "mutated_line": "new_mask = mask ^ 0 << node",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 0 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_mask = mask ^ (1 << node)",
      "mutated_line": "new_mask = mask ^ 0 << node",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 0 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_mask = mask ^ (1 << node)",
      "mutated_line": "new_mask = mask ^ -1 << node",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ -1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) + 1][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) + 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) * 1][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) * 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[1][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[1][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[-1][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[-1][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[1][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[1][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (mask & (1 << node2)) == 0:",
      "mutated_line": "if mask & 2 << node2 == 0:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 2 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (mask & (1 << node2)) == 0:",
      "mutated_line": "if mask & 0 << node2 == 0:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 0 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (mask & (1 << node2)) == 0:",
      "mutated_line": "if mask & 0 << node2 == 0:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 0 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (mask & (1 << node2)) == 0:",
      "mutated_line": "if mask & -1 << node2 == 0:",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & -1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 2][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 2][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 0][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 0][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - 0][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - 0][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(1 << n) - -1][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(1 << n) - -1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(2 << n) - 1][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(2 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(0 << n) - 1][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(0 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(0 << n) - 1][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(0 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "min_cost = min(min_cost, dp[node][(1 << n) - 1][0] + distance_matrix[0][node])",
      "mutated_line": "min_cost = min(min_cost, dp[node][(-1 << n) - 1][0] + distance_matrix[0][node])",
      "code": "def held_karp_tsp(distance_matrix):\n    \"\"\"\n    Returns the minimum cost (shortest distance) of a circular tour that visits all cities exactly once and returns to the starting city.\n    \n    Args:\n    distance_matrix (list of lists): A 2D distance matrix where distance_matrix[i][j] represents the distance from city i to city j.\n    \n    Returns:\n    int: The minimum cost of the tour.\n    \"\"\"\n    n = len(distance_matrix)\n    dp = [[[float('inf')] * n for _ in range(1 << n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i][i] = 0\n    for mask in range(1, 1 << n):\n        for node in range(n):\n            if not mask & 1 << node:\n                continue\n            for node2 in range(n):\n                if node == node2:\n                    continue\n                if mask & 1 << node2 == 0:\n                    continue\n                new_mask = mask ^ 1 << node\n                dp[node][mask][node2] = min(dp[node][mask][node2], dp[node2][new_mask][node] + distance_matrix[node2][node])\n    min_cost = float('inf')\n    for node in range(1, n):\n        min_cost = min(min_cost, dp[node][(-1 << n) - 1][0] + distance_matrix[0][node])\n    return min_cost + distance_matrix[0][0]"
    }
  ]
}