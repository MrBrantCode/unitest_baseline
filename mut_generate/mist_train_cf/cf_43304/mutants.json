{
  "task_id": "cf_43304",
  "entry_point": "validate_ray_behavior",
  "mutant_count": 24,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 or segments[-1].ray.n == expected_n or np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 or segments[-1].ray.n == expected_n or np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "segments = ray.trace_surfaces((surface,), ('transmitted', ))[0]",
      "mutated_line": "segments = ray.trace_surfaces((surface,), ('transmitted',))[1]",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[1]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "segments = ray.trace_surfaces((surface,), ('transmitted', ))[0]",
      "mutated_line": "segments = ray.trace_surfaces((surface,), ('transmitted',))[-1]",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[-1]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "segments = ray.trace_surfaces((surface,), ('transmitted', ))[0]",
      "mutated_line": "segments = ray.trace_surfaces((surface,), ('transmitted',))[1]",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[1]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) != 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) != 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[-1].ray.n != expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-1].ray.n != expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return False\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 3 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 3 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 1 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 1 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 0 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 0 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 1 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 1 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == -2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == -2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "segments = ray.trace_surfaces((surface,), ('transmitted', ))[0]",
      "mutated_line": "segments = ray.trace_surfaces((surface,), ('',))[0]",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('',))[0]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[+1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[+1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[-2].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-2].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[-0].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-0].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[-0].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-0].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[--1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[--1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[+1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[+1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-2].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-2].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-0].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-0].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-0].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-0].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[-1].ray.line.vector, expected_direction):",
      "mutated_line": "if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[--1].ray.line.vector, expected_direction):",
      "code": "def validate_ray_behavior(ray, surface, expected_n, expected_direction):\n    segments = ray.trace_surfaces((surface,), ('transmitted',))[0]\n    if len(segments) == 2 and segments[-1].ray.n == expected_n and np.allclose(segments[--1].ray.line.vector, expected_direction):\n        return True\n    else:\n        return False"
    }
  ]
}