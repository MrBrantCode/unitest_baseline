{
  "task_id": "cf_76369",
  "entry_point": "longestDupSubstring",
  "mutant_count": 119,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 63 + 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 + 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 63 * 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 * 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 1\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = -1\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 1\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while left <= right:",
      "mutated_line": "while left < right:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left < right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while left <= right:",
      "mutated_line": "while left > right:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left > right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while left <= right:",
      "mutated_line": "while left == right:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left == right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "nums = [ord(c) - ord('a') for c in s]",
      "mutated_line": "nums = [ord(c) + ord('a') for c in s]",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) + ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "nums = [ord(c) - ord('a') for c in s]",
      "mutated_line": "nums = [ord(c) * ord('a') for c in s]",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) * ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 * 63 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 * 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 + 63 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 + 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 63 - 2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 2\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 63 - 0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 0\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 63 - 0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 0\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 63 - -1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - -1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "left, right = 1, len(s)",
      "mutated_line": "(left, right) = (2, len(s))",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (2, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "left, right = 1, len(s)",
      "mutated_line": "(left, right) = (0, len(s))",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (0, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "left, right = 1, len(s)",
      "mutated_line": "(left, right) = (0, len(s))",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (0, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "left, right = 1, len(s)",
      "mutated_line": "(left, right) = (-1, len(s))",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (-1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "hash = 0",
      "mutated_line": "hash = 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 1\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "hash = 0",
      "mutated_line": "hash = -1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = -1\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "hash = 0",
      "mutated_line": "hash = 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 1\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return +1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) / 2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) / 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) * 2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) * 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if found != -1:",
      "mutated_line": "if found == -1:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found == -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "start, end = res, res + left - 1",
      "mutated_line": "(start, end) = (res, res + left + 1)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left + 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "start, end = res, res + left - 1",
      "mutated_line": "(start, end) = (res, (res + left) * 1)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, (res + left) * 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 3 ** 63 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 3 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 1 ** 63 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 1 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 0 ** 63 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 0 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 1 ** 63 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 1 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = -2 ** 63 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = -2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 64 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 64 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 62 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 62 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 0 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 0 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** 1 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 1 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 2**63 - 1",
      "mutated_line": "mod = 2 ** -63 - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** -63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 + nums[i]) * mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) * mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = hash * 26 + nums[i] + mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = hash * 26 + nums[i] + mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "constants = pow(26, length, mod)",
      "mutated_line": "constants = pow(27, length, mod)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(27, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "constants = pow(26, length, mod)",
      "mutated_line": "constants = pow(25, length, mod)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(25, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "constants = pow(26, length, mod)",
      "mutated_line": "constants = pow(0, length, mod)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(0, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "constants = pow(26, length, mod)",
      "mutated_line": "constants = pow(1, length, mod)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(1, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "constants = pow(26, length, mod)",
      "mutated_line": "constants = pow(-26, length, mod)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(-26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 - nums[i - length] * constants + nums[i]) * mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) * mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = hash * 26 - nums[i - length] * constants + nums[i] + mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = hash * 26 - nums[i - length] * constants + nums[i] + mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if hash in hashes:",
      "mutated_line": "if hash not in hashes:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash not in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -2\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -0\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -0\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return --1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left - right) // 2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left - right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = left * right // 2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = left * right // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 3",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 3\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 1\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 0\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 1\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // -2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // -2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if found != -1:",
      "mutated_line": "if found != +1:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != +1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid - 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid * 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid * 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "right = mid - 1",
      "mutated_line": "right = mid + 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid + 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "right = mid - 1",
      "mutated_line": "right = mid * 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid * 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "start, end = res, res + left - 1",
      "mutated_line": "(start, end) = (res, res - left - 1)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res - left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "start, end = res, res + left - 1",
      "mutated_line": "(start, end) = (res, res * left - 1)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res * left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "start, end = res, res + left - 1",
      "mutated_line": "(start, end) = (res, res + left - 2)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 2)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "start, end = res, res + left - 1",
      "mutated_line": "(start, end) = (res, res + left - 0)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 0)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "start, end = res, res + left - 1",
      "mutated_line": "(start, end) = (res, res + left - 0)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 0)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "start, end = res, res + left - 1",
      "mutated_line": "(start, end) = (res, res + left - -1)",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - -1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "nums = [ord(c) - ord('a') for c in s]",
      "mutated_line": "nums = [ord(c) - ord('') for c in s]",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 - nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 - nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = hash * 26 * nums[i] % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = hash * 26 * nums[i] % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 - nums[i - length] * constants - nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants - nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 - nums[i - length] * constants) * nums[i] % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants) * nums[i] % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return i - length + 1",
      "mutated_line": "return i - length - 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length - 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return i - length + 1",
      "mutated_line": "return (i - length) * 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return (i - length) * 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if found != -1:",
      "mutated_line": "if found != -2:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -2:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if found != -1:",
      "mutated_line": "if found != -0:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -0:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if found != -1:",
      "mutated_line": "if found != -0:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -0:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if found != -1:",
      "mutated_line": "if found != --1:",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != --1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 2\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 0\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 0\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + -1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + -1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right = mid - 1",
      "mutated_line": "right = mid - 2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 2\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right = mid - 1",
      "mutated_line": "right = mid - 0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 0\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right = mid - 1",
      "mutated_line": "right = mid - 0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 0\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right = mid - 1",
      "mutated_line": "right = mid - -1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - -1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash / 26 + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash / 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash + 26 + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash + 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash ** 26 + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash ** 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 + nums[i - length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 + nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 * (nums[i - length] * constants) + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 * (nums[i - length] * constants) + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return i - length + 1",
      "mutated_line": "return i + length + 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i + length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return i - length + 1",
      "mutated_line": "return i * length + 1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i * length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return i - length + 1",
      "mutated_line": "return i - length + 2",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 2\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return i - length + 1",
      "mutated_line": "return i - length + 0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 0\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return i - length + 1",
      "mutated_line": "return i - length + 0",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 0\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return i - length + 1",
      "mutated_line": "return i - length + -1",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + -1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash * 27 + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 27 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash * 25 + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 25 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash * 0 + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 0 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash * 1 + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 1 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "hash = (hash * 26 + nums[i]) % mod",
      "mutated_line": "hash = (hash * -26 + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * -26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash / 26 - nums[i - length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash / 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash + 26 - nums[i - length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash + 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash ** 26 - nums[i - length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash ** 26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 - nums[i - length] / constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] / constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 - (nums[i - length] + constants) + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - (nums[i - length] + constants) + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 - nums[i - length] ** constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i - length] ** constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 27 - nums[i - length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 27 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 25 - nums[i - length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 25 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 0 - nums[i - length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 0 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 1 - nums[i - length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 1 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * -26 - nums[i - length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * -26 - nums[i - length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 - nums[i + length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i + length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "hash = ((hash * 26) - (nums[i - length] * constants) + nums[i]) % mod",
      "mutated_line": "hash = (hash * 26 - nums[i * length] * constants + nums[i]) % mod",
      "code": "def longestDupSubstring(s: str) -> str:\n    nums = [ord(c) - ord('a') for c in s]\n    mod = 2 ** 63 - 1\n    (left, right) = (1, len(s))\n    res = 0\n\n    def check(length):\n        hash = 0\n        for i in range(length):\n            hash = (hash * 26 + nums[i]) % mod\n        hashes = {hash}\n        constants = pow(26, length, mod)\n        for i in range(length, len(s)):\n            hash = (hash * 26 - nums[i * length] * constants + nums[i]) % mod\n            if hash in hashes:\n                return i - length + 1\n            hashes.add(hash)\n        return -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = check(mid)\n        if found != -1:\n            left = mid + 1\n            res = found\n        else:\n            right = mid - 1\n    (start, end) = (res, res + left - 1)\n    return s[start:end]"
    }
  ]
}