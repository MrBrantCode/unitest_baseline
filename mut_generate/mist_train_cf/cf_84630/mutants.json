{
  "task_id": "cf_84630",
  "entry_point": "min_operations",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if num == Y:",
      "mutated_line": "if num != Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num != Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num / 2, num - 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num / 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num + 2, num - 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num + 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num ** 2, num - 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num ** 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 2, num + 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num + 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 2, num * 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num * 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 2, num - 1, num / num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num / num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 2, num - 1, num + num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num + num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 2, num - 1, num ** num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num ** num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if next_num not in visited and 1 <= next_num <= Y:",
      "mutated_line": "if next_num not in visited or 1 <= next_num <= Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited or 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "queue = deque([(X, 0)])",
      "mutated_line": "queue = deque([(X, 1)])",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 1)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "queue = deque([(X, 0)])",
      "mutated_line": "queue = deque([(X, -1)])",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, -1)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "queue = deque([(X, 0)])",
      "mutated_line": "queue = deque([(X, 1)])",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 1)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 3, num - 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 3, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 1, num - 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 1, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 0, num - 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 0, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 1, num - 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 1, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * -2, num - 1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * -2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 2, num - 2, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 2, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 2, num - 0, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 0, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 2, num - 0, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 0, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for next_num in [num * 2, num - 1, num * num]:",
      "mutated_line": "for next_num in [num * 2, num - -1, num * num]:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - -1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if next_num not in visited and 1 <= next_num <= Y:",
      "mutated_line": "if next_num in visited and 1 <= next_num <= Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if next_num not in visited and 1 <= next_num <= Y:",
      "mutated_line": "if next_num not in visited and 1 < next_num <= Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 < next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if next_num not in visited and 1 <= next_num <= Y:",
      "mutated_line": "if next_num not in visited and 1 > next_num <= Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 > next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if next_num not in visited and 1 <= next_num <= Y:",
      "mutated_line": "if next_num not in visited and 1 == next_num <= Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 == next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if next_num not in visited and 1 <= next_num <= Y:",
      "mutated_line": "if next_num not in visited and 2 <= next_num <= Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 2 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if next_num not in visited and 1 <= next_num <= Y:",
      "mutated_line": "if next_num not in visited and 0 <= next_num <= Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 0 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if next_num not in visited and 1 <= next_num <= Y:",
      "mutated_line": "if next_num not in visited and 0 <= next_num <= Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 0 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if next_num not in visited and 1 <= next_num <= Y:",
      "mutated_line": "if next_num not in visited and -1 <= next_num <= Y:",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and -1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "queue.append((next_num, step + 1))",
      "mutated_line": "queue.append((next_num, step - 1))",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step - 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "queue.append((next_num, step + 1))",
      "mutated_line": "queue.append((next_num, step * 1))",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step * 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((next_num, step + 1))",
      "mutated_line": "queue.append((next_num, step + 2))",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((next_num, step + 1))",
      "mutated_line": "queue.append((next_num, step + 0))",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 0))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((next_num, step + 1))",
      "mutated_line": "queue.append((next_num, step + 0))",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + 0))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((next_num, step + 1))",
      "mutated_line": "queue.append((next_num, step + -1))",
      "code": "from collections import deque\n\ndef min_operations(X: int, Y: int) -> int:\n    queue = deque([(X, 0)])\n    visited = {X}\n    while queue:\n        (num, step) = queue.popleft()\n        if num == Y:\n            return step\n        for next_num in [num * 2, num - 1, num * num]:\n            if next_num not in visited and 1 <= next_num <= Y:\n                visited.add(next_num)\n                queue.append((next_num, step + -1))\n    return -1"
    }
  ]
}