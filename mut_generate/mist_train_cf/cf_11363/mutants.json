{
  "task_id": "cf_11363",
  "entry_point": "calculate_shortest_distance",
  "mutant_count": 153,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return +1"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if x == x2 and y == y2 and z == z2:",
      "mutated_line": "if x == x2 or y == y2 or z == z2:",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 or y == y2 or z == z2:\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(2, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(2, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(-1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(-1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, -1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, -1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, -1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, -1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (+1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (+1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, -1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, -1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, -1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, -1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (-1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (-1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 2, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 2, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, -1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, -1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, -1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, -1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (-1, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (-1, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, +1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, +1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, -1), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, -1), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (-1, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (-1, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, -1, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, -1, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 2), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 2), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, -1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, -1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (-1, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (-1, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, -1, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, -1, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, +1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, +1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [(0, x1, y1, z1)]",
      "mutated_line": "queue = [(1, x1, y1, z1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(1, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [(0, x1, y1, z1)]",
      "mutated_line": "queue = [(-1, x1, y1, z1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(-1, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [(0, x1, y1, z1)]",
      "mutated_line": "queue = [(1, x1, y1, z1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(1, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if x == x2 and y == y2 and z == z2:",
      "mutated_line": "if x != x2 and y == y2 and (z == z2):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x != x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if x == x2 and y == y2 and z == z2:",
      "mutated_line": "if x == x2 and y != y2 and (z == z2):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y != y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if x == x2 and y == y2 and z == z2:",
      "mutated_line": "if x == x2 and y == y2 and (z != z2):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z != z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) or 0 <= ny < len(grid[0]) or 0 <= nz < len(grid[0][0]) or (grid[nx][ny][nz] == 0) or ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) or 0 <= ny < len(grid[0]) or 0 <= nz < len(grid[0][0]) or (grid[nx][ny][nz] == 0) or ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-2, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-2, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (--1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (--1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -2, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -2, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, --1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, --1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -2)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -2)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, --1)]",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, --1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "nx, ny, nz = x + dx, y + dy, z + dz",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x - dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "nx, ny, nz = x + dx, y + dy, z + dz",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x * dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "nx, ny, nz = x + dx, y + dy, z + dz",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y - dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "nx, ny, nz = x + dx, y + dy, z + dz",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y * dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "nx, ny, nz = x + dx, y + dy, z + dz",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z - dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "nx, ny, nz = x + dx, y + dy, z + dz",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z * dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 < nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 < nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 > nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 > nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 == nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 == nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 < ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 < ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 > ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 > ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 == ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 == ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 < nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 < nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 > nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 > nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 == nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 == nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "grid[nx][ny][nz] == 0 and (nx, ny, nz) not in visited):",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] != 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] != 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "grid[nx][ny][nz] == 0 and (nx, ny, nz) not in visited):",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost - costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost - costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost * costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost * costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 1 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 1 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if -1 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if -1 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 1 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 1 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 1 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 1 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and -1 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and -1 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 1 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 1 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (1 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (1 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (-1 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (-1 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (1 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (1 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "grid[nx][ny][nz] == 0 and (nx, ny, nz) not in visited):",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 1) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 1) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "grid[nx][ny][nz] == 0 and (nx, ny, nz) not in visited):",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == -1) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == -1) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "grid[nx][ny][nz] == 0 and (nx, ny, nz) not in visited):",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 1) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 1) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[1]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[1]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[-1]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[-1]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[1]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[1]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][1])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][1])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][-1])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][-1])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][1])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][1])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz >= 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz >= 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz <= 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz <= 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz != 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz != 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[1][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[1][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[-1][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[-1][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and 0 <= nz < len(grid[0][0]) and",
      "mutated_line": "if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[1][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[1][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 1 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 1 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > -1 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > -1 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 1 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 1 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz <= 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz <= 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz >= 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz >= 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz != 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz != 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else '' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else '' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 1 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 1 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < -1 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < -1 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 1 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 1 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy >= 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy >= 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy <= 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy <= 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy != 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy != 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else '' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else '' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 1 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 1 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > -1 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > -1 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 1 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 1 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy <= 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy <= 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy >= 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy >= 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy != 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy != 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else '' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else '' if dy < 0 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 1 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 1 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < -1 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < -1 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 1 else 'forward' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 1 else 'forward' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx >= 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx >= 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx <= 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx <= 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx != 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx != 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else '' if dx > 0 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else '' if dx > 0 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else '']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else '']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 1 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 1 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > -1 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > -1 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 0 else 'backward']",
      "mutated_line": "new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 1 else 'backward']",
      "code": "from collections import deque\nimport heapq\n\ndef calculate_shortest_distance(grid, x1, y1, z1, x2, y2, z2, costs):\n    \"\"\"\n    Calculate the shortest distance between two points in a three-dimensional grid while avoiding obstacles.\n    \n    Args:\n    grid (3D list): A 3D list of 0s (passable cells) and 1s (impassable cells) representing the grid.\n    x1, y1, z1 (int): The start point coordinates.\n    x2, y2, z2 (int): The target point coordinates.\n    costs (dict): A dictionary with movement directions as keys and costs as values.\n    \n    Returns:\n    int: The shortest distance between the start and target points while avoiding obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, x1, y1, z1)]\n    visited = set((x1, y1, z1))\n    while queue:\n        (cost, x, y, z) = heapq.heappop(queue)\n        if x == x2 and y == y2 and (z == z2):\n            return cost\n        for (dx, dy, dz) in movements:\n            (nx, ny, nz) = (x + dx, y + dy, z + dz)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (0 <= nz < len(grid[0][0])) and (grid[nx][ny][nz] == 0) and ((nx, ny, nz) not in visited):\n                new_cost = cost + costs['up' if dz > 0 else 'down' if dz < 0 else 'right' if dy > 0 else 'left' if dy < 0 else 'forward' if dx > 1 else 'backward']\n                visited.add((nx, ny, nz))\n                heapq.heappush(queue, (new_cost, nx, ny, nz))\n    return -1"
    }
  ]
}