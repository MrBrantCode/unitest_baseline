{
  "task_id": "cf_53141",
  "entry_point": "shiftOneNumber",
  "mutant_count": 26,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sorted_arr = negatives + positives",
      "mutated_line": "sorted_arr = negatives - positives",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives - positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sorted_arr = negatives + positives",
      "mutated_line": "sorted_arr = negatives * positives",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives * positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 1\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return -1\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 1\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "shifted_arr = arr[i:] + arr[:i]",
      "mutated_line": "shifted_arr = arr[i:] - arr[:i]",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] - arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "shifted_arr = arr[i:] + arr[:i]",
      "mutated_line": "shifted_arr = arr[i:] * arr[:i]",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] * arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if shifted_arr == sorted_arr:",
      "mutated_line": "if shifted_arr != sorted_arr:",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr != sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return --1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "negatives = sorted([num for num in arr if num < 0])",
      "mutated_line": "negatives = sorted([num for num in arr if num <= 0])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num <= 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "negatives = sorted([num for num in arr if num < 0])",
      "mutated_line": "negatives = sorted([num for num in arr if num >= 0])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num >= 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "negatives = sorted([num for num in arr if num < 0])",
      "mutated_line": "negatives = sorted([num for num in arr if num != 0])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num != 0])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "positives = sorted([num for num in arr if num >= 0])",
      "mutated_line": "positives = sorted([num for num in arr if num > 0])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num > 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "positives = sorted([num for num in arr if num >= 0])",
      "mutated_line": "positives = sorted([num for num in arr if num < 0])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num < 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "positives = sorted([num for num in arr if num >= 0])",
      "mutated_line": "positives = sorted([num for num in arr if num == 0])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num == 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "negatives = sorted([num for num in arr if num < 0])",
      "mutated_line": "negatives = sorted([num for num in arr if num < 1])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 1])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "negatives = sorted([num for num in arr if num < 0])",
      "mutated_line": "negatives = sorted([num for num in arr if num < -1])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < -1])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "negatives = sorted([num for num in arr if num < 0])",
      "mutated_line": "negatives = sorted([num for num in arr if num < 1])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 1])\n    positives = sorted([num for num in arr if num >= 0])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positives = sorted([num for num in arr if num >= 0])",
      "mutated_line": "positives = sorted([num for num in arr if num >= 1])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 1])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positives = sorted([num for num in arr if num >= 0])",
      "mutated_line": "positives = sorted([num for num in arr if num >= -1])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= -1])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positives = sorted([num for num in arr if num >= 0])",
      "mutated_line": "positives = sorted([num for num in arr if num >= 1])",
      "code": "def shiftOneNumber(arr):\n    \"\"\"\n    This function takes an array of unique integers as input and returns the minimum number of right shift operations required \n    to sort the array according to positive and negative numbers (negatives first, followed by positives). If it is not possible \n    to sort the array through shifting, return -1. If the input array is empty, return 0.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The minimum number of right shift operations required to sort the array.\n    \"\"\"\n    if not arr:\n        return 0\n    negatives = sorted([num for num in arr if num < 0])\n    positives = sorted([num for num in arr if num >= 1])\n    sorted_arr = negatives + positives\n    for i in range(len(arr)):\n        shifted_arr = arr[i:] + arr[:i]\n        if shifted_arr == sorted_arr:\n            return i\n    return -1"
    }
  ]
}