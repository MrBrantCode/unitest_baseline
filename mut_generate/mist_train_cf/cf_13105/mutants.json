{
  "task_id": "cf_13105",
  "entry_point": "array_stack_operations",
  "mutant_count": 51,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "self.stack = [None] * n",
      "mutated_line": "self.stack = [None] / n",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] / n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "self.stack = [None] * n",
      "mutated_line": "self.stack = [None] + n",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] + n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "self.stack = [None] * n",
      "mutated_line": "self.stack = [None] ** n",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] ** n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "self.top = -1",
      "mutated_line": "self.top = +1",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = +1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "\"\"\"Adds an element to the top of the stack.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if self.top < self.max_size - 1:",
      "mutated_line": "if self.top <= self.max_size - 1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top <= self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if self.top < self.max_size - 1:",
      "mutated_line": "if self.top >= self.max_size - 1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top >= self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if self.top < self.max_size - 1:",
      "mutated_line": "if self.top != self.max_size - 1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top != self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "self.top += 1",
      "mutated_line": "self.top -= 1",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top -= 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "\"\"\"Removes an element from the top of the stack.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top > 0:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top > 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top < 0:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top < 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top == 0:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top == 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "self.top -= 1",
      "mutated_line": "self.top += 1",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top += 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "\"\"\"Returns the top element of the stack without removing it.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top > 0:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top > 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top < 0:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top < 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top == 0:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top == 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.top = -1",
      "mutated_line": "self.top = -2",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -2\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.top = -1",
      "mutated_line": "self.top = -0",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -0\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.top = -1",
      "mutated_line": "self.top = -0",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -0\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.top = -1",
      "mutated_line": "self.top = --1",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = --1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if self.top < self.max_size - 1:",
      "mutated_line": "if self.top < self.max_size + 1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size + 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if self.top < self.max_size - 1:",
      "mutated_line": "if self.top < self.max_size * 1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size * 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.top += 1",
      "mutated_line": "self.top += 2",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 2\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.top += 1",
      "mutated_line": "self.top += 0",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 0\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.top += 1",
      "mutated_line": "self.top += 0",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 0\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.top += 1",
      "mutated_line": "self.top += -1",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += -1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top >= 1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 1:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top >= -1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= -1:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top >= 1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 1:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.top -= 1",
      "mutated_line": "self.top -= 2",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 2\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.top -= 1",
      "mutated_line": "self.top -= 0",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 0\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.top -= 1",
      "mutated_line": "self.top -= 0",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 0\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.top -= 1",
      "mutated_line": "self.top -= -1",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= -1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top >= 1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 1:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top >= -1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= -1:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if self.top >= 0:",
      "mutated_line": "if self.top >= 1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 1:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if op == \"push\":",
      "mutated_line": "if op != 'push':",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op != 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if self.top < self.max_size - 1:",
      "mutated_line": "if self.top < self.max_size - 2:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 2:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if self.top < self.max_size - 1:",
      "mutated_line": "if self.top < self.max_size - 0:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 0:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if self.top < self.max_size - 1:",
      "mutated_line": "if self.top < self.max_size - 0:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 0:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if self.top < self.max_size - 1:",
      "mutated_line": "if self.top < self.max_size - -1:",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - -1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "raise Exception(\"Stack is full\")",
      "mutated_line": "raise Exception('')",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "raise Exception(\"Stack is empty\")",
      "mutated_line": "raise Exception('')",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "raise Exception(\"Stack is empty\")",
      "mutated_line": "raise Exception('')",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if op == \"push\":",
      "mutated_line": "if op == '':",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == '':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif op == \"pop\":",
      "mutated_line": "elif op != 'pop':",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op != 'pop':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif op == \"pop\":",
      "mutated_line": "elif op == '':",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == '':\n                result.append(self.pop())\n            elif op == 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif op == \"peek\":",
      "mutated_line": "elif op != 'peek':",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op != 'peek':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif op == \"peek\":",
      "mutated_line": "elif op == '':",
      "code": "class ArrayStack:\n\n    def __init__(self, n):\n        self.stack = [None] * n\n        self.top = -1\n        self.max_size = n\n\n    def push(self, x):\n        \"\"\"Adds an element to the top of the stack.\"\"\"\n        if self.top < self.max_size - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        else:\n            raise Exception('Stack is full')\n\n    def pop(self):\n        \"\"\"Removes an element from the top of the stack.\"\"\"\n        if self.top >= 0:\n            x = self.stack[self.top]\n            self.stack[self.top] = None\n            self.top -= 1\n            return x\n        else:\n            raise Exception('Stack is empty')\n\n    def peek(self):\n        \"\"\"Returns the top element of the stack without removing it.\"\"\"\n        if self.top >= 0:\n            return self.stack[self.top]\n        else:\n            raise Exception('Stack is empty')\n\n    def array_stack_operations(self, operations, values):\n        result = []\n        for (i, op) in enumerate(operations):\n            if op == 'push':\n                self.push(values[i])\n            elif op == 'pop':\n                result.append(self.pop())\n            elif op == '':\n                result.append(self.peek())\n        return result\n\ndef array_stack_operations(operations, values, n):\n    stack = ArrayStack(n)\n    return stack.array_stack_operations(operations, values)"
    }
  ]
}