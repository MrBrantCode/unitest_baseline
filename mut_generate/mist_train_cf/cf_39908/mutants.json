{
  "task_id": "cf_39908",
  "entry_point": "conjugate_gradient",
  "mutant_count": 40,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=1.0000000001, maxIter=1000):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1.0000000001, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=-0.9999999999, maxIter=1000):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=-0.9999999999, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=0, maxIter=1000):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=0, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=1, maxIter=1000):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=-1e-10, maxIter=1000):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=-1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1001):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1001):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=999):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=999):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=0):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=0):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):",
      "mutated_line": "def conjugate_gradient(A, b, x0, eps=1e-10, maxIter=-1000):",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=-1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = b - np.dot(A, x)",
      "mutated_line": "r = b + np.dot(A, x)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b + np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = b - np.dot(A, x)",
      "mutated_line": "r = b * np.dot(A, x)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b * np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "alpha = rsold / np.dot(p, Ap)",
      "mutated_line": "alpha = rsold * np.dot(p, Ap)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold * np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "alpha = rsold / np.dot(p, Ap)",
      "mutated_line": "alpha = rsold // np.dot(p, Ap)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold // np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = x + alpha * p",
      "mutated_line": "x = x - alpha * p",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x - alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = x + alpha * p",
      "mutated_line": "x = x * (alpha * p)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x * (alpha * p)\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "r = r - alpha * Ap",
      "mutated_line": "r = r + alpha * Ap",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r + alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "r = r - alpha * Ap",
      "mutated_line": "r = r * (alpha * Ap)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r * (alpha * Ap)\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if np.sqrt(rsnew) < eps:",
      "mutated_line": "if np.sqrt(rsnew) <= eps:",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) <= eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if np.sqrt(rsnew) < eps:",
      "mutated_line": "if np.sqrt(rsnew) >= eps:",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) >= eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if np.sqrt(rsnew) < eps:",
      "mutated_line": "if np.sqrt(rsnew) != eps:",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) != eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = r + (rsnew / rsold) * p",
      "mutated_line": "p = r - rsnew / rsold * p",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r - rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = r + (rsnew / rsold) * p",
      "mutated_line": "p = r * (rsnew / rsold * p)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r * (rsnew / rsold * p)\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return x, ite+1",
      "mutated_line": "return (x, ite - 1)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return x, ite+1",
      "mutated_line": "return (x, ite * 1)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite * 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = x + alpha * p",
      "mutated_line": "x = x + alpha / p",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha / p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = x + alpha * p",
      "mutated_line": "x = x + (alpha + p)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + (alpha + p)\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = x + alpha * p",
      "mutated_line": "x = x + alpha ** p",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha ** p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "r = r - alpha * Ap",
      "mutated_line": "r = r - alpha / Ap",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha / Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "r = r - alpha * Ap",
      "mutated_line": "r = r - (alpha + Ap)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - (alpha + Ap)\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "r = r - alpha * Ap",
      "mutated_line": "r = r - alpha ** Ap",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha ** Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = r + (rsnew / rsold) * p",
      "mutated_line": "p = r + rsnew / rsold / p",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold / p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = r + (rsnew / rsold) * p",
      "mutated_line": "p = r + (rsnew / rsold + p)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + (rsnew / rsold + p)\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = r + (rsnew / rsold) * p",
      "mutated_line": "p = r + (rsnew / rsold) ** p",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + (rsnew / rsold) ** p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x, ite+1",
      "mutated_line": "return (x, ite + 2)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x, ite+1",
      "mutated_line": "return (x, ite + 0)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x, ite+1",
      "mutated_line": "return (x, ite + 0)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x, ite+1",
      "mutated_line": "return (x, ite + -1)",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew / rsold * p\n        rsold = rsnew\n    return (x, ite + -1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = r + (rsnew / rsold) * p",
      "mutated_line": "p = r + rsnew * rsold * p",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew * rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = r + (rsnew / rsold) * p",
      "mutated_line": "p = r + rsnew // rsold * p",
      "code": "import numpy as np\n\ndef conjugate_gradient(A, b, x0, eps=1e-10, maxIter=1000):\n    x = np.copy(x0)\n    r = b - np.dot(A, x)\n    p = np.copy(r)\n    rsold = np.dot(r, r)\n    for ite in range(maxIter):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        if np.sqrt(rsnew) < eps:\n            break\n        p = r + rsnew // rsold * p\n        rsold = rsnew\n    return (x, ite + 1)"
    }
  ]
}