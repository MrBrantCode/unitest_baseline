{
  "task_id": "cf_77028",
  "entry_point": "kthSmallest",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "while k > 0 and min_heap:",
      "mutated_line": "(number, r, c) = heapq.heappop(min_heap)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 or min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (1, 0, -1)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (1, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (-1, 0, -1)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (-1, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (1, 0, -1)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (1, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (0, 1, -1)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 1, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (0, -1, -1)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, -1, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (0, 1, -1)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 1, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (0, 0, +1)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, +1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while k > 0 and min_heap:",
      "mutated_line": "(number, r, c) = heapq.heappop(min_heap)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k >= 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while k > 0 and min_heap:",
      "mutated_line": "(number, r, c) = heapq.heappop(min_heap)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k <= 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while k > 0 and min_heap:",
      "mutated_line": "(number, r, c) = heapq.heappop(min_heap)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k != 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 and min_heap[0][0] != number and (k == 1):",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 and min_heap[0][0] != number and (k == 1):\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "k -= 1",
      "mutated_line": "if c < n - 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k += 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c < n - 1:",
      "mutated_line": "if c <= n - 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c <= n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c < n - 1:",
      "mutated_line": "if c >= n - 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c >= n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c < n - 1:",
      "mutated_line": "if c != n - 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c != n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (0, 0, -2)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -2)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (0, 0, -0)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -0)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (0, 0, -0)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -0)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "number, r, c = 0, 0, -1",
      "mutated_line": "(number, r, c) = (0, 0, --1)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, --1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while k > 0 and min_heap:",
      "mutated_line": "(number, r, c) = heapq.heappop(min_heap)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 1 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while k > 0 and min_heap:",
      "mutated_line": "(number, r, c) = heapq.heappop(min_heap)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > -1 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while k > 0 and min_heap:",
      "mutated_line": "(number, r, c) = heapq.heappop(min_heap)",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 1 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) != 0 or min_heap[0][0] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) != 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[0][0] == number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] == number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k != 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k != 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "k -= 1",
      "mutated_line": "if c < n - 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 2\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "k -= 1",
      "mutated_line": "if c < n - 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 0\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "k -= 1",
      "mutated_line": "if c < n - 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 0\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "k -= 1",
      "mutated_line": "if c < n - 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= -1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c < n - 1:",
      "mutated_line": "if c < n + 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n + 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c < n - 1:",
      "mutated_line": "if c < n * 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n * 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "min_heap.append((matrix[r][0], r, 0))",
      "mutated_line": "min_heap.append((matrix[r][0], r, 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 1))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "min_heap.append((matrix[r][0], r, 0))",
      "mutated_line": "min_heap.append((matrix[r][0], r, -1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, -1))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "min_heap.append((matrix[r][0], r, 0))",
      "mutated_line": "min_heap.append((matrix[r][0], r, 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 1))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 1 or min_heap[0][0] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 1 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == -1 or min_heap[0][0] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == -1 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 1 or min_heap[0][0] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 1 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 2:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 2:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 0:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 0:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 0:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 0:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == -1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == -1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c < n - 1:",
      "mutated_line": "if c < n - 2:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 2:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c < n - 1:",
      "mutated_line": "if c < n - 0:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 0:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c < n - 1:",
      "mutated_line": "if c < n - 0:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 0:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c < n - 1:",
      "mutated_line": "if c < n - -1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - -1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "min_heap.append((matrix[r][0], r, 0))",
      "mutated_line": "min_heap.append((matrix[r][1], r, 0))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][1], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "min_heap.append((matrix[r][0], r, 0))",
      "mutated_line": "min_heap.append((matrix[r][-1], r, 0))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][-1], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "min_heap.append((matrix[r][0], r, 0))",
      "mutated_line": "min_heap.append((matrix[r][1], r, 0))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][1], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[0][1] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][1] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[0][-1] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][-1] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[0][1] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][1] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c - 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c - 1))\n    return number"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c * 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c * 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[1][0] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[1][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[-1][0] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[-1][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:",
      "mutated_line": "if len(min_heap) == 0 or min_heap[1][0] != number or k == 1:",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[1][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))\n    return number"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c - 1], r, c + 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c - 1], r, c + 1))\n    return number"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c * 1], r, c + 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c * 1], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 2))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 2))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 0))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 0))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 0))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 0))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + -1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 1], r, c + -1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + 2], r, c + 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 2], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + 0], r, c + 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 0], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + 0], r, c + 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + 0], r, c + 1))\n    return number"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))",
      "mutated_line": "heapq.heappush(min_heap, (matrix[r][c + -1], r, c + 1))",
      "code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    n = len(matrix)\n    for r in range(min(k, n)):\n        min_heap.append((matrix[r][0], r, 0))\n    heapq.heapify(min_heap)\n    (number, r, c) = (0, 0, -1)\n    while k > 0 and min_heap:\n        (number, r, c) = heapq.heappop(min_heap)\n        if len(min_heap) == 0 or min_heap[0][0] != number or k == 1:\n            k -= 1\n        if c < n - 1:\n            heapq.heappush(min_heap, (matrix[r][c + -1], r, c + 1))\n    return number"
    }
  ]
}