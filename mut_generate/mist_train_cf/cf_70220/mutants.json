{
  "task_id": "cf_70220",
  "entry_point": "compare_paradigms",
  "mutant_count": 38,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "\"Imperative\": {",
      "mutated_line": "paradigms = {'': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "\"Declarative\": {",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, '': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, '': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "\"Functional\": {",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, '': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, '': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "\"Object-Oriented\": {",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, '': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, '': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "print(compare_paradigms(\"Imperative\"))",
      "mutated_line": "print(compare_paradigms(''))",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms(''))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "\"description\": \"A sequence of instructions that change the state of the computer.\",",
      "mutated_line": "paradigms = {'Imperative': {'': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "\"most_effective\": \"Applications where time is a significant factor, such as video games or GUI based applications.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', '': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', '': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "\"least_effective\": \"Higher-level or business problems which demand abstraction.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', '': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', '': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "\"example_language\": \"C\"",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', '': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', '': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "\"description\": \"A sequence of instructions that change the state of the computer.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': '', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': '', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "\"most_effective\": \"Applications where time is a significant factor, such as video games or GUI based applications.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': '', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': '', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "\"least_effective\": \"Higher-level or business problems which demand abstraction.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': '', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': '', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "\"example_language\": \"C\"",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': ''}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': ''}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "\"description\": \"Specifies what the program must do, not how it should do it.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "\"most_effective\": \"Data-focused applications or programs, such as database management and data analysis tools.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', '': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', '': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "\"least_effective\": \"If you need complete control over the program’s flow and state.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', '': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', '': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "\"example_language\": \"SQL\"",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', '': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', '': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "\"description\": \"Specifies what the program must do, not how it should do it.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': '', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': '', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "\"most_effective\": \"Data-focused applications or programs, such as database management and data analysis tools.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': '', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': '', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "\"least_effective\": \"If you need complete control over the program’s flow and state.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': '', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': '', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "\"example_language\": \"SQL\"",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': ''}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': ''}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "\"description\": \"Functions are first-class entities, taking inputs & producing outputs without internal state.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "\"most_effective\": \"Manipulating data and concurrent programming.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', '': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', '': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "\"least_effective\": \"If the problem requires stateful or imperative model.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', '': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', '': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "\"example_language\": \"Haskell\"",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', '': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', '': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "\"description\": \"Functions are first-class entities, taking inputs & producing outputs without internal state.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': '', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': '', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "\"most_effective\": \"Manipulating data and concurrent programming.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': '', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': '', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "\"least_effective\": \"If the problem requires stateful or imperative model.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': '', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': '', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "\"example_language\": \"Haskell\"",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': ''}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': ''}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "\"description\": \"Uses instances of classes, known as objects, to carry out tasks.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "\"most_effective\": \"Building large, complex systems where re-usability of code and abstraction is necessary.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', '': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', '': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "\"least_effective\": \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', '': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', '': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "\"example_language\": \"Java\"",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", '': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", '': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "\"description\": \"Uses instances of classes, known as objects, to carry out tasks.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': '', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': '', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "\"most_effective\": \"Building large, complex systems where re-usability of code and abstraction is necessary.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': '', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': '', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "\"least_effective\": \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\",",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': '', 'example_language': 'Java'}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': '', 'example_language': 'Java'}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "\"example_language\": \"Java\"",
      "mutated_line": "paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': ''}}",
      "code": "def compare_paradigms(paradigm):\n    \"\"\"\n    Compare the four primary programming paradigms: Imperative, Declarative, Functional, and Object-Oriented.\n\n    Args:\n        paradigm (str): The name of the paradigm to compare.\n\n    Returns:\n        dict: A dictionary containing the description, most effective use case, least effective use case, and example language for the specified paradigm.\n    \"\"\"\n    paradigms = {'Imperative': {'description': 'A sequence of instructions that change the state of the computer.', 'most_effective': 'Applications where time is a significant factor, such as video games or GUI based applications.', 'least_effective': 'Higher-level or business problems which demand abstraction.', 'example_language': 'C'}, 'Declarative': {'description': 'Specifies what the program must do, not how it should do it.', 'most_effective': 'Data-focused applications or programs, such as database management and data analysis tools.', 'least_effective': 'If you need complete control over the program’s flow and state.', 'example_language': 'SQL'}, 'Functional': {'description': 'Functions are first-class entities, taking inputs & producing outputs without internal state.', 'most_effective': 'Manipulating data and concurrent programming.', 'least_effective': 'If the problem requires stateful or imperative model.', 'example_language': 'Haskell'}, 'Object-Oriented': {'description': 'Uses instances of classes, known as objects, to carry out tasks.', 'most_effective': 'Building large, complex systems where re-usability of code and abstraction is necessary.', 'least_effective': \"Simple, straight-forward programs and data-intensive tasks that don't map naturally to objects.\", 'example_language': ''}}\n    return paradigms.get(paradigm, {})\nprint(compare_paradigms('Imperative'))"
    }
  ]
}