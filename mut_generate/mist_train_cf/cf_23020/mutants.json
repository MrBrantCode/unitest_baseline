{
  "task_id": "cf_23020",
  "entry_point": "polar_representation",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if x == 0 and y == 0:",
      "mutated_line": "if x == 0 or y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 or y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 2 - y ** 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 - y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 2 * y ** 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 * y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if x == 0 and y == 0:",
      "mutated_line": "if x != 0 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x != 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if x == 0 and y == 0:",
      "mutated_line": "if x == 0 and y != 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y != 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "theta = 0",
      "mutated_line": "theta = 1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 1\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "theta = 0",
      "mutated_line": "theta = -1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = -1\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "theta = 0",
      "mutated_line": "theta = 1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 1\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == 0 or y > 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 or y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x * 2 + y ** 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x * 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x + 2 + y ** 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x + 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 2 + y * 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y * 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 2 + (y + 2))",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + (y + 2))\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if x == 0 and y == 0:",
      "mutated_line": "if x == 1 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 1 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if x == 0 and y == 0:",
      "mutated_line": "if x == -1 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == -1 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if x == 0 and y == 0:",
      "mutated_line": "if x == 1 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 1 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if x == 0 and y == 0:",
      "mutated_line": "if x == 0 and y == 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 1:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if x == 0 and y == 0:",
      "mutated_line": "if x == 0 and y == -1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == -1:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if x == 0 and y == 0:",
      "mutated_line": "if x == 0 and y == 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 1:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x != 0 and y > 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x != 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == 0 and y >= 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y >= 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == 0 and y <= 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y <= 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == 0 and y != 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y != 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "theta = math.pi / 2",
      "mutated_line": "theta = math.pi * 2",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi * 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "theta = math.pi / 2",
      "mutated_line": "theta = math.pi // 2",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi // 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == 0 or y < 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 or y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 3 + y ** 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 3 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 1 + y ** 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 1 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 0 + y ** 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 0 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 1 + y ** 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 1 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** -2 + y ** 2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** -2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 2 + y ** 3)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 3)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 2 + y ** 1)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 1)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 2 + y ** 0)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 0)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 2 + y ** 1)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 1)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = math.sqrt(x**2 + y**2)",
      "mutated_line": "r = math.sqrt(x ** 2 + y ** -2)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** -2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == 1 and y > 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 1 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == -1 and y > 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == -1 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == 1 and y > 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 1 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == 0 and y > 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 1:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == 0 and y > -1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > -1:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif x == 0 and y > 0:",
      "mutated_line": "elif x == 0 and y > 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 1:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "theta = math.pi / 2",
      "mutated_line": "theta = math.pi / 3",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 3\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "theta = math.pi / 2",
      "mutated_line": "theta = math.pi / 1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 1\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "theta = math.pi / 2",
      "mutated_line": "theta = math.pi / 0",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 0\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "theta = math.pi / 2",
      "mutated_line": "theta = math.pi / 1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 1\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "theta = math.pi / 2",
      "mutated_line": "theta = math.pi / -2",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / -2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x != 0 and y < 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x != 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == 0 and y <= 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y <= 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == 0 and y >= 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y >= 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == 0 and y != 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y != 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "theta = -math.pi / 2",
      "mutated_line": "theta = -math.pi * 2",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi * 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "theta = -math.pi / 2",
      "mutated_line": "theta = -math.pi // 2",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi // 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x > 0 or y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 or y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == 1 and y < 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 1 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == -1 and y < 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == -1 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == 1 and y < 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 1 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == 0 and y < 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 1:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == 0 and y < -1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < -1:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif x == 0 and y < 0:",
      "mutated_line": "elif x == 0 and y < 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 1:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "theta = -math.pi / 2",
      "mutated_line": "theta = +math.pi / 2",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = +math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "theta = -math.pi / 2",
      "mutated_line": "theta = -math.pi / 3",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 3\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "theta = -math.pi / 2",
      "mutated_line": "theta = -math.pi / 1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 1\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "theta = -math.pi / 2",
      "mutated_line": "theta = -math.pi / 0",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 0\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "theta = -math.pi / 2",
      "mutated_line": "theta = -math.pi / 1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 1\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "theta = -math.pi / 2",
      "mutated_line": "theta = -math.pi / -2",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / -2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x >= 0 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x >= 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x <= 0 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x <= 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x != 0 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x != 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x > 0 and y != 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y != 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "theta = 0",
      "mutated_line": "theta = 1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 1\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "theta = 0",
      "mutated_line": "theta = -1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = -1\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "theta = 0",
      "mutated_line": "theta = 1",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 1\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x < 0 or y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 or y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x > 1 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 1 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x > -1 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > -1 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x > 1 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 1 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x > 0 and y == 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 1:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x > 0 and y == -1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == -1:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif x > 0 and y == 0:",
      "mutated_line": "elif x > 0 and y == 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 1:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x <= 0 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x <= 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x >= 0 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x >= 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x != 0 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x != 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x < 0 and y != 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y != 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 or y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x < 1 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 1 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x < -1 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < -1 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x < 1 and y == 0:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 1 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x < 0 and y == 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 1:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x < 0 and y == -1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == -1:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif x < 0 and y == 0:",
      "mutated_line": "elif x < 0 and y == 1:",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 1:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x >= 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x <= 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x != 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y >= 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y <= 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y != 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 or y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 1 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > -1 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 1 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 1:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > -1:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if x > 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 1:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x <= 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x >= 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x != 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y >= 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y <= 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y != 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 or y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 1 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < -1 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 1 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 1:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > -1:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif x < 0 and y > 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 1:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x <= 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x >= 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x != 0 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y <= 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y >= 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y != 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 1 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < -1 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 1 and y < 0:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 1:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < -1:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif x < 0 and y < 0:",
      "mutated_line": "theta = math.atan2(y, x)",
      "code": "import math\n\ndef polar_representation(x, y):\n    \"\"\"\n    This function converts a 2D point (x, y) into polar representation (r, θ) without using any trigonometric functions.\n    \n    Parameters:\n    x (int): The x-coordinate of the point, between -1000 and 1000, inclusive.\n    y (int): The y-coordinate of the point, between -1000 and 1000, inclusive.\n    \n    Returns:\n    tuple: A tuple containing the distance r from the origin to the point and the angle θ between the positive x-axis and the line connecting the origin and the point.\n    \"\"\"\n    r = math.sqrt(x ** 2 + y ** 2)\n    if x == 0 and y == 0:\n        theta = 0\n    elif x == 0 and y > 0:\n        theta = math.pi / 2\n    elif x == 0 and y < 0:\n        theta = -math.pi / 2\n    elif x > 0 and y == 0:\n        theta = 0\n    elif x < 0 and y == 0:\n        theta = math.pi\n    elif x > 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y > 0:\n        theta = math.atan2(y, x)\n    elif x < 0 and y < 1:\n        theta = math.atan2(y, x)\n    else:\n        theta = math.atan2(y, x)\n    return (r, theta)"
    }
  ]
}