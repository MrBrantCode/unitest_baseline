{
  "task_id": "cf_63810",
  "entry_point": "numDistinctIslands2",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "grid[i][j] = 0",
      "mutated_line": "grid[i][j] = 1",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 1\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "grid[i][j] = 0",
      "mutated_line": "grid[i][j] = -1",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = -1\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "grid[i][j] = 0",
      "mutated_line": "grid[i][j] = 1",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 1\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) or 0 <= j < len(grid[0]) or grid[i][j] == 1):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) or 0 <= j < len(grid[0]) or grid[i][j] == 1):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dfs(i-1, j, 'u', path)",
      "mutated_line": "dfs(i + 1, j, 'u', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i + 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dfs(i-1, j, 'u', path)",
      "mutated_line": "dfs(i * 1, j, 'u', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i * 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dfs(i-1, j, 'u', path)",
      "mutated_line": "dfs(i - 1, j, '', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, '', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dfs(i+1, j, 'd', path)",
      "mutated_line": "dfs(i - 1, j, 'd', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i - 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dfs(i+1, j, 'd', path)",
      "mutated_line": "dfs(i * 1, j, 'd', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i * 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dfs(i+1, j, 'd', path)",
      "mutated_line": "dfs(i + 1, j, '', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, '', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dfs(i, j-1, 'l', path)",
      "mutated_line": "dfs(i, j + 1, 'l', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j + 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dfs(i, j-1, 'l', path)",
      "mutated_line": "dfs(i, j * 1, 'l', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j * 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(i, j-1, 'l', path)",
      "mutated_line": "dfs(i, j - 1, '', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, '', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dfs(i, j+1, 'r', path)",
      "mutated_line": "dfs(i, j - 1, 'r', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j - 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dfs(i, j+1, 'r', path)",
      "mutated_line": "dfs(i, j * 1, 'r', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j * 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dfs(i, j+1, 'r', path)",
      "mutated_line": "dfs(i, j + 1, '', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, '', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "path.append('e')",
      "mutated_line": "path.append('')",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] != 1:",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] != 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 < i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 < i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 > i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 > i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 == i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 == i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 < j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 < j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 > j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 > j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 == j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 == j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] != 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] != 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dfs(i-1, j, 'u', path)",
      "mutated_line": "dfs(i - 2, j, 'u', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 2, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dfs(i-1, j, 'u', path)",
      "mutated_line": "dfs(i - 0, j, 'u', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 0, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dfs(i-1, j, 'u', path)",
      "mutated_line": "dfs(i - 0, j, 'u', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 0, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dfs(i-1, j, 'u', path)",
      "mutated_line": "dfs(i - -1, j, 'u', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - -1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dfs(i+1, j, 'd', path)",
      "mutated_line": "dfs(i + 2, j, 'd', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 2, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dfs(i+1, j, 'd', path)",
      "mutated_line": "dfs(i + 0, j, 'd', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 0, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dfs(i+1, j, 'd', path)",
      "mutated_line": "dfs(i + 0, j, 'd', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 0, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dfs(i+1, j, 'd', path)",
      "mutated_line": "dfs(i + -1, j, 'd', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + -1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(i, j-1, 'l', path)",
      "mutated_line": "dfs(i, j - 2, 'l', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 2, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(i, j-1, 'l', path)",
      "mutated_line": "dfs(i, j - 0, 'l', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 0, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(i, j-1, 'l', path)",
      "mutated_line": "dfs(i, j - 0, 'l', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 0, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(i, j-1, 'l', path)",
      "mutated_line": "dfs(i, j - -1, 'l', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - -1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dfs(i, j+1, 'r', path)",
      "mutated_line": "dfs(i, j + 2, 'r', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 2, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dfs(i, j+1, 'r', path)",
      "mutated_line": "dfs(i, j + 0, 'r', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 0, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dfs(i, j+1, 'r', path)",
      "mutated_line": "dfs(i, j + 0, 'r', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 0, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dfs(i, j+1, 'r', path)",
      "mutated_line": "dfs(i, j + -1, 'r', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + -1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', ''), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', ''), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', '')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', '')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == 2:",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 2:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == 0:",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == 0:",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == -1:",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == -1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (1 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (1 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (-1 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (-1 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (1 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (1 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 1 <= j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 1 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and -1 <= j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and -1 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 1 <= j < len(grid[0]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 1 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 2)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 2)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 0)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 0)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 0)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 0)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == -1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == -1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::+1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::+1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(len(grid[0])):",
      "mutated_line": "for j in range(len(grid[1])):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[1])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(len(grid[0])):",
      "mutated_line": "for j in range(len(grid[-1])):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[-1])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(len(grid[0])):",
      "mutated_line": "for j in range(len(grid[1])):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[1])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dfs(i, j, 's', path)",
      "mutated_line": "dfs(i, j, '', path)",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, '', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::-2], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-2], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::-0], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-0], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::-0], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-0], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::--1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::--1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', '').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', '').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', '').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', '').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[1]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[1]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[-1]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[-1]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1):",
      "mutated_line": "if not (0 <= i < len(grid) and 0 <= j < len(grid[1]) and (grid[i][j] == 1)):",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[1]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "shape = normalize(''.join(path))",
      "mutated_line": "shape = normalize('MUTATED'.join(path))",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize('MUTATED'.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::-1], path.replace('', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'),",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '').replace('d', 'u').replace('#', 'd'), path.replace('l', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('', '#').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('', '#').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path.replace('l', '#').replace('r', 'l').replace('#', 'r')]",
      "mutated_line": "paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '').replace('r', 'l').replace('#', 'r')]",
      "code": "def numDistinctIslands2(grid):\n\n    def dfs(i, j, direction, path):\n        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and (grid[i][j] == 1)):\n            return\n        grid[i][j] = 0\n        path.append(direction)\n        dfs(i - 1, j, 'u', path)\n        dfs(i + 1, j, 'd', path)\n        dfs(i, j - 1, 'l', path)\n        dfs(i, j + 1, 'r', path)\n        path.append('e')\n\n    def normalize(path):\n        paths = [path, path[::-1], path.replace('u', '#').replace('d', 'u').replace('#', 'd'), path.replace('l', '').replace('r', 'l').replace('#', 'r')]\n        return min(paths)\n    shapes = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(i, j, 's', path)\n                shape = normalize(''.join(path))\n                shapes.add(shape)\n    return len(shapes)"
    }
  ]
}