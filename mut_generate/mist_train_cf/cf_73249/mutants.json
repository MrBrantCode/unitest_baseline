{
  "task_id": "cf_73249",
  "entry_point": "parse_expr",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'+': (1, op.add),",
      "mutated_line": "OPERATORS = {'': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'-': (1, op.sub),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'*': (2, op.mul),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'/': (2, op.truediv),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'^': (3, op.pow),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'+': (1, op.add),",
      "mutated_line": "OPERATORS = {'+': (2, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (2, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'+': (1, op.add),",
      "mutated_line": "OPERATORS = {'+': (0, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (0, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'+': (1, op.add),",
      "mutated_line": "OPERATORS = {'+': (0, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (0, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'+': (1, op.add),",
      "mutated_line": "OPERATORS = {'+': (-1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (-1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'-': (1, op.sub),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (2, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (2, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'-': (1, op.sub),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (0, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (0, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'-': (1, op.sub),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (0, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (0, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'-': (1, op.sub),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (-1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (-1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'*': (2, op.mul),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (3, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (3, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'*': (2, op.mul),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (1, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (1, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'*': (2, op.mul),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (0, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (0, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'*': (2, op.mul),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (1, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (1, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'*': (2, op.mul),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (-2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (-2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'/': (2, op.truediv),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (3, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (3, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'/': (2, op.truediv),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (1, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (1, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'/': (2, op.truediv),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (0, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (0, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'/': (2, op.truediv),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (1, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (1, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'/': (2, op.truediv),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (-2, op.truediv), '^': (3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (-2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'^': (3, op.pow),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (4, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (4, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'^': (3, op.pow),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (2, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (2, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'^': (3, op.pow),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (0, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (0, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'^': (3, op.pow),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (1, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (1, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'^': (3, op.pow),",
      "mutated_line": "OPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (-3, op.pow)}",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (-3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "token = ''",
      "mutated_line": "token = 'MUTATED'",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = 'MUTATED'\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if char in OPERATORS or char in \"()\":",
      "mutated_line": "if char in OPERATORS and char in '()':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS and char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "token += char",
      "mutated_line": "token -= char",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token -= char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if type(token) is float:",
      "mutated_line": "if type(token) is not float:",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is not float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if char in OPERATORS or char in \"()\":",
      "mutated_line": "if char not in OPERATORS or char in '()':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char not in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if char in OPERATORS or char in \"()\":",
      "mutated_line": "if char in OPERATORS or char not in '()':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char not in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif token in OPERATORS:",
      "mutated_line": "elif token not in OPERATORS:",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token not in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if char in OPERATORS or char in \"()\":",
      "mutated_line": "if char in OPERATORS or char in '':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "token = ''",
      "mutated_line": "token = 'MUTATED'",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = 'MUTATED'\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack or stack[-1] != '(' or OPERATORS[token][0] <= OPERATORS[stack[-1]][0]:",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack or stack[-1] != '(' or OPERATORS[token][0] <= OPERATORS[stack[-1]][0]:\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif token == \")\":",
      "mutated_line": "elif token != ')':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token != ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] == '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] == '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] < OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] < OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] > OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] > OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] == OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] == OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif token == \")\":",
      "mutated_line": "elif token == '':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == '':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "while stack and stack[-1] != \"(\":",
      "mutated_line": "while stack or stack[-1] != '(':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack or stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif token == \"(\":",
      "mutated_line": "elif token != '(':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token != '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while stack and stack[-1] != \"(\":",
      "mutated_line": "while stack and stack[-1] == '(':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] == '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif token == \"(\":",
      "mutated_line": "elif token == '':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[+1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[+1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][1] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][1] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][-1] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][-1] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][1] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][1] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][1]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][1]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][-1]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][-1]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][1]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][1]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while stack and stack[-1] != \"(\":",
      "mutated_line": "while stack and stack[-1] != '':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-2] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-2] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-0] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-0] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-0] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-0] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[--1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[--1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "while stack and stack[-1] != \"(\":",
      "mutated_line": "while stack and stack[+1] != '(':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[+1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[+1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[+1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while stack and stack[-1] != \"(\":",
      "mutated_line": "while stack and stack[-2] != '(':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-2] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while stack and stack[-1] != \"(\":",
      "mutated_line": "while stack and stack[-0] != '(':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-0] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while stack and stack[-1] != \"(\":",
      "mutated_line": "while stack and stack[-0] != '(':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-0] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while stack and stack[-1] != \"(\":",
      "mutated_line": "while stack and stack[--1] != '(':",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[--1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-2]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-2]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-0]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-0]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-0]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[-0]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while (stack and stack[-1] != \"(\" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]):",
      "mutated_line": "while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[--1]][0]):",
      "code": "import math\nimport operator as op\nOPERATORS = {'+': (1, op.add), '-': (1, op.sub), '*': (2, op.mul), '/': (2, op.truediv), '^': (3, op.pow)}\n\ndef parse_expr(expression):\n\n    def parse_token(token):\n        try:\n            return float(token)\n        except ValueError:\n            return token\n\n    def tokenize(expression):\n        token = ''\n        for char in expression:\n            if char in OPERATORS or char in '()':\n                if token:\n                    yield parse_token(token)\n                    token = ''\n                yield parse_token(char)\n            else:\n                token += char\n        if token:\n            yield parse_token(token)\n\n    def shunting_yard(parsed):\n        stack = []\n        for token in parsed:\n            if type(token) is float:\n                yield token\n            elif token in OPERATORS:\n                while stack and stack[-1] != '(' and (OPERATORS[token][0] <= OPERATORS[stack[--1]][0]):\n                    yield stack.pop()\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            elif token == '(':\n                stack.append(token)\n        while stack:\n            yield stack.pop()\n    return list(shunting_yard(tokenize(expression)))"
    }
  ]
}