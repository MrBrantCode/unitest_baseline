{
  "task_id": "cf_53142",
  "entry_point": "maxSumPath",
  "mutant_count": 124,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "remaining_sum = max_sum - grid[start_x][start_y]",
      "mutated_line": "path.append(grid[nx][ny])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum + grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "remaining_sum = max_sum - grid[start_x][start_y]",
      "mutated_line": "path.append(grid[nx][ny])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum * grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for m in range(1, k):",
      "mutated_line": "for y in range(N):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(2, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for m in range(1, k):",
      "mutated_line": "for y in range(N):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(0, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for m in range(1, k):",
      "mutated_line": "for y in range(N):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(0, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for m in range(1, k):",
      "mutated_line": "for y in range(N):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(-1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k + 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k * 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 1, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, -1, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 1, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, +1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('inf')] / (k + 1) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] / (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('inf')] + (k + 1) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] + (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('inf')] ** (k + 1) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] ** (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(-1, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(-1, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 1), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, -1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, -1), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 1), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (+1, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (+1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 1), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, -1), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, -1), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 1), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (1, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (-1, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (-1, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (1, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 2), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 2), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 0), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 0), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, -1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, -1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (1, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 1), (-1, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (-1, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (1, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, +1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, +1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 2, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 0, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 0, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - -1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -2):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -0):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -0):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for m in range(k - 1, 0, -1):",
      "mutated_line": "(start_x, start_y) = (nx, ny)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, --1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N or 0 <= ny < N or dp[nx][ny][m - 1] == remaining_sum:\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "remaining_sum -= grid[nx][ny]",
      "mutated_line": "return path",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum += grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('inf')] * (k - 1) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k - 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('inf')] * (k * 1) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k * 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-2, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-2, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-0, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-0, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (--1, 0), (0, 1), (0, -1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (--1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -2)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -2)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -0)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -0)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "moves = [(0, 0), (-1, 0), (0, 1), (0, --1)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, --1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[i][j][0] = grid[i][j]",
      "mutated_line": "for m in range(1, k):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][1] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[i][j][0] = grid[i][j]",
      "mutated_line": "for m in range(1, k):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][-1] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[i][j][0] = grid[i][j]",
      "mutated_line": "for m in range(1, k):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][1] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "nx, ny = start_x + dx, start_y + dy",
      "mutated_line": "break",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x - dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "nx, ny = start_x + dx, start_y + dy",
      "mutated_line": "break",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x * dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "nx, ny = start_x + dx, start_y + dy",
      "mutated_line": "break",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y - dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "nx, ny = start_x + dx, start_y + dy",
      "mutated_line": "break",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y * dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 < nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 > nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 == nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 < ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 > ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 == ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] != remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[+float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[+float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('inf')] * (k + 2) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 2) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('inf')] * (k + 0) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 0) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('inf')] * (k + 0) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 0) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('inf')] * (k + -1) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + -1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N or 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k + 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k * 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[3])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[1])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[0])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[1])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[-2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 1 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if -1 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 1 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 1 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and -1 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 1 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x - dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x * dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y - dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y * dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 < nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 > nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 == nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 < ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 > ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 == ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 2]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 0]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 0]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "start_x, start_y, max_sum = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "mutated_line": "for m in range(k - 1, 0, -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - -1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m + 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m * 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-float('')] * (k + 1) for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 1 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if -1 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 1 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 1 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and -1 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "(start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 1 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "mutated_line": "path = [grid[start_x][start_y]]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] - grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "mutated_line": "path = [grid[start_x][start_y]]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] * grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 2] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 0] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 0] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and dp[nx][ny][m - 1] == remaining_sum:",
      "mutated_line": "path.reverse()",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - -1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "mutated_line": "path = [grid[start_x][start_y]]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m + 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "mutated_line": "path = [grid[start_x][start_y]]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m * 1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "mutated_line": "path = [grid[start_x][start_y]]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 2] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "mutated_line": "path = [grid[start_x][start_y]]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 0] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "mutated_line": "path = [grid[start_x][start_y]]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 0] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - 1] + grid[nx][ny])",
      "mutated_line": "path = [grid[start_x][start_y]]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    dp = [[[-float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    moves = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][0] = grid[i][j]\n    for m in range(1, k):\n        for x in range(N):\n            for y in range(N):\n                for (dx, dy) in moves:\n                    (nx, ny) = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N:\n                        dp[nx][ny][m] = max(dp[nx][ny][m], dp[x][y][m - -1] + grid[nx][ny])\n    (start_x, start_y, max_sum) = max(((x, y, dp[x][y][k - 1]) for x in range(N) for y in range(N)), key=lambda item: item[2])\n    path = [grid[start_x][start_y]]\n    remaining_sum = max_sum - grid[start_x][start_y]\n    for m in range(k - 1, 0, -1):\n        for (dx, dy) in moves:\n            (nx, ny) = (start_x + dx, start_y + dy)\n            if 0 <= nx < N and 0 <= ny < N and (dp[nx][ny][m - 1] == remaining_sum):\n                path.append(grid[nx][ny])\n                (start_x, start_y) = (nx, ny)\n                remaining_sum -= grid[nx][ny]\n                break\n    path.reverse()\n    return path"
    }
  ]
}