{
  "task_id": "cf_71144",
  "entry_point": "find_product_info",
  "mutant_count": 12,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price < cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price > most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cheapest_product_price = float('inf')",
      "mutated_line": "cheapest_product_price = float('')",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price < cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price > most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "most_expensive_product_price = float('-inf')",
      "mutated_line": "most_expensive_product_price = float('')",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price < cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price > most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if price < cheapest_product_price:",
      "mutated_line": "if price <= cheapest_product_price:",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price <= cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price > most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if price < cheapest_product_price:",
      "mutated_line": "if price >= cheapest_product_price:",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price >= cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price > most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if price < cheapest_product_price:",
      "mutated_line": "if price != cheapest_product_price:",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price != cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price > most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if price > most_expensive_product_price:",
      "mutated_line": "if price >= most_expensive_product_price:",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price < cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price >= most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if price > most_expensive_product_price:",
      "mutated_line": "if price <= most_expensive_product_price:",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price < cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price <= most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if price > most_expensive_product_price:",
      "mutated_line": "if price != most_expensive_product_price:",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price < cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price != most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "price = product['Price']",
      "mutated_line": "price = product['']",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['']\n            name = product['Name']\n            if price < cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price > most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "name = product['Name']",
      "mutated_line": "name = product['']",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['']\n            if price < cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price > most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('Malformed JSON data detected.')"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "raise json.JSONDecodeError(\"Malformed JSON data detected.\")",
      "mutated_line": "raise json.JSONDecodeError('')",
      "code": "import json\nfrom collections import defaultdict\n\ndef find_product_info(products_json):\n    \"\"\"\n    This function takes a JSON string of products, where each product is represented as a dictionary with 'Name' and 'Price' keys.\n    It returns the cheapest and most expensive product along with their prices.\n    The function also groups products with the same price together, sorted in lexicographical order by their names.\n    If the input JSON string is malformed, the function raises a json.JSONDecodeError.\n\n    Args:\n        products_json (str): A JSON string of products.\n\n    Returns:\n        tuple: A tuple containing the cheapest and most expensive product information, and the grouped products.\n    \"\"\"\n    try:\n        products = json.loads(products_json)\n        cheapest_product_price = float('inf')\n        cheapest_product_name = None\n        most_expensive_product_price = float('-inf')\n        most_expensive_product_name = None\n        grouped_products = defaultdict(list)\n        for product in products:\n            price = product['Price']\n            name = product['Name']\n            if price < cheapest_product_price:\n                cheapest_product_price = price\n                cheapest_product_name = name\n            if price > most_expensive_product_price:\n                most_expensive_product_price = price\n                most_expensive_product_name = name\n            grouped_products[price].append(name)\n        for product_group in grouped_products.values():\n            product_group.sort()\n        return (cheapest_product_name, cheapest_product_price, most_expensive_product_name, most_expensive_product_price, dict(grouped_products))\n    except json.JSONDecodeError:\n        raise json.JSONDecodeError('')"
    }
  ]
}