{
  "task_id": "cf_73110",
  "entry_point": "canPartitionKSubsets",
  "mutant_count": 30,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if rem != 0:",
      "mutated_line": "if rem == 0:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem == 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nums[-1] > target:",
      "mutated_line": "if nums[-1] >= target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] >= target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nums[-1] > target:",
      "mutated_line": "if nums[-1] <= target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] <= target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nums[-1] > target:",
      "mutated_line": "if nums[-1] != target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] != target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if rem != 0:",
      "mutated_line": "if rem != 1:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 1:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if rem != 0:",
      "mutated_line": "if rem != -1:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != -1:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if rem != 0:",
      "mutated_line": "if rem != 1:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 1:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return True\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return True\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return True\n    return search([0] * k)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return search([0]*k)",
      "mutated_line": "return search([0] / k)",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] / k)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return search([0]*k)",
      "mutated_line": "return search([0] + k)",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] + k)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return search([0]*k)",
      "mutated_line": "return search([0] ** k)",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] ** k)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return False\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if group + v <= target:",
      "mutated_line": "if group + v < target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v < target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if group + v <= target:",
      "mutated_line": "if group + v > target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v > target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if group + v <= target:",
      "mutated_line": "if group + v == target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v == target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "groups[i] += v",
      "mutated_line": "groups[i] -= v",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] -= v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "groups[i] -= v",
      "mutated_line": "groups[i] += v",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] += v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "if nums[-1] > target:",
      "mutated_line": "if nums[+1] > target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[+1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if group + v <= target:",
      "mutated_line": "if group - v <= target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group - v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if group + v <= target:",
      "mutated_line": "if group * v <= target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group * v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nums[-1] > target:",
      "mutated_line": "if nums[-2] > target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-2] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nums[-1] > target:",
      "mutated_line": "if nums[-0] > target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-0] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nums[-1] > target:",
      "mutated_line": "if nums[-0] > target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-0] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nums[-1] > target:",
      "mutated_line": "if nums[--1] > target:",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[--1] > target:\n        return False\n    return search([0] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return search([0]*k)",
      "mutated_line": "return search([1] * k)",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([1] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return search([0]*k)",
      "mutated_line": "return search([-1] * k)",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([-1] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return search([0]*k)",
      "mutated_line": "return search([1] * k)",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return True\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([1] * k)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def canPartitionKSubsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem != 0:\n        return False\n\n    def search(groups):\n        if not nums:\n            return True\n        v = nums.pop()\n        for (i, group) in enumerate(groups):\n            if group + v <= target:\n                groups[i] += v\n                if search(groups):\n                    return False\n                groups[i] -= v\n            if not group:\n                break\n        nums.append(v)\n        return False\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    return search([0] * k)"
    }
  ]
}