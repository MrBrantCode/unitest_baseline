{
  "task_id": "cf_29713",
  "entry_point": "largestBlackRegionBoundingBox",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_area = 0",
      "mutated_line": "max_area = 1",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 1\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_area = 0",
      "mutated_line": "max_area = -1",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = -1\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_area = 0",
      "mutated_line": "max_area = 1",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 1\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 and col < 0 and (row >= len(image)) and (col >= len(image[0])) and (image[row][col] == 0) and visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 and col < 0 and (row >= len(image)) and (col >= len(image[0])) and (image[row][col] == 0) and visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[row][col] = True",
      "mutated_line": "visited[row][col] = False",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = False\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) - dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) - dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return (1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited)) * dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return (1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited)) * dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top_left = (0, 0)",
      "mutated_line": "top_left = (1, 0)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (1, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top_left = (0, 0)",
      "mutated_line": "top_left = (-1, 0)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (-1, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top_left = (0, 0)",
      "mutated_line": "top_left = (1, 0)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (1, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top_left = (0, 0)",
      "mutated_line": "top_left = (0, 1)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 1)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top_left = (0, 0)",
      "mutated_line": "top_left = (0, -1)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, -1)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top_left = (0, 0)",
      "mutated_line": "top_left = (0, 1)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 1)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bottom_right = (0, 0)",
      "mutated_line": "bottom_right = (1, 0)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (1, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bottom_right = (0, 0)",
      "mutated_line": "bottom_right = (-1, 0)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (-1, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bottom_right = (0, 0)",
      "mutated_line": "bottom_right = (1, 0)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (1, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bottom_right = (0, 0)",
      "mutated_line": "bottom_right = (0, 1)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 1)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bottom_right = (0, 0)",
      "mutated_line": "bottom_right = (0, -1)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, -1)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bottom_right = (0, 0)",
      "mutated_line": "bottom_right = (0, 1)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 1)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row <= 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row <= 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row >= 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row >= 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row != 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row != 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col <= 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col <= 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col >= 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col >= 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col != 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col != 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row > len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row > len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row < len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row < len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row == len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row == len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col > len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col > len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col < len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col < len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col == len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col == len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] != 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] != 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 1\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return -1\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 1\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) - dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) - dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return (1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited)) * dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return (1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited)) * dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]",
      "mutated_line": "visited = [[True for _ in range(len(image[0]))] for _ in range(len(image))]",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[True for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if image[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if image[i][j] == 1 or not visited[i][j]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 or not visited[i][j]:\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 1 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 1 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < -1 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < -1 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 1 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 1 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 1 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 1 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < -1 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < -1 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 1 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 1 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 1) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 1) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == -1) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == -1) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 1) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 1) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) - dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) - dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return (1 + dfs(row + 1, col, visited)) * dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return (1 + dfs(row + 1, col, visited)) * dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col + 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col + 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col * 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col * 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if image[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if image[i][j] != 1 and (not visited[i][j]):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] != 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if area > max_area:",
      "mutated_line": "if area >= max_area:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area >= max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if area > max_area:",
      "mutated_line": "if area <= max_area:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area <= max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if area > max_area:",
      "mutated_line": "if area != max_area:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area != max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 - dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 - dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 * dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 * dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col - 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col - 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col * 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col * 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 2, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 2, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 0, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 0, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 0, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 0, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - -1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - -1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(len(image[0])):",
      "mutated_line": "for j in range(len(image[1])):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[1])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(len(image[0])):",
      "mutated_line": "for j in range(len(image[-1])):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[-1])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(len(image[0])):",
      "mutated_line": "for j in range(len(image[1])):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[1])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if image[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if image[i][j] == 2 and (not visited[i][j]):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 2 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if image[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if image[i][j] == 0 and (not visited[i][j]):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 0 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if image[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if image[i][j] == 0 and (not visited[i][j]):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 0 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if image[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if image[i][j] == -1 and (not visited[i][j]):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == -1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col >= len(image[1])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[1])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col >= len(image[-1])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[-1])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if row < 0 or col < 0 or row >= len(image) or col >= len(image[0]) or image[row][col] == 0 or visited[row][col]:",
      "mutated_line": "if row < 0 or col < 0 or row >= len(image) or (col >= len(image[1])) or (image[row][col] == 0) or visited[row][col]:",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[1])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 2 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 2 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 0 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 0 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 0 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 0 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return -1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return -1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row + 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row + 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row * 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row * 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 2, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 2, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 0, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 0, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 0, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 0, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + -1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + -1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row - 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row - 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row * 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row * 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 2, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 2, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 0, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 0, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - 0, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 0, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 1, col, visited) + dfs(row - -1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - -1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]",
      "mutated_line": "visited = [[False for _ in range(len(image[1]))] for _ in range(len(image))]",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[1]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]",
      "mutated_line": "visited = [[False for _ in range(len(image[-1]))] for _ in range(len(image))]",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[-1]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]",
      "mutated_line": "visited = [[False for _ in range(len(image[1]))] for _ in range(len(image))]",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[1]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 2, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 2, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 0, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 0, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + 0, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 0, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1 + dfs(row+1, col, visited) + dfs(row-1, col, visited) + dfs(row, col+1, visited) + dfs(row, col-1, visited)",
      "mutated_line": "return 1 + dfs(row + -1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + -1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[0])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for y in range(len(image[0])):",
      "mutated_line": "for y in range(len(image[1])):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[1])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for y in range(len(image[0])):",
      "mutated_line": "for y in range(len(image[-1])):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[-1])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for y in range(len(image[0])):",
      "mutated_line": "for y in range(len(image[1])):",
      "code": "from typing import List, Tuple\n\ndef largestBlackRegionBoundingBox(image: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n\n    def dfs(row, col, visited):\n        if row < 0 or col < 0 or row >= len(image) or (col >= len(image[0])) or (image[row][col] == 0) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        return 1 + dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n    max_area = 0\n    top_left = (0, 0)\n    bottom_right = (0, 0)\n    visited = [[False for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1 and (not visited[i][j]):\n                area = dfs(i, j, visited)\n                if area > max_area:\n                    max_area = area\n                    min_row = i\n                    min_col = j\n                    max_row = i\n                    max_col = j\n                    for x in range(len(image)):\n                        for y in range(len(image[1])):\n                            if visited[x][y]:\n                                min_row = min(min_row, x)\n                                max_row = max(max_row, x)\n                                min_col = min(min_col, y)\n                                max_col = max(max_col, y)\n                    top_left = (min_row, min_col)\n                    bottom_right = (max_row, max_col)\n    return (top_left, bottom_right)"
    }
  ]
}