{
  "task_id": "cf_51004",
  "entry_point": "getNeighbors",
  "mutant_count": 115,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if not isinstance(grid, list) or not all(isinstance(i, list) for i in grid):",
      "mutated_line": "return 'Invalid input. Input has to be a 2D grid.'",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) and (not all((isinstance(i, list) for i in grid))):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) and (not 1 <= k <= n * n):",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) and (not 1 <= k <= n * n):\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return \"Invalid input. Input has to be a 2D grid.\"",
      "mutated_line": "return ''",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return ''\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return \"Invalid input. k has to be an integer and within range.\"",
      "mutated_line": "return ''",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return ''\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return \"Invalid input. Grid should only contain integers.\"",
      "mutated_line": "return ''",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return ''\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[+1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 1], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, -1], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 1], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [1, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [-1, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [1, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, +1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [1, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [-1, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [1, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 2], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 0], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 0], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, -1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [2, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [0, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [0, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [-1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 1]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, -1]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 1]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x - i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x - i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x * i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x * i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y - j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y - j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y * j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y * j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n or 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n or 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not 1 < k <= n * n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 < k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not 1 > k <= n * n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 > k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not 1 == k <= n * n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 == k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(1, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(-1, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(1, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 1): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, -1): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 1): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][1]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][-1]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][1]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(1, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(1, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(-1, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(-1, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(1, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(1, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 1): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 1): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, -1): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, -1): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 1): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 1): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "newSum = sumCache[(curi, curj)] + grid[nexti][nextj]",
      "mutated_line": "newPath = pathCache[curi, curj] + [grid[nexti][nextj]]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] - grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "newSum = sumCache[(curi, curj)] + grid[nexti][nextj]",
      "mutated_line": "newPath = pathCache[curi, curj] + [grid[nexti][nextj]]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] * grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "newPath = pathCache[(curi, curj)] + [grid[nexti][nextj]]",
      "mutated_line": "if len(newPath) > k:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] - [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "newPath = pathCache[(curi, curj)] + [grid[nexti][nextj]]",
      "mutated_line": "if len(newPath) > k:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] * [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if len(newPath) > k:   # If path too long, skip",
      "mutated_line": "if len(newPath) >= k:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) >= k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if len(newPath) > k:   # If path too long, skip",
      "mutated_line": "if len(newPath) <= k:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) <= k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if len(newPath) > k:   # If path too long, skip",
      "mutated_line": "if len(newPath) != k:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) != k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if (nexti, nextj) not in sumCache or newSum < sumCache[(nexti, nextj)]:",
      "mutated_line": "sumCache[nexti, nextj] = newSum",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache and newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-2, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-0, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-0, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[--1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -2], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -0], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -0], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, --1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 < x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 < x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 > x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 > x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 == x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 == x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 < y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 < y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 > y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 > y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 == y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 == y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not 2 <= k <= n * n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 2 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not 0 <= k <= n * n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 0 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not 0 <= k <= n * n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 0 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not -1 <= k <= n * n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not -1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not 1 <= k <= n / n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n / n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not 1 <= k <= n + n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n + n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if not isinstance(k, int) or not 1 <= k <= n*n:",
      "mutated_line": "if not isinstance(k, int) or not 1 <= k <= n ** n:",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n ** n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][1], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][-1], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][1], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [1, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [-1, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [1, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 1]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, -1]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 1]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[1][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[-1][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[1][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][1]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][1]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][-1]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][-1]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[0][1]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][1]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (nexti, nextj) not in sumCache or newSum < sumCache[(nexti, nextj)]:",
      "mutated_line": "sumCache[nexti, nextj] = newSum",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (nexti, nextj) not in sumCache or newSum < sumCache[(nexti, nextj)]:",
      "mutated_line": "sumCache[nexti, nextj] = newSum",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum <= sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (nexti, nextj) not in sumCache or newSum < sumCache[(nexti, nextj)]:",
      "mutated_line": "sumCache[nexti, nextj] = newSum",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum >= sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (nexti, nextj) not in sumCache or newSum < sumCache[(nexti, nextj)]:",
      "mutated_line": "sumCache[nexti, nextj] = newSum",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum != sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "return min((path for path in pathCache.values() if len(path)==k), key=sum)",
      "mutated_line": "return min((path for path in pathCache.values() if len(path) != k), key=sum)",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) != k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 1 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 1 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if -1 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if -1 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 1 <= x + i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 1 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x - i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x - i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x * i < n and 0 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x * i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 1 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 1 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and -1 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and -1 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 1 <= y + j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 1 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y - j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y - j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return [[x+i, y+j] for x, y in neighbors if 0 <= x+i < n and 0 <= y+j < n]",
      "mutated_line": "return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y * j < n]",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y * j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[1][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[-1][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heap = [[grid[0][0], [0, 0]]]   # value at cell, coords",
      "mutated_line": "sumCache = {(0, 0): grid[0][0]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[1][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[0][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[1][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[1][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[-1][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[-1][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords",
      "mutated_line": "pathCache = {(0, 0): [grid[1][0]]}",
      "code": "from typing import List\nimport heapq\nfrom collections import deque\n\ndef getNeighbors(i: int, j: int, n: int) -> List[List[int]]:\n    neighbors = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    return [[x + i, y + j] for (x, y) in neighbors if 0 <= x + i < n and 0 <= y + j < n]\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all((isinstance(i, list) for i in grid)):\n        return 'Invalid input. Input has to be a 2D grid.'\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n * n:\n        return 'Invalid input. k has to be an integer and within range.'\n    if any((not isinstance(i, int) for sublist in grid for i in sublist)):\n        return 'Invalid input. Grid should only contain integers.'\n    heap = [[grid[0][0], [0, 0]]]\n    sumCache = {(0, 0): grid[0][0]}\n    pathCache = {(0, 0): [grid[1][0]]}\n    while heap:\n        (curvalue, (curi, curj)) = heapq.heappop(heap)\n        for (nexti, nextj) in getNeighbors(curi, curj, n):\n            newSum = sumCache[curi, curj] + grid[nexti][nextj]\n            newPath = pathCache[curi, curj] + [grid[nexti][nextj]]\n            if len(newPath) > k:\n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[nexti, nextj]:\n                sumCache[nexti, nextj] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[nexti, nextj] = newPath\n    return min((path for path in pathCache.values() if len(path) == k), key=sum)"
    }
  ]
}