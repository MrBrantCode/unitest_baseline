{
  "task_id": "cf_39385",
  "entry_point": "ocr_decode",
  "mutant_count": 20,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[0]",
      "mutated_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[1]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[1]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[0]",
      "mutated_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[-1]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[-1]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[0]",
      "mutated_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[1]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[1]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "initial_beam = [((), 0)]",
      "mutated_line": "initial_beam = [((), 1)]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 1)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "initial_beam = [((), 0)]",
      "mutated_line": "initial_beam = [((), -1)]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), -1)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "initial_beam = [((), 0)]",
      "mutated_line": "initial_beam = [((), 1)]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 1)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "decoded_sequence = ''.join(map(str, best_sequence))",
      "mutated_line": "decoded_sequence = 'MUTATED'.join(map(str, best_sequence))",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = 'MUTATED'.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_prefix = prefix + (c,)",
      "mutated_line": "new_prefix = prefix - (c,)",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix - (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_prefix = prefix + (c,)",
      "mutated_line": "new_prefix = prefix * (c,)",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix * (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "new_score = score + log_probs[t, c]",
      "mutated_line": "new_score = score - log_probs[t, c]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score - log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "new_score = score + log_probs[t, c]",
      "mutated_line": "new_score = score * log_probs[t, c]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score * log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]",
      "mutated_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=False)[:beam_width]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=False)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[0]",
      "mutated_line": "best_sequence = max(initial_beam, key=lambda x: x[2])[0]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[2])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[0]",
      "mutated_line": "best_sequence = max(initial_beam, key=lambda x: x[0])[0]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[0])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[0]",
      "mutated_line": "best_sequence = max(initial_beam, key=lambda x: x[0])[0]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[0])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_sequence = max(initial_beam, key=lambda x: x[1])[0]",
      "mutated_line": "best_sequence = max(initial_beam, key=lambda x: x[-1])[0]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[-1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]",
      "mutated_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[2], reverse=True)[:beam_width]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[2], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]",
      "mutated_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[0], reverse=True)[:beam_width]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[0], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]",
      "mutated_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[0], reverse=True)[:beam_width]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[0], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[1], reverse=True)[:beam_width]",
      "mutated_line": "initial_beam = sorted(new_beam.items(), key=lambda x: x[-1], reverse=True)[:beam_width]",
      "code": "def ocr_decode(log_probs, beam_width):\n    (T, C) = log_probs.shape\n    initial_beam = [((), 0)]\n    for t in range(T):\n        new_beam = {}\n        for (prefix, score) in initial_beam:\n            for c in range(C):\n                new_prefix = prefix + (c,)\n                new_score = score + log_probs[t, c]\n                new_beam[new_prefix] = new_score\n        initial_beam = sorted(new_beam.items(), key=lambda x: x[-1], reverse=True)[:beam_width]\n    best_sequence = max(initial_beam, key=lambda x: x[1])[0]\n    decoded_sequence = ''.join(map(str, best_sequence))\n    return decoded_sequence"
    }
  ]
}