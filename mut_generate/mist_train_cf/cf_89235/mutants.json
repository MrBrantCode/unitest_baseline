{
  "task_id": "cf_89235",
  "entry_point": "permutation",
  "mutant_count": 20,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if len(s) > 50:",
      "mutated_line": "if len(s) >= 50:",
      "code": "def permutation(s):\n    if len(s) >= 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if len(s) > 50:",
      "mutated_line": "if len(s) <= 50:",
      "code": "def permutation(s):\n    if len(s) <= 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if len(s) > 50:",
      "mutated_line": "if len(s) != 50:",
      "code": "def permutation(s):\n    if len(s) != 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(s) > 50:",
      "mutated_line": "if len(s) > 51:",
      "code": "def permutation(s):\n    if len(s) > 51:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(s) > 50:",
      "mutated_line": "if len(s) > 49:",
      "code": "def permutation(s):\n    if len(s) > 49:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(s) > 50:",
      "mutated_line": "if len(s) > 0:",
      "code": "def permutation(s):\n    if len(s) > 0:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(s) > 50:",
      "mutated_line": "if len(s) > 1:",
      "code": "def permutation(s):\n    if len(s) > 1:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(s) > 50:",
      "mutated_line": "if len(s) > -50:",
      "code": "def permutation(s):\n    if len(s) > -50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return \"Input string too long\"",
      "mutated_line": "return ''",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return ''\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "backtrack(s, \"\")",
      "mutated_line": "backtrack(s, 'MUTATED')",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation + s[i])\n    backtrack(s, 'MUTATED')\n    return list(unique_permutations)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] - s[i + 1:], current_permutation + s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] - s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] * s[i + 1:], current_permutation + s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] * s[i + 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] + s[i + 1:], current_permutation - s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation - s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] + s[i + 1:], current_permutation * s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 1:], current_permutation * s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] + s[i - 1:], current_permutation + s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i - 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] + s[i * 1:], current_permutation + s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i * 1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] + s[i + 2:], current_permutation + s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 2:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] + s[i + 0:], current_permutation + s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 0:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] + s[i + 0:], current_permutation + s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + 0:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "backtrack(s[:i] + s[i+1:], current_permutation + s[i])",
      "mutated_line": "backtrack(s[:i] + s[i + -1:], current_permutation + s[i])",
      "code": "def permutation(s):\n    if len(s) > 50:\n        return 'Input string too long'\n    unique_permutations = set()\n\n    def backtrack(s, current_permutation):\n        if not s:\n            unique_permutations.add(current_permutation)\n        else:\n            for i in range(len(s)):\n                backtrack(s[:i] + s[i + -1:], current_permutation + s[i])\n    backtrack(s, '')\n    return list(unique_permutations)"
    }
  ]
}