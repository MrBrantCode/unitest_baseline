{
  "task_id": "cf_85805",
  "entry_point": "rearrange_two_operations",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def rearrange_two_operations(arr, bit_shift_allowed=True):",
      "mutated_line": "def rearrange_two_operations(arr, bit_shift_allowed=False):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=False):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if len(arr) == 0 or is_sorted(arr):",
      "mutated_line": "if len(arr) == 0 and is_sorted(arr):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 and is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first % 2 == 0:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 == 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(arr) == 0 or is_sorted(arr):",
      "mutated_line": "if len(arr) != 0 or is_sorted(arr):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) != 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return False\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "first_element = arr[0]",
      "mutated_line": "less_than_first = sum((1 for x in arr if x < first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[1]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "first_element = arr[0]",
      "mutated_line": "less_than_first = sum((1 for x in arr if x < first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[-1]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "first_element = arr[0]",
      "mutated_line": "less_than_first = sum((1 for x in arr if x < first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[1]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first * 2 != 0:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first * 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first + 2 != 0:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first + 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first % 2 != 1:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 1:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first % 2 != -1:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != -1:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first % 2 != 1:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 1:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return True\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(arr) == 0 or is_sorted(arr):",
      "mutated_line": "if len(arr) == 1 or is_sorted(arr):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 1 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(arr) == 0 or is_sorted(arr):",
      "mutated_line": "if len(arr) == -1 or is_sorted(arr):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == -1 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(arr) == 0 or is_sorted(arr):",
      "mutated_line": "if len(arr) == 1 or is_sorted(arr):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 1 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "less_than_first = sum(1 for x in arr if x < first_element)",
      "mutated_line": "less_than_first = sum((2 for x in arr if x < first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((2 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "less_than_first = sum(1 for x in arr if x < first_element)",
      "mutated_line": "less_than_first = sum((0 for x in arr if x < first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((0 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "less_than_first = sum(1 for x in arr if x < first_element)",
      "mutated_line": "less_than_first = sum((0 for x in arr if x < first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((0 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "less_than_first = sum(1 for x in arr if x < first_element)",
      "mutated_line": "less_than_first = sum((-1 for x in arr if x < first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((-1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first % 3 != 0:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 3 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first % 1 != 0:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 1 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first % 0 != 0:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 0 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first % 1 != 0:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 1 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if less_than_first % 2 != 0:",
      "mutated_line": "if less_than_first % -2 != 0:",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % -2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(arr)):",
      "mutated_line": "for j in range(i - 1, len(arr)):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i - 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(arr)):",
      "mutated_line": "for j in range(i * 1, len(arr)):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i * 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] - arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] - arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = (arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]]) * arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = (arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]]) * arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] < arr[i + 1] for i in range(len(arr) - 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] < arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] > arr[i + 1] for i in range(len(arr) - 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] > arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] == arr[i + 1] for i in range(len(arr) - 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] == arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "less_than_first = sum(1 for x in arr if x < first_element)",
      "mutated_line": "less_than_first = sum((1 for x in arr if x <= first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x <= first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "less_than_first = sum(1 for x in arr if x < first_element)",
      "mutated_line": "less_than_first = sum((1 for x in arr if x >= first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x >= first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "less_than_first = sum(1 for x in arr if x < first_element)",
      "mutated_line": "less_than_first = sum((1 for x in arr if x != first_element))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x != first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(arr)):",
      "mutated_line": "for j in range(i + 2, len(arr)):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 2, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(arr)):",
      "mutated_line": "for j in range(i + 0, len(arr)):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 0, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(arr)):",
      "mutated_line": "for j in range(i + 0, len(arr)):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 0, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(arr)):",
      "mutated_line": "for j in range(i + -1, len(arr)):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + -1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] - [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] - [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = (arr[:i] + [arr[j]] + arr[i + 1:j]) * [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = (arr[:i] + [arr[j]] + arr[i + 1:j]) * [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return False\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] - arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] - arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = (arr[:i] + [arr[j]]) * arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = (arr[:i] + [arr[j]]) * arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i - 1] for i in range(len(arr) - 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i - 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i * 1] for i in range(len(arr) - 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i * 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + 1] for i in range(len(arr) + 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) + 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + 1] for i in range(len(arr) * 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) * 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] - [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] - [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] * [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] * [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j - 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j - 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j * 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j * 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for shift in range(1, 32):",
      "mutated_line": "for shift in range(2, 32):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(2, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for shift in range(1, 32):",
      "mutated_line": "for shift in range(0, 32):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(0, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for shift in range(1, 32):",
      "mutated_line": "for shift in range(0, 32):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(0, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for shift in range(1, 32):",
      "mutated_line": "for shift in range(-1, 32):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(-1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for shift in range(1, 32):",
      "mutated_line": "for shift in range(1, 33):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 33):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for shift in range(1, 32):",
      "mutated_line": "for shift in range(1, 31):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 31):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for shift in range(1, 32):",
      "mutated_line": "for shift in range(1, 0):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 0):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for shift in range(1, 32):",
      "mutated_line": "for shift in range(1, 1):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 1):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for shift in range(1, 32):",
      "mutated_line": "for shift in range(1, -32):",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, -32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] - swapped_arr[k + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] - swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = (swapped_arr[:k] + [swapped_arr[k] >> shift]) * swapped_arr[k + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = (swapped_arr[:k] + [swapped_arr[k] >> shift]) * swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] - swapped_arr[k + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] - swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = (swapped_arr[:k] + [swapped_arr[k] << shift]) * swapped_arr[k + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = (swapped_arr[:k] + [swapped_arr[k] << shift]) * swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + 2] for i in range(len(arr) - 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 2] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + 0] for i in range(len(arr) - 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 0] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + 0] for i in range(len(arr) - 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 0] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + -1] for i in range(len(arr) - 1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + -1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 2)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 2)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 0)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 0)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 0)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 0)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",
      "mutated_line": "return all((arr[i] <= arr[i + 1] for i in range(len(arr) - -1)))",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - -1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 2:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 2:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 0:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 0:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 0:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 0:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + -1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + -1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] - [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] - [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] * [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] * [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return False\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] - [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] - [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] * [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] * [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return False\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i - 1:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i - 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i * 1:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i * 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 2:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 2:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 0:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 0:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 0:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 0:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]",
      "mutated_line": "swapped_arr = arr[:i] + [arr[j]] + arr[i + -1:j] + [arr[i]] + arr[j + 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + -1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k - 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k - 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k * 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k * 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k - 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k - 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k * 1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k * 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 2:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 2:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 0:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 0:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 0:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 0:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + -1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + -1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 2:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 2:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 0:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 0:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 0:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 0:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + 1:]",
      "mutated_line": "shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + -1:]",
      "code": "def rearrange_two_operations(arr, bit_shift_allowed=True):\n    \"\"\"\n    Given an array 'arr' comprising N integers arr[1], arr[2], ..., arr[N]. The integers within the array\n    are randomly ordered. The goal is to determine if it's feasible to obtain a sorted, non-decreasing array by\n    following these steps:\n        1. Use a swap operation to exchange exactly a pair of elements in the array.\n        2. If permitted and needed, execute a bit-level shift operation on exactly one element.\n         - A right shift operation (x >> y) divides x by 2^y\n         - A left shift operation (x << y) multiplies x by 2^y\n        3. The total number of performed operations(minimal swaps and maximal bit-level shifts) must not exceed two.\n\n    The function should return True if it's feasible to obtain the sorted array and False if it's not.\n    For an empty array, the function should also return True.\n\n    Note: The list can contain distinct or identical elements. The bit-level shift operation is optional \n    and can be turned off by setting the 'bit_shift_allowed' parameter to 'False'.\n\n    \"\"\"\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if len(arr) == 0 or is_sorted(arr):\n        return True\n    first_element = arr[0]\n    less_than_first = sum((1 for x in arr if x < first_element))\n    if less_than_first % 2 != 0:\n        return False\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:i] + [arr[j]] + arr[i + 1:j] + [arr[i]] + arr[j + 1:]\n            if is_sorted(swapped_arr):\n                return True\n            if bit_shift_allowed:\n                for k in range(len(swapped_arr)):\n                    for shift in range(1, 32):\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] >> shift] + swapped_arr[k + 1:]\n                        if is_sorted(shifted_arr):\n                            return True\n                        shifted_arr = swapped_arr[:k] + [swapped_arr[k] << shift] + swapped_arr[k + -1:]\n                        if is_sorted(shifted_arr):\n                            return True\n    return False"
    }
  ]
}