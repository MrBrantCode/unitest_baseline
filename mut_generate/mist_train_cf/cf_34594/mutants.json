{
  "task_id": "cf_34594",
  "entry_point": "propIR",
  "mutant_count": 111,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = 2 * np.pi * wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi * wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = 2 * np.pi // wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi // wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L * 2.0, L / 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L * 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L // 2.0, L / 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L // 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 2.0, L / 2.0 + step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 + step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 2.0, L / 2.0 * step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 * step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L * 2.0, L / 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L * 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L // 2.0, L / 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L // 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 2.0, L / 2.0 + step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 + step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 2.0, L / 2.0 * step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 * step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = 2 / np.pi / wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 / np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = (2 + np.pi) / wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = (2 + np.pi) / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = 2 ** np.pi / wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 ** np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(+L / 2.0, L / 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(+L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 3.0, L / 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 3.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 1.0, L / 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 1.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 0, L / 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 1, L / 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 1, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / -2.0, L / 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / -2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 2.0, L * 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L * 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 2.0, L // 2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L // 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(+L / 2.0, L / 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(+L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 3.0, L / 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 3.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 1.0, L / 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 1.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 0, L / 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 1, L / 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 1, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / -2.0, L / 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / -2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 2.0, L * 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L * 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 2.0, L // 2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L // 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = 3 * np.pi / wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 3 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = 1 * np.pi / wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 1 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = 0 * np.pi / wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 0 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = 1 * np.pi / wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 1 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "k = 2 * np.pi / wavel",
      "mutated_line": "k = -2 * np.pi / wavel",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = -2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) / step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) / step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) + step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) + step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) ** step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) ** step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) / integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) / integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) + integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) + integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) ** integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) ** integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 2.0, L / 3.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 3.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 2.0, L / 1.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 1.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 2.0, L / 0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 2.0, L / 1 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 1 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = np.linspace(-L/2.0, L/2.0-step, M)",
      "mutated_line": "x = np.linspace(-L / 2.0, L / -2.0 - step, M)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / -2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 2.0, L / 3.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 3.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 2.0, L / 1.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 1.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 2.0, L / 0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 2.0, L / 1 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 1 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = np.linspace(-L/2.0, L/2.0-step, N)",
      "mutated_line": "y = np.linspace(-L / 2.0, L / -2.0 - step, N)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / -2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * (step * 2)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * (step * 2)\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * (step + 2)",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * (step + 2)\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) * (1j * wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) * (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) // (1j * wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) // (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 3",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 3\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 1",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 1\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 0",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 0\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 1",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 1\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** -2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** -2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) / (1j * wavel / z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel / z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) / (1j * wavel + z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel + z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) / (1j * wavel) ** z * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel) ** z * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u / np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u / np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u + np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u + np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u ** np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u ** np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k / z) / (1j * wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k / z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k + z) / (1j * wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k + z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp((1j * k) ** z) / (1j * wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp((1j * k) ** z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) / (1j / wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j / wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) / ((1j + wavel) * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / ((1j + wavel) * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j * k * z) / (1j ** wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j ** wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j / k * z) / (1j * wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j / k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp((1j + k) * z) / (1j * wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp((1j + k) * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "u_out[i, j] = (np.exp(1j * k * z) / (1j * wavel * z)) * integral",
      "mutated_line": "u_out[i, j] = np.exp(1j ** k * z) / (1j * wavel * z) * integral",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j ** k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) / ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) / ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) + ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) + ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp((-1j * k / (2 * z)) ** ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp((-1j * k / (2 * z)) ** ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k * (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k * (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k // (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k // (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 - (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 - (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 * (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 * (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j / k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j / k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp((-1j + k) / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp((-1j + k) / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp((-1j) ** k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp((-1j) ** k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 / z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 / z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 + z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 + z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / 2 ** z * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / 2 ** z * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) * 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) * 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * (X - x[i] + 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * (X - x[i] + 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) * 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) * 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j] + 2))))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j] + 2))))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(+1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(+1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (3 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (3 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (1 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (1 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (0 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (0 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (1 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (1 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (-2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (-2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X + x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X + x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X * x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X * x[i]) ** 2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 3 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 3 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 1 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 1 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 0 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 0 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 1 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 1 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** -2 + (Y - y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** -2 + (Y - y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y + y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y + y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y * y[j]) ** 2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y * y[j]) ** 2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 3)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 3)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 1)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 1)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 0)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 0)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 1)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** 1)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i])**2 + (Y - y[j])**2)))) * step**2",
      "mutated_line": "integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** -2)))) * step ** 2",
      "code": "import numpy as np\n\ndef propIR(u, step, L, wavel, z):\n    (M, N) = np.shape(u)\n    x = np.linspace(-L / 2.0, L / 2.0 - step, M)\n    y = np.linspace(-L / 2.0, L / 2.0 - step, N)\n    (X, Y) = np.meshgrid(x, y)\n    k = 2 * np.pi / wavel\n    u_out = np.zeros_like(u, dtype=np.complex128)\n    for i in range(M):\n        for j in range(N):\n            integral = np.sum(np.sum(u * np.exp(-1j * k / (2 * z) * ((X - x[i]) ** 2 + (Y - y[j]) ** -2)))) * step ** 2\n            u_out[i, j] = np.exp(1j * k * z) / (1j * wavel * z) * integral\n    return u_out"
    }
  ]
}