{
  "task_id": "cf_71181",
  "entry_point": "shortestDistance",
  "mutant_count": 146,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if tuple(destination) in visited:   # if the destination is reached",
      "mutated_line": "if tuple(destination) not in visited:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) not in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {tuple(start): 0}",
      "mutated_line": "visited = {tuple(start): 1}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 1}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {tuple(start): 0}",
      "mutated_line": "visited = {tuple(start): -1}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): -1}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {tuple(start): 0}",
      "mutated_line": "visited = {tuple(start): 1}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 1}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[2], tuple(portals[1]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[2], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[0], tuple(portals[1]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[0], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[0], tuple(portals[1]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[0], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[-1], tuple(portals[1]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[-1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[1]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[1]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[-1]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[-1]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[1]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[1]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) or 0 <= y + d[1] < len(maze[0]) or maze[x + d[0]][y + d[1]] != 1:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) or 0 <= y + d[1] < len(maze[0]) or maze[x + d[0]][y + d[1]] != 1:\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "x += d[0]",
      "mutated_line": "x -= d[0]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x -= d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "y += d[1]",
      "mutated_line": "y -= d[1]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y -= d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "tmp += 1    # the distance increases",
      "mutated_line": "tmp -= 1",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp -= 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if (x, y) not in visited or dist+tmp<visited[(x, y)]:  # if it's a new position or we find a shorter path",
      "mutated_line": "if (x, y) not in visited and dist + tmp < visited[x, y]:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited and dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return --1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]  # right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = deque([(start, 0)])  # position and distance",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 1)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = deque([(start, 0)])  # position and distance",
      "mutated_line": "queue = deque([(start, -1)])",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, -1)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = deque([(start, 0)])  # position and distance",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 1)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[1]): portals[1], tuple(portals[1]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[1]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[-1]): portals[1], tuple(portals[1]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[-1]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[1]): portals[1], tuple(portals[1]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[1]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[2]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[2]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[0]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[0]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[0]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[0]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}",
      "mutated_line": "portal_dict = {tuple(portals[0]): portals[1], tuple(portals[-1]): portals[0]}",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[-1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[0], position[1], 1)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 1)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[0], position[1], -1)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], -1)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[0], position[1], 1)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 1)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 < x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 < x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 > x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 > x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 == x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 == x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 < y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 < y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 > y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 > y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 == y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 == y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] == 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] == 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += 1    # the distance increases",
      "mutated_line": "tmp += 2",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 2\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += 1    # the distance increases",
      "mutated_line": "tmp += 0",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 0\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += 1    # the distance increases",
      "mutated_line": "tmp += 0",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 0\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += 1    # the distance increases",
      "mutated_line": "tmp += -1",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += -1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if maze[x][y]==2:   # a portal",
      "mutated_line": "if maze[x][y] != 2:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] != 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "tmp += 1   # teleport counts additional 1 distance",
      "mutated_line": "tmp -= 1",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp -= 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (x, y) not in visited or dist+tmp<visited[(x, y)]:  # if it's a new position or we find a shorter path",
      "mutated_line": "if (x, y) in visited or dist + tmp < visited[x, y]:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (x, y) not in visited or dist+tmp<visited[(x, y)]:  # if it's a new position or we find a shorter path",
      "mutated_line": "if (x, y) not in visited or dist + tmp <= visited[x, y]:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp <= visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (x, y) not in visited or dist+tmp<visited[(x, y)]:  # if it's a new position or we find a shorter path",
      "mutated_line": "if (x, y) not in visited or dist + tmp >= visited[x, y]:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp >= visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (x, y) not in visited or dist+tmp<visited[(x, y)]:  # if it's a new position or we find a shorter path",
      "mutated_line": "if (x, y) not in visited or dist + tmp != visited[x, y]:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp != visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "visited[(x, y)] = dist+tmp",
      "mutated_line": "visited[x, y] = dist - tmp",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist - tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "visited[(x, y)] = dist+tmp",
      "mutated_line": "visited[x, y] = dist * tmp",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist * tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (x, y)!=tuple(destination):   # if new position is not the destination, add it to the queue",
      "mutated_line": "if (x, y) == tuple(destination):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) == tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[1], position[1], 0)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[1], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[-1], position[1], 0)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[-1], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[1], position[1], 0)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[1], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[0], position[2], 0)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[2], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[0], position[0], 0)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[0], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[0], position[0], 0)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[0], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y, tmp = position[0], position[1], 0",
      "mutated_line": "(x, y, tmp) = (position[0], position[-1], 0)",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[-1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 1 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 1 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while -1 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while -1 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 1 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 1 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x - d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x - d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x * d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x * d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 1 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 1 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and -1 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and -1 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 1 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 1 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y - d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y - d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y * d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y * d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 2):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 2):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 0):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 0):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 0):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 0):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != -1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != -1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x += d[0]",
      "mutated_line": "x += d[1]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[1]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x += d[0]",
      "mutated_line": "x += d[-1]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[-1]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x += d[0]",
      "mutated_line": "x += d[1]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[1]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y += d[1]",
      "mutated_line": "y += d[2]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[2]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y += d[1]",
      "mutated_line": "y += d[0]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[0]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y += d[1]",
      "mutated_line": "y += d[0]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[0]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y += d[1]",
      "mutated_line": "y += d[-1]",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[-1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if maze[x][y]==2:   # a portal",
      "mutated_line": "if maze[x][y] == 3:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 3:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if maze[x][y]==2:   # a portal",
      "mutated_line": "if maze[x][y] == 1:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 1:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if maze[x][y]==2:   # a portal",
      "mutated_line": "if maze[x][y] == 0:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 0:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if maze[x][y]==2:   # a portal",
      "mutated_line": "if maze[x][y] == 1:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 1:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if maze[x][y]==2:   # a portal",
      "mutated_line": "if maze[x][y] == -2:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == -2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp += 1   # teleport counts additional 1 distance",
      "mutated_line": "tmp += 2",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 2\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp += 1   # teleport counts additional 1 distance",
      "mutated_line": "tmp += 0",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 0\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp += 1   # teleport counts additional 1 distance",
      "mutated_line": "tmp += 0",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 0\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp += 1   # teleport counts additional 1 distance",
      "mutated_line": "tmp += -1",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += -1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (x, y) not in visited or dist+tmp<visited[(x, y)]:  # if it's a new position or we find a shorter path",
      "mutated_line": "if (x, y) not in visited or dist - tmp < visited[x, y]:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist - tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (x, y) not in visited or dist+tmp<visited[(x, y)]:  # if it's a new position or we find a shorter path",
      "mutated_line": "if (x, y) not in visited or dist * tmp < visited[x, y]:",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist * tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y - d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y - d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y * d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y * d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[1] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[1] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[-1] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[-1] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[1] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[1] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[2] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[2] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[0] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[0] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[0] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[0] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[-1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[-1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[1]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[1]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[-1]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[-1]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[1]) and (maze[x + d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[1]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x - d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x - d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x * d[0]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x * d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "queue.append(((x, y), dist+tmp))",
      "mutated_line": "queue.append(((x, y), dist - tmp))",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist - tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "queue.append(((x, y), dist+tmp))",
      "mutated_line": "queue.append(((x, y), dist * tmp))",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist * tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[2]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[2]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[0]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[0]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[0]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[0]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[-1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[0]][y + d[-1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[1]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[1]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[-1]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[-1]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while 0<=x+d[0]<len(maze) and 0<=y+d[1]<len(maze[0]) and maze[x+d[0]][y+d[1]]!=1:   # while it can roll",
      "mutated_line": "while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[1]][y + d[1]] != 1):",
      "code": "from collections import deque\n\ndef shortestDistance(maze, start, destination, portals):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, 0)])\n    visited = {tuple(start): 0}\n    portal_dict = {tuple(portals[0]): portals[1], tuple(portals[1]): portals[0]}\n    while queue:\n        (position, dist) = queue.popleft()\n        for d in directions:\n            (x, y, tmp) = (position[0], position[1], 0)\n            while 0 <= x + d[0] < len(maze) and 0 <= y + d[1] < len(maze[0]) and (maze[x + d[1]][y + d[1]] != 1):\n                x += d[0]\n                y += d[1]\n                tmp += 1\n                if maze[x][y] == 2:\n                    (x, y) = portal_dict[x, y]\n                    tmp += 1\n                    break\n            if (x, y) not in visited or dist + tmp < visited[x, y]:\n                visited[x, y] = dist + tmp\n                if (x, y) != tuple(destination):\n                    queue.append(((x, y), dist + tmp))\n    if tuple(destination) in visited:\n        return visited[tuple(destination)]\n    else:\n        return -1"
    }
  ]
}