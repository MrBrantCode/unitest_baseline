{
  "task_id": "cf_78405",
  "entry_point": "median",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def median(l, cmp_func):\n    \"\"\"\"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length % 2 != 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 != 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "\"\"\"Flattens a nested list/tuple\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) != 1:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) != 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if k < len(left):",
      "mutated_line": "if k <= len(left):",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k <= len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if k < len(left):",
      "mutated_line": "if k >= len(left):",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k >= len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if k < len(left):",
      "mutated_line": "if k != len(left):",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k != len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length * 2 == 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length * 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length + 2 == 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length + 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length % 2 == 1:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 1:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length % 2 == -1:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == -1:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length % 2 == 1:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 1:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) * 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) * 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) // 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) // 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == 2:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 2:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 0:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 0:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == -1:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == -1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) / 2]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) / 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) * 2]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) * 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif k < len(left) + len(middle):",
      "mutated_line": "elif k <= len(left) + len(middle):",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k <= len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif k < len(left) + len(middle):",
      "mutated_line": "elif k >= len(left) + len(middle):",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k >= len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif k < len(left) + len(middle):",
      "mutated_line": "elif k != len(left) + len(middle):",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k != len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length % 3 == 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 3 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length % 1 == 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 1 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length % 0 == 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 0 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length % 1 == 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 1 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if length % 2 == 0:",
      "mutated_line": "if length % -2 == 0:",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % -2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 2 + 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 + 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 2 * 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 * 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "median2 = quickselect(flat_list, length // 2)",
      "mutated_line": "median2 = quickselect(flat_list, length / 2)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length / 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "median2 = quickselect(flat_list, length // 2)",
      "mutated_line": "median2 = quickselect(flat_list, length * 2)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length * 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) - cmp_func(median2, 0)) / 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) - cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = cmp_func(median1, 0) * cmp_func(median2, 0) / 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = cmp_func(median1, 0) * cmp_func(median2, 0) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 3",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 3\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 1",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 1\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 0",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 0\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 1",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 1\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / -2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / -2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length // 2), 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 1)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length // 2), -1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), -1)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length // 2), 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 1)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[1]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[-1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[-1]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[1]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // 3]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 3]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // 1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 1]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // 0]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 0]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // 1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 1]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // -2]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // -2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "left = [x for x in lst if cmp_func(x, pivot) < 0]",
      "mutated_line": "left = [x for x in lst if cmp_func(x, pivot) <= 0]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) <= 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "left = [x for x in lst if cmp_func(x, pivot) < 0]",
      "mutated_line": "left = [x for x in lst if cmp_func(x, pivot) >= 0]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) >= 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "left = [x for x in lst if cmp_func(x, pivot) < 0]",
      "mutated_line": "left = [x for x in lst if cmp_func(x, pivot) != 0]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) != 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "middle = [x for x in lst if cmp_func(x, pivot) == 0]",
      "mutated_line": "middle = [x for x in lst if cmp_func(x, pivot) != 0]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) != 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "right = [x for x in lst if cmp_func(x, pivot) > 0]",
      "mutated_line": "right = [x for x in lst if cmp_func(x, pivot) >= 0]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) >= 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "right = [x for x in lst if cmp_func(x, pivot) > 0]",
      "mutated_line": "right = [x for x in lst if cmp_func(x, pivot) <= 0]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) <= 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "right = [x for x in lst if cmp_func(x, pivot) > 0]",
      "mutated_line": "right = [x for x in lst if cmp_func(x, pivot) != 0]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) != 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "elif k < len(left) + len(middle):",
      "mutated_line": "elif k < len(left) - len(middle):",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) - len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "elif k < len(left) + len(middle):",
      "mutated_line": "elif k < len(left) * len(middle):",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) * len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length / 2 - 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length / 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length * 2 - 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length * 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 2 - 2)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 2)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 2 - 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 0)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 2 - 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 0)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 2 - -1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - -1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "median2 = quickselect(flat_list, length // 2)",
      "mutated_line": "median2 = quickselect(flat_list, length // 3)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 3)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "median2 = quickselect(flat_list, length // 2)",
      "mutated_line": "median2 = quickselect(flat_list, length // 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 1)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "median2 = quickselect(flat_list, length // 2)",
      "mutated_line": "median2 = quickselect(flat_list, length // 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 0)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "median2 = quickselect(flat_list, length // 2)",
      "mutated_line": "median2 = quickselect(flat_list, length // 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 1)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "median2 = quickselect(flat_list, length // 2)",
      "mutated_line": "median2 = quickselect(flat_list, length // -2)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // -2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length / 2), 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length / 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length * 2), 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length * 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = [x for x in lst if cmp_func(x, pivot) < 0]",
      "mutated_line": "left = [x for x in lst if cmp_func(x, pivot) < 1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 1]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = [x for x in lst if cmp_func(x, pivot) < 0]",
      "mutated_line": "left = [x for x in lst if cmp_func(x, pivot) < -1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < -1]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = [x for x in lst if cmp_func(x, pivot) < 0]",
      "mutated_line": "left = [x for x in lst if cmp_func(x, pivot) < 1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 1]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "middle = [x for x in lst if cmp_func(x, pivot) == 0]",
      "mutated_line": "middle = [x for x in lst if cmp_func(x, pivot) == 1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 1]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "middle = [x for x in lst if cmp_func(x, pivot) == 0]",
      "mutated_line": "middle = [x for x in lst if cmp_func(x, pivot) == -1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == -1]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "middle = [x for x in lst if cmp_func(x, pivot) == 0]",
      "mutated_line": "middle = [x for x in lst if cmp_func(x, pivot) == 1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 1]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = [x for x in lst if cmp_func(x, pivot) > 0]",
      "mutated_line": "right = [x for x in lst if cmp_func(x, pivot) > 1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 1]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = [x for x in lst if cmp_func(x, pivot) > 0]",
      "mutated_line": "right = [x for x in lst if cmp_func(x, pivot) > -1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > -1]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = [x for x in lst if cmp_func(x, pivot) > 0]",
      "mutated_line": "right = [x for x in lst if cmp_func(x, pivot) > 1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 1]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return middle[0]",
      "mutated_line": "return middle[1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[1]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return middle[0]",
      "mutated_line": "return middle[-1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[-1]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return middle[0]",
      "mutated_line": "return middle[1]",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[1]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return quickselect(right, k - len(left) - len(middle))",
      "mutated_line": "return quickselect(right, k - len(left) + len(middle))",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) + len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return quickselect(right, k - len(left) - len(middle))",
      "mutated_line": "return quickselect(right, (k - len(left)) * len(middle))",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, (k - len(left)) * len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 3 - 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 3 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 1 - 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 1 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 0 - 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 0 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // 1 - 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 1 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "median1 = quickselect(flat_list, length // 2 - 1)",
      "mutated_line": "median1 = quickselect(flat_list, length // -2 - 1)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // -2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 1) + cmp_func(median2, 0)) / 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 1) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, -1) + cmp_func(median2, 0)) / 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, -1) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 1) + cmp_func(median2, 0)) / 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 1) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 1)) / 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 1)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, -1)) / 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, -1)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2",
      "mutated_line": "median = (cmp_func(median1, 0) + cmp_func(median2, 1)) / 2",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 1)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length // 3), 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 3), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length // 1), 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 1), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length // 0), 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 0), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length // 1), 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 1), 0)\n    return median"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "median = cmp_func(quickselect(flat_list, length // 2), 0)",
      "mutated_line": "median = cmp_func(quickselect(flat_list, length // -2), 0)",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k - len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // -2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return quickselect(right, k - len(left) - len(middle))",
      "mutated_line": "return quickselect(right, k + len(left) - len(middle))",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k + len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return quickselect(right, k - len(left) - len(middle))",
      "mutated_line": "return quickselect(right, k * len(left) - len(middle))",
      "code": "def median(l, cmp_func):\n    \"\"\"\n    Returns the median of nested list and tuple elements in 'l' avoiding sorting or inbuilt functions.\n    Handles duplicates, tuples characterized by even and uneven number, employs cmp_func for comparison.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flattens a nested list/tuple\"\"\"\n        flat_list = []\n        for val in lst:\n            if isinstance(val, (list, tuple)):\n                flat_list.extend(flatten(val))\n            else:\n                flat_list.append(val)\n        return flat_list\n    flat_list = flatten(l)\n    length = len(flat_list)\n\n    def quickselect(lst, k):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if cmp_func(x, pivot) < 0]\n        middle = [x for x in lst if cmp_func(x, pivot) == 0]\n        right = [x for x in lst if cmp_func(x, pivot) > 0]\n        if k < len(left):\n            return quickselect(left, k)\n        elif k < len(left) + len(middle):\n            return middle[0]\n        else:\n            return quickselect(right, k * len(left) - len(middle))\n    if length % 2 == 0:\n        median1 = quickselect(flat_list, length // 2 - 1)\n        median2 = quickselect(flat_list, length // 2)\n        median = (cmp_func(median1, 0) + cmp_func(median2, 0)) / 2\n    else:\n        median = cmp_func(quickselect(flat_list, length // 2), 0)\n    return median"
    }
  ]
}