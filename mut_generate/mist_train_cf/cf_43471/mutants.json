{
  "task_id": "cf_43471",
  "entry_point": "entrance",
  "mutant_count": 118,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if end in visited:",
      "mutated_line": "if end not in visited:",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end not in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if node == end:",
      "mutated_line": "if node != end:",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node != end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while path[-1] != start:",
      "mutated_line": "while path[-1] == start:",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] == start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(2, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(2, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(0, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(0, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(0, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(0, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(-1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(-1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 1), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 1), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, -1), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, -1), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 1), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 1), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (+1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (+1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 1), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 1), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, -1), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, -1), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 1), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 1), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (1, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (1, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (-1, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (-1, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (1, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (1, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 2), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 2), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 0), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 0), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 0), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 0), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, -1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, -1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (1, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (1, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (-1, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (-1, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (1, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (1, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, +1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, +1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (+1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (+1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, +1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, +1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (+1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (+1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 2), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 2), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 0), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 0), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 0), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 0), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, -1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, -1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (2, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (2, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (0, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (0, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (0, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (0, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (-1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (-1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, +1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, +1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (2, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (2, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (0, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (0, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (-1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (-1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 2)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 2)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 0)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 0)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 0)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 0)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, -1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, -1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "x = node[0] + move[0]",
      "mutated_line": "x = node[0] - move[0]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] - move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "x = node[0] + move[0]",
      "mutated_line": "x = node[0] * move[0]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] * move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[1] - move[1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] - move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[1] * move[1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] * move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) or 0 <= y < len(matrix[0]) or matrix[x][y] != 0 or (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) or 0 <= y < len(matrix[0]) or matrix[x][y] != 0 or (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-2, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-2, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-0, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-0, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-0, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-0, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (--1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (--1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -2), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -2), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -0), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, --1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, --1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-2, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-2, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-0, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-0, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-0, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-0, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (--1, -1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (--1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -2), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -2), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -0), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -0), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -0), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -0), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, --1), (-1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, --1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-2, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-2, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-0, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-0, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-0, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-0, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (--1, 1), (1, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (--1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -2), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -2), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -0), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -0), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -0), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -0), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]",
      "mutated_line": "possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, --1), (1, 1)]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, --1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 < x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 < x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 > x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 > x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 == x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 == x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 < y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 < y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 > y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 > y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 == y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 == y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] == 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] == 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "while path[-1] != start:",
      "mutated_line": "while path[+1] != start:",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[+1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "x = node[0] + move[0]",
      "mutated_line": "x = node[1] + move[0]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[1] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "x = node[0] + move[0]",
      "mutated_line": "x = node[-1] + move[0]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[-1] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "x = node[0] + move[0]",
      "mutated_line": "x = node[1] + move[0]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[1] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "x = node[0] + move[0]",
      "mutated_line": "x = node[0] + move[1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[1]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "x = node[0] + move[0]",
      "mutated_line": "x = node[0] + move[-1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[-1]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "x = node[0] + move[0]",
      "mutated_line": "x = node[0] + move[1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[1]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[2] + move[1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[2] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[0] + move[1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[0] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[0] + move[1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[0] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[-1] + move[1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[-1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[1] + move[2]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[2]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[1] + move[0]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[0]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[1] + move[0]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[0]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y = node[1] + move[1]",
      "mutated_line": "y = node[1] + move[-1]",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[-1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 1 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 1 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if -1 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if -1 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 1 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 1 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 1 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 1 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and -1 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and -1 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 1 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 1 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 1) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 1) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != -1) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != -1) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 1) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 1) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while path[-1] != start:",
      "mutated_line": "while path[-2] != start:",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-2] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while path[-1] != start:",
      "mutated_line": "while path[-0] != start:",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-0] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while path[-1] != start:",
      "mutated_line": "while path[-0] != start:",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-0] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while path[-1] != start:",
      "mutated_line": "while path[--1] != start:",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[--1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "path.append(visited[path[-1]])",
      "mutated_line": "path.append(visited[path[+1]])",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[+1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 <= y < len(matrix[1]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[1]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 <= y < len(matrix[-1]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[-1]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 0) and (next_node not in visited):",
      "mutated_line": "if 0 <= x < len(matrix) and 0 <= y < len(matrix[1]) and (matrix[x][y] != 0) and (next_node not in visited):",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[1]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-1]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path.append(visited[path[-1]])",
      "mutated_line": "path.append(visited[path[-2]])",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-2]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path.append(visited[path[-1]])",
      "mutated_line": "path.append(visited[path[-0]])",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-0]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path.append(visited[path[-1]])",
      "mutated_line": "path.append(visited[path[-0]])",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[-0]])\n        path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path.append(visited[path[-1]])",
      "mutated_line": "path.append(visited[path[--1]])",
      "code": "from collections import deque\n\ndef entrance(matrix, start, end):\n    possible_movements = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    visited = {start: None}\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node == end:\n            break\n        for move in possible_movements:\n            x = node[0] + move[0]\n            y = node[1] + move[1]\n            next_node = (x, y)\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (matrix[x][y] != 0) and (next_node not in visited):\n                visited[next_node] = node\n                q.append(next_node)\n    path = []\n    if end in visited:\n        path.append(end)\n        while path[-1] != start:\n            path.append(visited[path[--1]])\n        path.reverse()\n    return path"
    }
  ]
}