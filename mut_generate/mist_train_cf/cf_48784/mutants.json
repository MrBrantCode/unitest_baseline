{
  "task_id": "cf_48784",
  "entry_point": "minPath",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "min_path = [float('inf')]*k",
      "mutated_line": "min_path = [float('inf')] / k",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] / k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "min_path = [float('inf')]*k",
      "mutated_line": "min_path = [float('inf')] + k",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] + k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "min_path = [float('inf')]*k",
      "mutated_line": "min_path = [float('inf')] ** k",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] ** k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [1, 1, 0, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [1, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [-1, 1, 0, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [-1, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [1, 1, 0, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [1, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 2, 0, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 2, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 0, 0, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 0, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 0, 0, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 0, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, -1, 0, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, -1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 1, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 1, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, -1, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, -1, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 1, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 1, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, +1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, +1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [+1, 0, 1, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [+1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, 1, 1, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 1, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, -1, 1, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, -1, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, 1, 1, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 1, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, 0, 2, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 2, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, 0, 0, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 0, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, 0, 0, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 0, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, 0, -1, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, -1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, 0, 1, 1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 1]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, 0, 1, -1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, -1]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-1, 0, 1, 1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 1]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [[False]*n for _ in range(n)]",
      "mutated_line": "visited = [[False] / n for _ in range(n)]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] / n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [[False]*n for _ in range(n)]",
      "mutated_line": "visited = [[False] + n for _ in range(n)]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] + n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [[False]*n for _ in range(n)]",
      "mutated_line": "visited = [[False] ** n for _ in range(n)]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] ** n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 <= x < n or 0 <= y < n or (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n or 0 <= y < n or (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k != 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, -2]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -2]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, -0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -0]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, -0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -0]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, --1]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, --1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-2, 0, 1, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-2, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-0, 0, 1, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-0, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [-0, 0, 1, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-0, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [-1, 0, 1, 0]",
      "mutated_line": "dy = [--1, 0, 1, 0]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [--1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 < x < n and 0 <= y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 < x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 > x < n and 0 <= y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 > x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 == x < n and 0 <= y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 == x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 <= x < n and 0 < y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 < y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 <= x < n and 0 > y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 > y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 <= x < n and 0 == y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 == y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 1:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == -1:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 1:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(5):",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(5):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(3):",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(3):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(0):",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(0):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(1):",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(1):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(-4):",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(-4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited[i][j] = True",
      "mutated_line": "visited[i][j] = False",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = False\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "visited[i][j] = False",
      "mutated_line": "visited[i][j] = True",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = True\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [[False]*n for _ in range(n)]",
      "mutated_line": "visited = [[True] * n for _ in range(n)]",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[True] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_path = [float('inf')]*k",
      "mutated_line": "min_path = [float('')] * k",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 1 <= x < n and 0 <= y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 1 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return -1 <= x < n and 0 <= y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return -1 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 1 <= x < n and 0 <= y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 1 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 <= x < n and 1 <= y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 1 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 <= x < n and -1 <= y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and -1 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0<=x<n and 0<=y<n and not visited[x][y]",
      "mutated_line": "return 0 <= x < n and 1 <= y < n and (not visited[x][y])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 1 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x+dx[i], y+dy[i]",
      "mutated_line": "(nx, ny) = (x - dx[i], y + dy[i])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x - dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x+dx[i], y+dy[i]",
      "mutated_line": "(nx, ny) = (x * dx[i], y + dy[i])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x * dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x+dx[i], y+dy[i]",
      "mutated_line": "(nx, ny) = (x + dx[i], y - dy[i])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y - dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x+dx[i], y+dy[i]",
      "mutated_line": "(nx, ny) = (x + dx[i], y * dy[i])",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y * dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "visited[nx][ny] = True",
      "mutated_line": "visited[nx][ny] = False",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = False\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[nx][ny] = False",
      "mutated_line": "visited[nx][ny] = True",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = True\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dfs(i, j, k-1)",
      "mutated_line": "dfs(i, j, k + 1)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k + 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dfs(i, j, k-1)",
      "mutated_line": "dfs(i, j, k * 1)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k * 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dfs(nx, ny, k-1)",
      "mutated_line": "dfs(nx, ny, k + 1)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k + 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dfs(nx, ny, k-1)",
      "mutated_line": "dfs(nx, ny, k * 1)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k * 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dfs(i, j, k-1)",
      "mutated_line": "dfs(i, j, k - 2)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 2)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dfs(i, j, k-1)",
      "mutated_line": "dfs(i, j, k - 0)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 0)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dfs(i, j, k-1)",
      "mutated_line": "dfs(i, j, k - 0)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 0)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dfs(i, j, k-1)",
      "mutated_line": "dfs(i, j, k - -1)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - -1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dfs(nx, ny, k-1)",
      "mutated_line": "dfs(nx, ny, k - 2)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 2)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dfs(nx, ny, k-1)",
      "mutated_line": "dfs(nx, ny, k - 0)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 0)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dfs(nx, ny, k-1)",
      "mutated_line": "dfs(nx, ny, k - 0)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - 0)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dfs(nx, ny, k-1)",
      "mutated_line": "dfs(nx, ny, k - -1)",
      "code": "def minPath(grid, k):\n    n = len(grid)\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    visited = [[False] * n for _ in range(n)]\n    min_path = [float('inf')] * k\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (not visited[x][y])\n\n    def dfs(x, y, k):\n        nonlocal min_path, path\n        if k == 0:\n            min_path = min(min_path, sorted(path))\n            return\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if is_valid(nx, ny):\n                visited[nx][ny] = True\n                path.append(grid[nx][ny])\n                dfs(nx, ny, k - -1)\n                visited[nx][ny] = False\n                path.pop()\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = True\n            path.append(grid[i][j])\n            dfs(i, j, k - 1)\n            path.pop()\n            visited[i][j] = False\n    return min_path"
    }
  ]
}