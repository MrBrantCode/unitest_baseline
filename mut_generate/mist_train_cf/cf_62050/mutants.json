{
  "task_id": "cf_62050",
  "entry_point": "cheapestJump",
  "mutant_count": 139,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "next_jump = [-1]*size",
      "mutated_line": "next_jump = [-1] / size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] / size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "next_jump = [-1]*size",
      "mutated_line": "next_jump = [-1] + size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] + size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "next_jump = [-1]*size",
      "mutated_line": "next_jump = [-1] ** size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] ** size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [float('inf')]*size",
      "mutated_line": "dp = [float('inf')] / size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] / size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [float('inf')]*size",
      "mutated_line": "dp = [float('inf')] + size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] + size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [float('inf')]*size",
      "mutated_line": "dp = [float('inf')] ** size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] ** size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "steps = [0]*size",
      "mutated_line": "steps = [0] / size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] / size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "steps = [0]*size",
      "mutated_line": "steps = [0] + size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] + size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "steps = [0]*size",
      "mutated_line": "steps = [0] ** size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] ** size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if dp[0] == float('inf'):",
      "mutated_line": "if dp[0] != float('inf'):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] != float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i != -1:",
      "mutated_line": "while i == -1:",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i == -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[+1] = A[-1]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[+1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[-1] = A[+1]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[+1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size + 1, -1, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size + 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size * 1, -1, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size * 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, +1, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, +1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, -1, +1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, +1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i, path = 0, []",
      "mutated_line": "(i, path) = (1, [])",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (1, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i, path = 0, []",
      "mutated_line": "(i, path) = (-1, [])",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (-1, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i, path = 0, []",
      "mutated_line": "(i, path) = (1, [])",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (1, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "while i != -1:",
      "mutated_line": "while i != +1:",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != +1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "next_jump = [-1]*size",
      "mutated_line": "next_jump = [+1] * size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [+1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[-2] = A[-1]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-2] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[-0] = A[-1]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-0] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[-0] = A[-1]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-0] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[--1] = A[-1]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[--1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[-1] = A[-2]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-2]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[-1] = A[-0]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-0]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[-1] = A[-0]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-0]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[-1] = A[-1]",
      "mutated_line": "dp[-1] = A[--1]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[--1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "steps = [0]*size",
      "mutated_line": "steps = [1] * size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [1] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "steps = [0]*size",
      "mutated_line": "steps = [-1] * size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [-1] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "steps = [0]*size",
      "mutated_line": "steps = [1] * size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [1] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 2, -1, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 2, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 0, -1, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 0, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 0, -1, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 0, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - -1, -1, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - -1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, -2, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -2, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, -0, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -0, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, -0, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -0, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, --1, -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, --1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, -1, -2):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -2):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, -1, -0):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -0):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, -1, -0):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -0):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(size - 1, -1, -1):",
      "mutated_line": "for i in range(size - 1, -1, --1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, --1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(2, B + 1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(2, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(0, B + 1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(0, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(0, B + 1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(0, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(-1, B + 1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(-1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(1, B - 1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B - 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(1, B * 1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B * 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size or A[i + b] != -1 or steps[i + b] + 1 <= C:",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size or A[i + b] != -1 or steps[i + b] + 1 <= C:\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dp[0] == float('inf'):",
      "mutated_line": "if dp[1] == float('inf'):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[1] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dp[0] == float('inf'):",
      "mutated_line": "if dp[-1] == float('inf'):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[-1] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dp[0] == float('inf'):",
      "mutated_line": "if dp[1] == float('inf'):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[1] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dp[0] == float('inf'):",
      "mutated_line": "if dp[0] == float(''):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float(''):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i != -1:",
      "mutated_line": "while i != -2:",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -2:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i != -1:",
      "mutated_line": "while i != -0:",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -0:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i != -1:",
      "mutated_line": "while i != -0:",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -0:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i != -1:",
      "mutated_line": "while i != --1:",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != --1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "path.append(i + 1)",
      "mutated_line": "path.append(i - 1)",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i - 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "path.append(i + 1)",
      "mutated_line": "path.append(i * 1)",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i * 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_jump = [-1]*size",
      "mutated_line": "next_jump = [-2] * size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-2] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_jump = [-1]*size",
      "mutated_line": "next_jump = [-0] * size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-0] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_jump = [-1]*size",
      "mutated_line": "next_jump = [-0] * size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-0] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_jump = [-1]*size",
      "mutated_line": "next_jump = [--1] * size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [--1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [float('inf')]*size",
      "mutated_line": "dp = [float('')] * size",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(1, B + 2):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 2):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(1, B + 0):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 0):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(1, B + 0):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 0):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for b in range(1, B + 1):",
      "mutated_line": "for b in range(1, B + -1):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + -1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b <= size and A[i + b] != -1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b <= size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b >= size and A[i + b] != -1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b >= size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b != size and A[i + b] != -1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b != size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] == -1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] == -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 < C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 < C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 > C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 > C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 == C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 == C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] and (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] and (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "path.append(i + 1)",
      "mutated_line": "path.append(i + 2)",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 2)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "path.append(i + 1)",
      "mutated_line": "path.append(i + 0)",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 0)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "path.append(i + 1)",
      "mutated_line": "path.append(i + 0)",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 0)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "path.append(i + 1)",
      "mutated_line": "path.append(i + -1)",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + -1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i - b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i - b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i * b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i * b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != +1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != +1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i + b] - 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] - 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i + b] * 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] * 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] <= dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] <= dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] >= dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] >= dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] != dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] != dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] or (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] or (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i] = A[i] + dp[i + b]",
      "mutated_line": "dp[i] = A[i] - dp[i + b]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] - dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i] = A[i] + dp[i + b]",
      "mutated_line": "dp[i] = A[i] * dp[i + b]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] * dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "next_jump[i] = i + b",
      "mutated_line": "next_jump[i] = i - b",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i - b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "next_jump[i] = i + b",
      "mutated_line": "next_jump[i] = i * b",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i * b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "steps[i] = steps[i + b] + 1",
      "mutated_line": "steps[i] = steps[i + b] - 1",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] - 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "steps[i] = steps[i + b] + 1",
      "mutated_line": "steps[i] = steps[i + b] * 1",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] * 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i - b] != -1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i - b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i * b] != -1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i * b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -2 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -2 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -0 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -0 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -0 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -0 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != --1 and (steps[i + b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != --1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i + b] + 2 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 2 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i + b] + 0 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 0 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i + b] + 0 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 0 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i + b] + -1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + -1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] - dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] - dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] * dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] * dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] != dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] != dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 and i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 and i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "steps[i] = steps[i + b] + 1",
      "mutated_line": "steps[i] = steps[i + b] + 2",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 2\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "steps[i] = steps[i + b] + 1",
      "mutated_line": "steps[i] = steps[i + b] + 0",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 0\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "steps[i] = steps[i + b] + 1",
      "mutated_line": "steps[i] = steps[i + b] + 0",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 0\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "steps[i] = steps[i + b] + 1",
      "mutated_line": "steps[i] = steps[i + b] + -1",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + -1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i - b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i - b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i + b < size and A[i + b] != -1 and steps[i + b] + 1 <= C:",
      "mutated_line": "if i + b < size and A[i + b] != -1 and (steps[i * b] + 1 <= C):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i * b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] - dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] - dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] * dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] * dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] != -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] != -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b <= next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b <= next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b >= next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b >= next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b != next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b != next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i] = A[i] + dp[i + b]",
      "mutated_line": "dp[i] = A[i] + dp[i - b]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i - b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i] = A[i] + dp[i + b]",
      "mutated_line": "dp[i] = A[i] + dp[i * b]",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i * b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "steps[i] = steps[i + b] + 1",
      "mutated_line": "steps[i] = steps[i - b] + 1",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i - b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "steps[i] = steps[i + b] + 1",
      "mutated_line": "steps[i] = steps[i * b] + 1",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i * b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i - b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i - b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i * b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i * b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == +1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == +1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i - b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i - b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i * b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i * b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i - b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i - b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i * b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i * b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -2 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -2 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -0 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -0 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -0 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -0 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == -1 or i + b < next_jump[i])):",
      "mutated_line": "if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == --1 or i + b < next_jump[i])):",
      "code": "def cheapestJump(A, B, C):\n    size = len(A)\n    next_jump = [-1] * size\n    dp = [float('inf')] * size\n    dp[-1] = A[-1]\n    steps = [0] * size\n    for i in range(size - 1, -1, -1):\n        for b in range(1, B + 1):\n            if i + b < size and A[i + b] != -1 and (steps[i + b] + 1 <= C):\n                if A[i] + dp[i + b] < dp[i] or (A[i] + dp[i + b] == dp[i] and (next_jump[i] == --1 or i + b < next_jump[i])):\n                    dp[i] = A[i] + dp[i + b]\n                    next_jump[i] = i + b\n                    steps[i] = steps[i + b] + 1\n    if dp[0] == float('inf'):\n        return []\n    (i, path) = (0, [])\n    while i != -1:\n        path.append(i + 1)\n        i = next_jump[i]\n    return path"
    }
  ]
}