{
  "task_id": "cf_72252",
  "entry_point": "binary_to_unicode",
  "mutant_count": 23,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "def binary_to_unicode(binary_str, bit_endianness='big'):",
      "mutated_line": "def binary_to_unicode(binary_str, bit_endianness=''):",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness=''):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "unicode_str = \"\"",
      "mutated_line": "unicode_str = 'MUTATED'",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = 'MUTATED'\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if bit_endianness == 'big':",
      "mutated_line": "if bit_endianness != 'big':",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness != 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "unicode_str += chr(int(binary, 2))",
      "mutated_line": "unicode_str -= chr(int(binary, 2))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str -= chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str -= chr(int(binary[::-1], 2))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str -= chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if bit_endianness == 'big':",
      "mutated_line": "if bit_endianness == '':",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == '':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "unicode_str += chr(int(binary, 2))",
      "mutated_line": "unicode_str += chr(int(binary, 3))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 3))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "unicode_str += chr(int(binary, 2))",
      "mutated_line": "unicode_str += chr(int(binary, 1))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 1))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "unicode_str += chr(int(binary, 2))",
      "mutated_line": "unicode_str += chr(int(binary, 0))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 0))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "unicode_str += chr(int(binary, 2))",
      "mutated_line": "unicode_str += chr(int(binary, 1))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 1))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "unicode_str += chr(int(binary, 2))",
      "mutated_line": "unicode_str += chr(int(binary, -2))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, -2))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::-1], 3))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 3))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::-1], 1))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 1))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::-1], 0))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 0))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::-1], 1))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 1))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::-1], -2))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], -2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "raise InvalidUnicodeException(f\"Invalid unicode value: {binary}\") from e",
      "mutated_line": "raise InvalidUnicodeException(f'{binary}') from e",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'{binary}') from e\n    return unicode_str"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::+1], 2))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::+1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::-2], 2))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-2], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::-0], 2))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-0], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::-0], 2))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::-0], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "unicode_str += chr(int(binary[::-1], 2))",
      "mutated_line": "unicode_str += chr(int(binary[::--1], 2))",
      "code": "class InvalidUnicodeException(Exception):\n\n    def __init__(self, error):\n        super().__init__(error)\n\ndef binary_to_unicode(binary_str, bit_endianness='big'):\n    \"\"\"\n    Converts a provided binary code into its corresponding Unicode symbol(s) \n    and returns the result as a string.\n\n    Args:\n    binary_str (str): A sequence of multiple binary values separated by spaces.\n    bit_endianness (str): The byte order, either 'big' or 'little'. Defaults to 'big'.\n\n    Returns:\n    str: The corresponding Unicode symbol(s) as a string.\n\n    Raises:\n    InvalidUnicodeException: If any binary value is not a valid Unicode.\n    \"\"\"\n    binaries = binary_str.split()\n    unicode_str = ''\n    for binary in binaries:\n        try:\n            if bit_endianness == 'big':\n                unicode_str += chr(int(binary, 2))\n            else:\n                unicode_str += chr(int(binary[::--1], 2))\n        except ValueError as e:\n            raise InvalidUnicodeException(f'Invalid unicode value: {binary}') from e\n    return unicode_str"
    }
  ]
}