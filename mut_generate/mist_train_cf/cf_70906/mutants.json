{
  "task_id": "cf_70906",
  "entry_point": "number_to_binary",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x[0] == '-':",
      "mutated_line": "if x[0] != '-':",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] != '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if '.' in x:",
      "mutated_line": "(integer_part, fractional_part) = x.split('.')",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' not in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x[0] == '-':",
      "mutated_line": "if x[0] == '':",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prefix = '-'",
      "mutated_line": "prefix = ''",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = ''\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prefix = ''",
      "mutated_line": "prefix = 'MUTATED'",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = 'MUTATED'\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if '.' in x:",
      "mutated_line": "(integer_part, fractional_part) = x.split('.')",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "fractional_part = int(fractional_part, base) / (base ** len(fractional_part))",
      "mutated_line": "fractional_part = int(fractional_part, base) * base ** len(fractional_part)",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) * base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "fractional_part = int(fractional_part, base) / (base ** len(fractional_part))",
      "mutated_line": "fractional_part = int(fractional_part, base) // base ** len(fractional_part)",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) // base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "binary_fractional_part = '.'",
      "mutated_line": "binary_fractional_part = ''",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = ''\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while fractional_part > 0:",
      "mutated_line": "while fractional_part >= 0:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part >= 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while fractional_part > 0:",
      "mutated_line": "while fractional_part <= 0:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part <= 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while fractional_part > 0:",
      "mutated_line": "while fractional_part != 0:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part != 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "fractional_part *= 2",
      "mutated_line": "fractional_part /= 2",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part /= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return prefix + binary_integer_part + binary_fractional_part",
      "mutated_line": "return prefix + binary_integer_part - binary_fractional_part",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part - binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return prefix + binary_integer_part + binary_fractional_part",
      "mutated_line": "return (prefix + binary_integer_part) * binary_fractional_part",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return (prefix + binary_integer_part) * binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return prefix + bin(int(x, base))[2:]",
      "mutated_line": "return prefix - bin(int(x, base))[2:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix - bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return prefix + bin(int(x, base))[2:]",
      "mutated_line": "return prefix * bin(int(x, base))[2:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix * bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x[0] == '-':",
      "mutated_line": "if x[1] == '-':",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[1] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x[0] == '-':",
      "mutated_line": "if x[-1] == '-':",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[-1] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x[0] == '-':",
      "mutated_line": "if x[1] == '-':",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[1] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "integer_part, fractional_part = x.split('.')",
      "mutated_line": "(integer_part, fractional_part) = x.split('')",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "fractional_part = int(fractional_part, base) / (base ** len(fractional_part))",
      "mutated_line": "fractional_part = int(fractional_part, base) / (base * len(fractional_part))",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / (base * len(fractional_part))\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "fractional_part = int(fractional_part, base) / (base ** len(fractional_part))",
      "mutated_line": "fractional_part = int(fractional_part, base) / (base + len(fractional_part))",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / (base + len(fractional_part))\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while fractional_part > 0:",
      "mutated_line": "while fractional_part > 1:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 1:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while fractional_part > 0:",
      "mutated_line": "while fractional_part > -1:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > -1:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while fractional_part > 0:",
      "mutated_line": "while fractional_part > 1:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 1:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fractional_part *= 2",
      "mutated_line": "fractional_part *= 3",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 3\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fractional_part *= 2",
      "mutated_line": "fractional_part *= 1",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 1\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fractional_part *= 2",
      "mutated_line": "fractional_part *= 0",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 0\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fractional_part *= 2",
      "mutated_line": "fractional_part *= 1",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 1\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fractional_part *= 2",
      "mutated_line": "fractional_part *= -2",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= -2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if bit == 1:",
      "mutated_line": "if bit != 1:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit != 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "fractional_part -= bit",
      "mutated_line": "fractional_part += bit",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part += bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "binary_fractional_part += '1'",
      "mutated_line": "binary_fractional_part -= '1'",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part -= '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "binary_fractional_part += '0'",
      "mutated_line": "binary_fractional_part -= '0'",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part -= '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return prefix + binary_integer_part + binary_fractional_part",
      "mutated_line": "return prefix - binary_integer_part + binary_fractional_part",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix - binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return prefix + binary_integer_part + binary_fractional_part",
      "mutated_line": "return prefix * binary_integer_part + binary_fractional_part",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix * binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = x[1:]",
      "mutated_line": "x = x[2:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[2:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = x[1:]",
      "mutated_line": "x = x[0:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[0:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = x[1:]",
      "mutated_line": "x = x[0:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[0:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = x[1:]",
      "mutated_line": "x = x[-1:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[-1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "binary_integer_part = bin(integer_part)[2:]",
      "mutated_line": "binary_integer_part = bin(integer_part)[3:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[3:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "binary_integer_part = bin(integer_part)[2:]",
      "mutated_line": "binary_integer_part = bin(integer_part)[1:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[1:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "binary_integer_part = bin(integer_part)[2:]",
      "mutated_line": "binary_integer_part = bin(integer_part)[0:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[0:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "binary_integer_part = bin(integer_part)[2:]",
      "mutated_line": "binary_integer_part = bin(integer_part)[1:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[1:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "binary_integer_part = bin(integer_part)[2:]",
      "mutated_line": "binary_integer_part = bin(integer_part)[-2:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[-2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if bit == 1:",
      "mutated_line": "if bit == 2:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 2:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if bit == 1:",
      "mutated_line": "if bit == 0:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 0:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if bit == 1:",
      "mutated_line": "if bit == 0:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 0:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if bit == 1:",
      "mutated_line": "if bit == -1:",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == -1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "binary_fractional_part += '1'",
      "mutated_line": "binary_fractional_part += ''",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += ''\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "binary_fractional_part += '0'",
      "mutated_line": "binary_fractional_part += ''",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += ''\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return prefix + bin(int(x, base))[2:]",
      "mutated_line": "return prefix + bin(int(x, base))[3:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[3:]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return prefix + bin(int(x, base))[2:]",
      "mutated_line": "return prefix + bin(int(x, base))[1:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return prefix + bin(int(x, base))[2:]",
      "mutated_line": "return prefix + bin(int(x, base))[0:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return prefix + bin(int(x, base))[2:]",
      "mutated_line": "return prefix + bin(int(x, base))[1:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return prefix + bin(int(x, base))[2:]",
      "mutated_line": "return prefix + bin(int(x, base))[-2:]",
      "code": "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. \n    Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    if '.' in x:\n        (integer_part, fractional_part) = x.split('.')\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / base ** len(fractional_part)\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[-2:]"
    }
  ]
}