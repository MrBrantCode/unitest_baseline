{
  "task_id": "cf_23117",
  "entry_point": "ipv4_to_binary",
  "mutant_count": 24,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(parts) != 4:",
      "mutated_line": "if len(parts) == 4:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) == 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "parts = ip.split('.')",
      "mutated_line": "parts = ip.split('')",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(parts) != 4:",
      "mutated_line": "if len(parts) != 5:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 5:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(parts) != 4:",
      "mutated_line": "if len(parts) != 3:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 3:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(parts) != 4:",
      "mutated_line": "if len(parts) != 0:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 0:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(parts) != 4:",
      "mutated_line": "if len(parts) != 1:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 1:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(parts) != 4:",
      "mutated_line": "if len(parts) != -4:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != -4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() and (not 0 <= int(part) <= 255):",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() and (not 0 <= int(part) <= 255):\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return f\"{ip} is not a valid IPv4 address.\"",
      "mutated_line": "return f'{ip}'",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip}'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return '.'.join(binary_parts)",
      "mutated_line": "return ''.join(binary_parts)",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return ''.join(binary_parts)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 0 < int(part) <= 255:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 < int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 0 > int(part) <= 255:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 > int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 0 == int(part) <= 255:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 == int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return f\"{ip} is not a valid IPv4 address.\"",
      "mutated_line": "return f'{ip}'",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip}'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "binary_parts.append(format(int(part), '08b'))",
      "mutated_line": "binary_parts.append(format(int(part), ''))",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), ''))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 1 <= int(part) <= 255:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 1 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not -1 <= int(part) <= 255:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not -1 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 1 <= int(part) <= 255:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 1 <= int(part) <= 255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 0 <= int(part) <= 256:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 256:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 0 <= int(part) <= 254:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 254:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 0 <= int(part) <= 0:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 0:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 0 <= int(part) <= 1:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= 1:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not part.isdigit() or not (0 <= int(part) <= 255):",
      "mutated_line": "if not part.isdigit() or not 0 <= int(part) <= -255:",
      "code": "def ipv4_to_binary(ip: str) -> str:\n    \"\"\"\n    This function takes an input string representing an IPv4 address, \n    validates it, and returns its binary representation.\n    \n    Args:\n        ip (str): The input string representing an IPv4 address.\n    \n    Returns:\n        str: The binary representation of the input IPv4 address if it's valid, \n             otherwise an error message.\n    \"\"\"\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return f'{ip} is not a valid IPv4 address.'\n    for part in parts:\n        if not part.isdigit() or not 0 <= int(part) <= -255:\n            return f'{ip} is not a valid IPv4 address.'\n    binary_parts = []\n    for part in parts:\n        binary_parts.append(format(int(part), '08b'))\n    return '.'.join(binary_parts)"
    }
  ]
}