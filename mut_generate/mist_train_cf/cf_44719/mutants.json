{
  "task_id": "cf_44719",
  "entry_point": "canDistribute",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if idx == m:",
      "mutated_line": "if idx != m:",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx != m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return True\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dfs(0, tuple(freq))",
      "mutated_line": "return dfs(1, tuple(freq))",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(1, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dfs(0, tuple(freq))",
      "mutated_line": "return dfs(-1, tuple(freq))",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(-1, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dfs(0, tuple(freq))",
      "mutated_line": "return dfs(1, tuple(freq))",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(1, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "freq = sorted(Counter(nums).values(), reverse=True)",
      "mutated_line": "freq = sorted(Counter(nums).values(), reverse=False)",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=False)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "quantity.sort(reverse=True)",
      "mutated_line": "quantity.sort(reverse=False)",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=False)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return False\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if remain[i] >= quantity[idx]:",
      "mutated_line": "if remain[i] > quantity[idx]:",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] > quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if remain[i] >= quantity[idx]:",
      "mutated_line": "if remain[i] < quantity[idx]:",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] < quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if remain[i] >= quantity[idx]:",
      "mutated_line": "if remain[i] == quantity[idx]:",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] == quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "new_remain[i] -= quantity[idx]",
      "mutated_line": "new_remain[i] += quantity[idx]",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] += quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "new_remain[i] += quantity[idx]",
      "mutated_line": "new_remain[i] -= quantity[idx]",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] -= quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):",
      "mutated_line": "if dfs(idx - 1, tuple(sorted(new_remain, reverse=True))):",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx - 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):",
      "mutated_line": "if dfs(idx * 1, tuple(sorted(new_remain, reverse=True))):",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx * 1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):\n                    return False\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):",
      "mutated_line": "if dfs(idx + 2, tuple(sorted(new_remain, reverse=True))):",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 2, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):",
      "mutated_line": "if dfs(idx + 0, tuple(sorted(new_remain, reverse=True))):",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 0, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):",
      "mutated_line": "if dfs(idx + 0, tuple(sorted(new_remain, reverse=True))):",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 0, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):",
      "mutated_line": "if dfs(idx + -1, tuple(sorted(new_remain, reverse=True))):",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + -1, tuple(sorted(new_remain, reverse=True))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dfs(idx + 1, tuple(sorted(new_remain, reverse=True))):",
      "mutated_line": "if dfs(idx + 1, tuple(sorted(new_remain, reverse=False))):",
      "code": "from collections import Counter\nfrom functools import lru_cache\n\ndef canDistribute(nums, quantity):\n    freq = sorted(Counter(nums).values(), reverse=True)\n    (n, m) = (len(freq), len(quantity))\n    quantity.sort(reverse=True)\n\n    @lru_cache(None)\n    def dfs(idx: int, remain: tuple) -> bool:\n        if idx == m:\n            return True\n        for i in range(n):\n            if remain[i] >= quantity[idx]:\n                new_remain = list(remain)\n                new_remain[i] -= quantity[idx]\n                if dfs(idx + 1, tuple(sorted(new_remain, reverse=False))):\n                    return True\n                new_remain[i] += quantity[idx]\n        return False\n    return dfs(0, tuple(freq))"
    }
  ]
}