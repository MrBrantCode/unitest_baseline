{
  "task_id": "cf_51621",
  "entry_point": "advanced_custom_sort",
  "mutant_count": 25,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse= s == 'desc') + transformed[m:]",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') - transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') - transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse= s == 'desc') + transformed[m:]",
      "mutated_line": "sorted_l = (transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc')) * transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = (transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc')) * transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return sorted_l[-r:] + sorted_l[:-r]",
      "mutated_line": "return sorted_l[-r:] - sorted_l[:-r]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] - sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return sorted_l[-r:] + sorted_l[:-r]",
      "mutated_line": "return sorted_l[-r:] * sorted_l[:-r]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] * sorted_l[:-r]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "transform = {'square': lambda x: x*x,",
      "mutated_line": "transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "'cube': lambda x: x*x*x}",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, '': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse= s == 'desc') + transformed[m:]",
      "mutated_line": "sorted_l = transformed[:n] - sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] - sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse= s == 'desc') + transformed[m:]",
      "mutated_line": "sorted_l = transformed[:n] * sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] * sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "transform = {'square': lambda x: x*x,",
      "mutated_line": "transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x / x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "transform = {'square': lambda x: x*x,",
      "mutated_line": "transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x + x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "transform = {'square': lambda x: x*x,",
      "mutated_line": "transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x ** x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "'cube': lambda x: x*x*x}",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x / x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "'cube': lambda x: x*x*x}",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x + x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "'cube': lambda x: x*x*x}",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: (x * x) ** x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "transformed = [transform[f](x) if n<=i<m else x for i,x in enumerate(l)]",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n < i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "transformed = [transform[f](x) if n<=i<m else x for i,x in enumerate(l)]",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n > i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "transformed = [transform[f](x) if n<=i<m else x for i,x in enumerate(l)]",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n == i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "'cube': lambda x: x*x*x}",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x / x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "'cube': lambda x: x*x*x}",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: (x + x) * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "'cube': lambda x: x*x*x}",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x ** x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return sorted_l[-r:] + sorted_l[:-r]",
      "mutated_line": "return sorted_l[+r:] + sorted_l[:-r]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[+r:] + sorted_l[:-r]"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return sorted_l[-r:] + sorted_l[:-r]",
      "mutated_line": "return sorted_l[-r:] + sorted_l[:+r]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:+r]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse= s == 'desc') + transformed[m:]",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s != 'desc') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s != 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse= s == 'desc') + transformed[m:]",
      "mutated_line": "sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == '') + transformed[m:]",
      "code": "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    Parameters:\n    l (list): Input list\n    n (int): Start index of the range\n    m (int): End index of the range\n    s (str): Sort directive ('asc' or 'desc')\n    r (int): Rotation value\n    f (str): Arithmetic function ('square' or 'cube')\n\n    Returns:\n    list: The transformed, sorted and rotated list\n    \"\"\"\n    transform = {'square': lambda x: x * x, 'cube': lambda x: x * x * x}\n    transformed = [transform[f](x) if n <= i < m else x for (i, x) in enumerate(l)]\n    sorted_l = transformed[:n] + sorted(transformed[n:m], reverse=s == '') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    }
  ]
}