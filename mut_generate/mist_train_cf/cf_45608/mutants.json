{
  "task_id": "cf_45608",
  "entry_point": "crackSafe",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = [0] * k * n",
      "mutated_line": "a = [0] * k / n",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k / n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = [0] * k * n",
      "mutated_line": "a = [0] * k + n",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k + n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = [0] * k * n",
      "mutated_line": "a = ([0] * k) ** n",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = ([0] * k) ** n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = [0] * k * n",
      "mutated_line": "a = [0] / k * n",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] / k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = [0] * k * n",
      "mutated_line": "a = ([0] + k) * n",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = ([0] + k) * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = [0] * k * n",
      "mutated_line": "a = [0] ** k * n",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] ** k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if t > n:",
      "mutated_line": "if t >= n:",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t >= n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if t > n:",
      "mutated_line": "if t <= n:",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t <= n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if t > n:",
      "mutated_line": "if t != n:",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t != n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "db(1, 1)",
      "mutated_line": "db(2, 1)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(2, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "db(1, 1)",
      "mutated_line": "db(0, 1)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(0, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "db(1, 1)",
      "mutated_line": "db(0, 1)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(0, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "db(1, 1)",
      "mutated_line": "db(-1, 1)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(-1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "db(1, 1)",
      "mutated_line": "db(1, 2)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 2)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "db(1, 1)",
      "mutated_line": "db(1, 0)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 0)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "db(1, 1)",
      "mutated_line": "db(1, 0)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 0)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "db(1, 1)",
      "mutated_line": "db(1, -1)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, -1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "password = password[:-m] + password[-m:].replace(lock_sequence, '')",
      "mutated_line": "password = password[:-m] - password[-m:].replace(lock_sequence, '')",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] - password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "password = password[:-m] + password[-m:].replace(lock_sequence, '')",
      "mutated_line": "password = password[:-m] * password[-m:].replace(lock_sequence, '')",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] * password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n % p != 0:",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p != 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "password = ''.join(alphabet[i] for i in sequence)",
      "mutated_line": "password = 'MUTATED'.join((alphabet[i] for i in sequence))",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = 'MUTATED'.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "password = password[:k**n]",
      "mutated_line": "password = password[:k * n]",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k * n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "password = password[:k**n]",
      "mutated_line": "password = password[:k + n]",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k + n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = [0] * k * n",
      "mutated_line": "a = [1] * k * n",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [1] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = [0] * k * n",
      "mutated_line": "a = [-1] * k * n",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [-1] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = [0] * k * n",
      "mutated_line": "a = [1] * k * n",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [1] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n * p == 0:",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n * p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n + p == 0:",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n + p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n % p == 1:",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 1:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n % p == -1:",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == -1:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n % p == 1:",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 1:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "a[t] = a[t - p]",
      "mutated_line": "a[t] = a[t + p]",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t + p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "a[t] = a[t - p]",
      "mutated_line": "a[t] = a[t * p]",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t * p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "db(t + 1, p)",
      "mutated_line": "db(t - 1, p)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t - 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "db(t + 1, p)",
      "mutated_line": "db(t * 1, p)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t * 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(a[t - p] + 1, k):",
      "mutated_line": "for j in range(a[t - p] - 1, k):",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] - 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(a[t - p] + 1, k):",
      "mutated_line": "for j in range(a[t - p] * 1, k):",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] * 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "password = password[:-m] + password[-m:].replace(lock_sequence, '')",
      "mutated_line": "password = password[:-m] + password[-m:].replace(lock_sequence, 'MUTATED')",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, 'MUTATED')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "db(t + 1, p)",
      "mutated_line": "db(t + 2, p)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 2, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "db(t + 1, p)",
      "mutated_line": "db(t + 0, p)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 0, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "db(t + 1, p)",
      "mutated_line": "db(t + 0, p)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 0, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "db(t + 1, p)",
      "mutated_line": "db(t + -1, p)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + -1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(a[t - p] + 1, k):",
      "mutated_line": "for j in range(a[t - p] + 2, k):",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 2, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(a[t - p] + 1, k):",
      "mutated_line": "for j in range(a[t - p] + 0, k):",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 0, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(a[t - p] + 1, k):",
      "mutated_line": "for j in range(a[t - p] + 0, k):",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 0, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(a[t - p] + 1, k):",
      "mutated_line": "for j in range(a[t - p] + -1, k):",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + -1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "db(t + 1, t)",
      "mutated_line": "db(t - 1, t)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t - 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "db(t + 1, t)",
      "mutated_line": "db(t * 1, t)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t * 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "password = password[:-m] + password[-m:].replace(lock_sequence, '')",
      "mutated_line": "password = password[:+m] + password[-m:].replace(lock_sequence, '')",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:+m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(a[t - p] + 1, k):",
      "mutated_line": "for j in range(a[t + p] + 1, k):",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t + p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(a[t - p] + 1, k):",
      "mutated_line": "for j in range(a[t * p] + 1, k):",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t * p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "db(t + 1, t)",
      "mutated_line": "db(t + 2, t)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 2, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "db(t + 1, t)",
      "mutated_line": "db(t + 0, t)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 0, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "db(t + 1, t)",
      "mutated_line": "db(t + 0, t)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 0, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "db(t + 1, t)",
      "mutated_line": "db(t + -1, t)",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + -1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[2:p + 1])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[2:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[0:p + 1])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[0:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[0:p + 1])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[0:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[-1:p + 1])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[-1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[1:p - 1])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p - 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[1:p * 1])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p * 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "password = password[:-m] + password[-m:].replace(lock_sequence, '')",
      "mutated_line": "password = password[:-m] + password[+m:].replace(lock_sequence, '')",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[+m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[1:p + 2])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 2])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[1:p + 0])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 0])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[1:p + 0])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + 0])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sequence.extend(a[1:p+1])",
      "mutated_line": "sequence.extend(a[1:p + -1])",
      "code": "def crackSafe(n, k, m, lock_sequence):\n    \"\"\"\n    This function generates the minimal possible password of length k^n \n    that guarantees unlocking the receptacle without triggering the permanent lock.\n\n    Parameters:\n    n (int): The length of the password string.\n    k (int): The base of the number system.\n    m (int): The length of the lock sequence.\n    lock_sequence (str): The lock sequence string.\n\n    Returns:\n    str: The minimal possible password string.\n    \"\"\"\n    alphabet = list(map(str, range(k)))\n    sequence = []\n    a = [0] * k * n\n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                sequence.extend(a[1:p + -1])\n        else:\n            a[t] = a[t - p]\n            db(t + 1, p)\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                db(t + 1, t)\n    db(1, 1)\n    password = ''.join((alphabet[i] for i in sequence))\n    if password.endswith(lock_sequence):\n        password = password[:-m] + password[-m:].replace(lock_sequence, '')\n    password = password[:k ** n]\n    return password"
    }
  ]
}