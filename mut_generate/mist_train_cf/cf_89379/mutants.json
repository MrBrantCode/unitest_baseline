{
  "task_id": "cf_89379",
  "entry_point": "longest_common_subsequence",
  "mutant_count": 179,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "lcs = [''] * lcs_length",
      "mutated_line": "lcs = [''] / lcs_length",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] / lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "lcs = [''] * lcs_length",
      "mutated_line": "lcs = [''] + lcs_length",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] + lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "lcs = [''] * lcs_length",
      "mutated_line": "lcs = [''] ** lcs_length",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] ** lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 or j > 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 or j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] / (n + 1) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] / (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] + (n + 1) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] + (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] ** (n + 1) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] ** (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(2, m + 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(2, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(0, m + 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(0, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(0, m + 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(0, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(-1, m + 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(-1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m - 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m - 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m * 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m * 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i >= 0 and j > 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i >= 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i <= 0 and j > 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i <= 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i != 0 and j > 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i != 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j >= 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j >= 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j <= 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j <= 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j != 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j != 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] or str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] or str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i += 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j += 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "lcs_length -= 1",
      "mutated_line": "lcs_length += 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length += 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n - 1) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n - 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n * 1) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n * 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 2):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 2):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 0):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 0):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 0):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 0):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + -1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + -1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(2, n + 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(2, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(0, n + 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(0, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(0, n + 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(0, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(-1, n + 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(-1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n - 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n - 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n * 1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n * 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] or str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] or str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "lcs = [''] * lcs_length",
      "mutated_line": "lcs = ['MUTATED'] * lcs_length",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = ['MUTATED'] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 1 and j > 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 1 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > -1 and j > 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > -1 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 1 and j > 0:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 1 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j > 1:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 1:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j > -1:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > -1:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j > 1:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 1:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] != str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] != str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 2\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 0\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 0\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= -1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 2\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 0\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 0\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= -1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "lcs_length -= 1",
      "mutated_line": "lcs_length -= 2",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 2\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "lcs_length -= 1",
      "mutated_line": "lcs_length -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 0\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "lcs_length -= 1",
      "mutated_line": "lcs_length -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 0\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "lcs_length -= 1",
      "mutated_line": "lcs_length -= -1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= -1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 1][j] >= dp[i][j - 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] >= dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 1][j] <= dp[i][j - 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] <= dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 1][j] != dp[i][j - 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] != dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i += 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j += 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[1] * (n + 1) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[1] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1] * (n + 1) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[-1] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[1] * (n + 1) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[1] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + 2) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 2) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + 0) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 0) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + 0) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 0) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + -1) for _ in range(m + 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + -1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(m - 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m - 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(m * 1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m * 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + 2):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 2):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + 0):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 0):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + 0):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 0):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + -1):",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + -1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] != str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] != str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - 1] - 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] - 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - 1] * 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] * 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length + 1] = str1[i - 1]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length + 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length * 1] = str1[i - 1]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length * 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - 1] = str1[i + 1]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i + 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - 1] = str1[i * 1]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i * 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 2\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 0\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 0\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= -1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 2\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 0\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 0\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= -1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return ''.join(lcs), len(lcs)",
      "mutated_line": "return ('MUTATED'.join(lcs), len(lcs))",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return ('MUTATED'.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(m + 2)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 2)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(m + 0)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 0)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(m + 0)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 0)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0] * (n + 1) for _ in range(m + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(m + -1)]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + -1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - 1] + 2",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - 1] + 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 0\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - 1] + 0",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 0\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - 1] + -1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + -1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i + 1] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i + 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i * 1] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i * 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j + 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j + 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j * 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j * 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - 2] = str1[i - 1]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 2] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - 0] = str1[i - 1]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 0] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - 0] = str1[i - 1]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 0] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - -1] = str1[i - 1]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - -1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - 1] = str1[i - 2]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 2]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - 1] = str1[i - 0]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 0]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - 1] = str1[i - 0]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 0]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "lcs[lcs_length - 1] = str1[i - 1]",
      "mutated_line": "lcs[lcs_length - 1] = str1[i - -1]",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - -1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 1][j] > dp[i][j + 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j + 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 1][j] > dp[i][j * 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j * 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i + 1] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i + 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i * 1] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i * 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j + 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j + 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j * 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j * 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j + 1] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j + 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j * 1] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j * 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j + 1])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j + 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j * 1])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j * 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 2] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 2] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 0] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 0] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 0] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 0] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - -1] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - -1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 2] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 2] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 0] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 0] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 0] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 0] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - -1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - -1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i + 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i + 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i * 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i * 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i + 1][j] > dp[i][j - 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i + 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i * 1][j] > dp[i][j - 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i * 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 1][j] > dp[i][j - 2]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 2]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 1][j] > dp[i][j - 0]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 0]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 1][j] > dp[i][j - 0]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 0]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 1][j] > dp[i][j - -1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - -1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 2] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 2] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 0] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 0] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 0] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 0] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - -1] == str2[j - 1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - -1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 2] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 2] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 0] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 0] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 0] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 0] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - -1] and str1[i - 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - -1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i + 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i + 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i * 1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i * 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i + 1][j - 1] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i + 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i * 1][j - 1] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i * 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - 2] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 2] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - 0] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 0] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - 0] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 0] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 1][j - -1] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - -1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i * 1][j], dp[i][j - 1])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i * 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 2])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 2])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 0])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 0])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 0])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 0])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - -1])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - -1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i - 2].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 2].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i - 0].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 0].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i - 0].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 0].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i - -1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - -1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 2][j] > dp[i][j - 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 2][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 0][j] > dp[i][j - 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 0][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - 0][j] > dp[i][j - 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 0][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif dp[i - 1][j] > dp[i][j - 1]:",
      "mutated_line": "elif dp[i - -1][j] > dp[i][j - 1]:",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - -1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i - 2].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 2].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i - 0].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 0].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i - 0].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 0].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():",
      "mutated_line": "if str1[i - 1] == str2[j - 1] and str1[i - -1].isupper():",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - -1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 2][j - 1] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 2][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 0][j - 1] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 0][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - 0][j - 1] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 0][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[i][j] = dp[i - 1][j - 1] + 1",
      "mutated_line": "dp[i][j] = dp[i - -1][j - 1] + 1",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - -1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - 2][j], dp[i][j - 1])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 2][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - 0][j], dp[i][j - 1])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 0][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - 0][j], dp[i][j - 1])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 0][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = max(dp[i - -1][j], dp[i][j - 1])",
      "code": "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    This function finds the longest common subsequence in two input strings \n    that contains only uppercase alphabetical characters. If there are multiple \n    subsequences with the same length, it returns the one that comes first \n    lexicographically. The function returns the longest common subsequence and its length.\n\n    Args:\n    str1 (str): The first input string.\n    str2 (str): The second input string.\n\n    Returns:\n    tuple: A tuple containing the longest common subsequence and its length.\n    \"\"\"\n    (m, n) = (len(str1), len(str2))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - -1][j], dp[i][j - 1])\n    lcs_length = dp[m][n]\n    lcs = [''] * lcs_length\n    (i, j) = (m, n)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1] and str1[i - 1].isupper():\n            lcs[lcs_length - 1] = str1[i - 1]\n            i -= 1\n            j -= 1\n            lcs_length -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return (''.join(lcs), len(lcs))"
    }
  ]
}