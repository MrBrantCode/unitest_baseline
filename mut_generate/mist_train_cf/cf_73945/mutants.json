{
  "task_id": "cf_73945",
  "entry_point": "email_parser",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if match is None:",
      "mutated_line": "if match is not None:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is not None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') in ['gov', 'edu', 'org'] and match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] and match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pattern = re.compile(r\"^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\.(?P<toplevel>[a-zA-Z0-9-.]+$)\")",
      "mutated_line": "pattern = re.compile('')",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return True\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') not in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') not in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') not in ['gmail', 'yahoo', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') not in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "domain_type = 'special'",
      "mutated_line": "domain_type = ''",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = ''\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "domain_type = 'normal'",
      "mutated_line": "domain_type = ''",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = ''\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "'secondlevel': match.group('secondlevel'),",
      "mutated_line": "return {'': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "'toplevel': match.group('toplevel'),",
      "mutated_line": "return {'secondlevel': match.group('secondlevel'), '': match.group('toplevel'), 'domain_type': domain_type}",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), '': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "'domain_type': domain_type,",
      "mutated_line": "return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), '': domain_type}",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), '': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "'secondlevel': match.group('secondlevel'),",
      "mutated_line": "return {'secondlevel': match.group(''), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group(''), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "'toplevel': match.group('toplevel'),",
      "mutated_line": "return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group(''), 'domain_type': domain_type}",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group(''), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') in ['', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') in ['gov', '', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', '', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') in ['gov', 'edu', ''] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', ''] or match.group('secondlevel') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('') in ['gmail', 'yahoo', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('') in ['gmail', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['', 'yahoo', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['', 'yahoo', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', '', 'outlook']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', '', 'outlook']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if match.group('toplevel') in ['gov','edu','org'] or match.group('secondlevel') in ['gmail','yahoo','outlook']:",
      "mutated_line": "if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', '']:",
      "code": "import re\n\ndef email_parser(email_address):\n    \"\"\"\n    This function takes an email address as input, validates its structure, \n    and extracts the domain information. It returns a dictionary containing \n    the second-level domain, top-level domain, and a categorization of the \n    domain type as either 'special' or 'normal'. If the email address is \n    invalid, the function returns False.\n\n    Parameters:\n    email_address (str): The email address to be parsed.\n\n    Returns:\n    dict or bool: A dictionary containing the domain information or False \n                  if the email address is invalid.\n    \"\"\"\n    pattern = re.compile('^[a-zA-Z0-9_.+-]+@(?P<secondlevel>[a-zA-Z0-9-]+)\\\\.(?P<toplevel>[a-zA-Z0-9-.]+$)')\n    match = pattern.match(email_address)\n    if match is None:\n        return False\n    if match.group('toplevel') in ['gov', 'edu', 'org'] or match.group('secondlevel') in ['gmail', 'yahoo', '']:\n        domain_type = 'special'\n    else:\n        domain_type = 'normal'\n    return {'secondlevel': match.group('secondlevel'), 'toplevel': match.group('toplevel'), 'domain_type': domain_type}"
    }
  ]
}