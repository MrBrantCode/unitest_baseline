{
  "task_id": "cf_81045",
  "entry_point": "minMutation",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if end not in bank:",
      "mutated_line": "if end in bank:",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return +1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return +1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if word == end:",
      "mutated_line": "if word != end:",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word != end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -2\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -0\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -0\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return --1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for c in 'ACGT':",
      "mutated_line": "for c in '':",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in '':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(start, 0)])",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 1)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(start, 0)])",
      "mutated_line": "queue = deque([(start, -1)])",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, -1)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(start, 0)])",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 1)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = word[:i] + c - word[i + 1:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c - word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = (word[:i] + c) * word[i + 1:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = (word[:i] + c) * word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if next_word in bank:",
      "mutated_line": "if next_word not in bank:",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word not in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = word[:i] - c + word[i + 1:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] - c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = word[:i] * c + word[i + 1:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] * c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = word[:i] + c + word[i - 1:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i - 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = word[:i] + c + word[i * 1:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i * 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((next_word, steps + 1))",
      "mutated_line": "queue.append((next_word, steps - 1))",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps - 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((next_word, steps + 1))",
      "mutated_line": "queue.append((next_word, steps * 1))",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps * 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = word[:i] + c + word[i + 2:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 2:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = word[:i] + c + word[i + 0:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 0:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = word[:i] + c + word[i + 0:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 0:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "next_word = word[:i] + c + word[i+1:]",
      "mutated_line": "next_word = word[:i] + c + word[i + -1:]",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + -1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((next_word, steps + 1))",
      "mutated_line": "queue.append((next_word, steps + 2))",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((next_word, steps + 1))",
      "mutated_line": "queue.append((next_word, steps + 0))",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 0))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((next_word, steps + 1))",
      "mutated_line": "queue.append((next_word, steps + 0))",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + 0))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((next_word, steps + 1))",
      "mutated_line": "queue.append((next_word, steps + -1))",
      "code": "from collections import deque\n\ndef minMutation(start, end, bank):\n    if end not in bank:\n        return -1\n    queue = deque([(start, 0)])\n    bank = set(bank)\n    while queue:\n        (word, steps) = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            for c in 'ACGT':\n                next_word = word[:i] + c + word[i + 1:]\n                if next_word in bank:\n                    bank.remove(next_word)\n                    queue.append((next_word, steps + -1))\n    return -1"
    }
  ]
}