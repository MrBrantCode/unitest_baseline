{
  "task_id": "cf_27632",
  "entry_point": "solve",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if grid[x][y] == 'E':",
      "mutated_line": "if grid[x][y] != 'E':",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] != 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if grid[i][j] == 'S':",
      "mutated_line": "if grid[i][j] != 'S':",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] != 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if grid[x][y] == 'E':",
      "mutated_line": "if grid[x][y] == '':",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == '':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows or 0 <= new_y < cols or grid[new_x][new_y] != '#' or (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows or 0 <= new_y < cols or grid[new_x][new_y] != '#' or (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[1]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[-1]))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[-1]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[1]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[i][j] == 'S':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x - dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x * dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y - dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y * dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 < new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 < new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 > new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 > new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 == new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 == new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and 0 < new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 < new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and 0 > new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 > new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and 0 == new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 == new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] == 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] == 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "grid[new_x][new_y] = 'v'",
      "mutated_line": "grid[new_x][new_y] = ''",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = ''\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if -1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if -1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and 1 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 1 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and -1 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and -1 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and 1 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 1 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '') and (grid[new_x][new_y] != 'v'):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#' and grid[new_x][new_y] != 'v':",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != ''):",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != ''):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, 0))  # (x, y, distance)",
      "mutated_line": "queue.append((i, j, 1))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 1))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, 0))  # (x, y, distance)",
      "mutated_line": "queue.append((i, j, -1))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, -1))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, 0))  # (x, y, distance)",
      "mutated_line": "queue.append((i, j, 1))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 1))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "queue.append((new_x, new_y, distance + 1))",
      "mutated_line": "queue.append((new_x, new_y, distance - 1))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance - 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "queue.append((new_x, new_y, distance + 1))",
      "mutated_line": "queue.append((new_x, new_y, distance * 1))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance * 1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue.append((new_x, new_y, distance + 1))",
      "mutated_line": "queue.append((new_x, new_y, distance + 2))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 2))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue.append((new_x, new_y, distance + 1))",
      "mutated_line": "queue.append((new_x, new_y, distance + 0))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 0))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue.append((new_x, new_y, distance + 1))",
      "mutated_line": "queue.append((new_x, new_y, distance + 0))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + 0))\n                grid[new_x][new_y] = 'v'\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue.append((new_x, new_y, distance + 1))",
      "mutated_line": "queue.append((new_x, new_y, distance + -1))",
      "code": "from collections import deque\n\ndef solve(grid):\n    \"\"\"\n    This function takes a 2D grid representing a maze as input and returns the length of the shortest path from 'S' to 'E' using a breadth-first search algorithm. If no path exists, it returns -1.\n\n    Args:\n        grid (list): A 2D list representing the maze. Each cell can be 'S' (starting point), 'E' (ending point), '.' (open path), or '#' (wall).\n\n    Returns:\n        int: The length of the shortest path from 'S' to 'E' if a path exists, -1 otherwise.\n    \"\"\"\n    queue = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (rows, cols) = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                break\n    while queue:\n        (x, y, distance) = queue.popleft()\n        if grid[x][y] == 'E':\n            return distance\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != '#') and (grid[new_x][new_y] != 'v'):\n                queue.append((new_x, new_y, distance + -1))\n                grid[new_x][new_y] = 'v'\n    return -1"
    }
  ]
}