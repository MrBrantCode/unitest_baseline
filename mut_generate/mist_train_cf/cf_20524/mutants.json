{
  "task_id": "cf_20524",
  "entry_point": "evaluate_reverse_polish_notation",
  "mutant_count": 27,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):",
      "mutated_line": "if token.isdigit() and (token.startswith('-') and token[1:].isdigit()):",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() and (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return stack[0]",
      "mutated_line": "return stack[1]",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return stack[0]",
      "mutated_line": "return stack[-1]",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return stack[0]",
      "mutated_line": "return stack[1]",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[1]"
    },
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):",
      "mutated_line": "if token.isdigit() or (token.startswith('-') or token[1:].isdigit()):",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') or token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif token == '+':",
      "mutated_line": "elif token != '+':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token != '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "elif token == '+':",
      "mutated_line": "elif token == '':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif token == '-':",
      "mutated_line": "elif token != '-':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token != '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):",
      "mutated_line": "if token.isdigit() or (token.startswith('') and token[1:].isdigit()):",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "stack.append(operand1 + operand2)",
      "mutated_line": "stack.append(operand1 - operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "stack.append(operand1 + operand2)",
      "mutated_line": "stack.append(operand1 * operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif token == '-':",
      "mutated_line": "elif token == '':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif token == '*':",
      "mutated_line": "elif token != '*':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token != '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "stack.append(operand1 - operand2)",
      "mutated_line": "stack.append(operand1 + operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "stack.append(operand1 - operand2)",
      "mutated_line": "stack.append(operand1 * operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif token == '*':",
      "mutated_line": "elif token == '':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif token == '/':",
      "mutated_line": "elif token != '/':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token != '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "stack.append(operand1 * operand2)",
      "mutated_line": "stack.append(operand1 / operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "stack.append(operand1 * operand2)",
      "mutated_line": "stack.append(operand1 + operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "stack.append(operand1 * operand2)",
      "mutated_line": "stack.append(operand1 ** operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 ** operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif token == '/':",
      "mutated_line": "elif token == '':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):",
      "mutated_line": "if token.isdigit() or (token.startswith('-') and token[2:].isdigit()):",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[2:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):",
      "mutated_line": "if token.isdigit() or (token.startswith('-') and token[0:].isdigit()):",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[0:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):",
      "mutated_line": "if token.isdigit() or (token.startswith('-') and token[0:].isdigit()):",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[0:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):",
      "mutated_line": "if token.isdigit() or (token.startswith('-') and token[-1:].isdigit()):",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[-1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stack.append(operand1 / operand2)",
      "mutated_line": "stack.append(operand1 * operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stack.append(operand1 / operand2)",
      "mutated_line": "stack.append(operand1 // operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        elif token == '+':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 + operand2)\n        elif token == '-':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 - operand2)\n        elif token == '*':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 * operand2)\n        elif token == '/':\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(operand1 // operand2)\n    return stack[0]"
    }
  ]
}