{
  "task_id": "cf_82049",
  "entry_point": "minPath",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited and (not 0 <= i < n) and (not 0 <= j < n) and (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited and (not 0 <= i < n) and (not 0 <= j < n) and (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(s) > k:",
      "mutated_line": "if len(s) >= k:",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) >= k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(s) > k:",
      "mutated_line": "if len(s) <= k:",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) <= k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(s) > k:",
      "mutated_line": "if len(s) != k:",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) != k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(s) == k:",
      "mutated_line": "if len(s) != k:",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) != k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) not in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) not in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] > ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] > ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] < ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] < ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] == ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] == ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "heappush(s, -grid[i][j])",
      "mutated_line": "heappush(s, +grid[i][j])",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, +grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 < i < n or (not 0 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 < i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 > i < n or (not 0 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 > i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 == i < n or (not 0 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 == i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 <= i < n or (not 0 < j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 < j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 <= i < n or (not 0 > j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 > j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 <= i < n or (not 0 == j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 == j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "ans = min(ans, -s[0])",
      "mutated_line": "ans = min(ans, +s[0])",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, +s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i - d[0], j + d[1], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i - d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i * d[0], j + d[1], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i * d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i + d[0], j - d[1], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j - d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i + d[0], j * d[1], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j * d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 1 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 1 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not -1 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not -1 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 1 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 1 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 <= i < n or (not 1 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 1 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 <= i < n or (not -1 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not -1 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j) in visited or not (0 <= i < n) or not (0 <= j < n) or grid[i][j] >= ans:",
      "mutated_line": "if (i, j) in visited or not 0 <= i < n or (not 1 <= j < n) or (grid[i][j] >= ans):",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 1 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "path = sorted([-x for x in s])",
      "mutated_line": "path = sorted([+x for x in s])",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([+x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans = min(ans, -s[0])",
      "mutated_line": "ans = min(ans, -s[1])",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[1])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans = min(ans, -s[0])",
      "mutated_line": "ans = min(ans, -s[-1])",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[-1])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans = min(ans, -s[0])",
      "mutated_line": "ans = min(ans, -s[1])",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[1])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i + d[1], j + d[1], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[1], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i + d[-1], j + d[1], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[-1], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i + d[1], j + d[1], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[1], j + d[1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i + d[0], j + d[2], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[2], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i + d[0], j + d[0], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[0], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i + d[0], j + d[0], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[0], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dfs(i + d[0], j + d[1], k, s)",
      "mutated_line": "dfs(i + d[0], j + d[-1], k, s)",
      "code": "from heapq import *\nimport sys\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\ndef minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    ans = sys.maxsize\n    path = []\n\n    def dfs(i, j, k, s):\n        nonlocal ans, path\n        if (i, j) in visited or not 0 <= i < n or (not 0 <= j < n) or (grid[i][j] >= ans):\n            return\n        visited.add((i, j))\n        heappush(s, -grid[i][j])\n        if len(s) > k:\n            heappop(s)\n        if len(s) == k:\n            ans = min(ans, -s[0])\n            path = sorted([-x for x in s])\n        for d in directions:\n            dfs(i + d[0], j + d[-1], k, s)\n        visited.remove((i, j))\n        heappop(s)\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, k, [])\n    return path"
    }
  ]
}