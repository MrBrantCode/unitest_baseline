{
  "task_id": "cf_70401",
  "entry_point": "minPathSumSequence",
  "mutant_count": 143,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if k < N * N:",
      "mutated_line": "if k <= N * N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k <= N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if k < N * N:",
      "mutated_line": "if k >= N * N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k >= N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if k < N * N:",
      "mutated_line": "if k != N * N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k != N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if k < N * N:",
      "mutated_line": "if k < N / N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N / N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if k < N * N:",
      "mutated_line": "if k < N + N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N + N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if k < N * N:",
      "mutated_line": "if k < N ** N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N ** N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if min_sum == float('inf'):",
      "mutated_line": "if min_sum != float('inf'):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum != float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return \"The number of steps is larger than the number of cells in the grid.\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return ''"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k + 1, -1, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k + 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k * 1, -1, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k * 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, +1, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, +1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, -1, +1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, +1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[float('inf')] / k for _ in range(N)] for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] / k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[float('inf')] + k for _ in range(N)] for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] + k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[float('inf')] ** k for _ in range(N)] for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] ** k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][0], 1, 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 1, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][0], -1, 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], -1, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][0], 1, 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 1, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][0], 0, 1, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 1, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][0], 0, -1, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, -1, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][0], 0, 1, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 1, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][0], 0, 0, 1)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 1)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][0], 0, 0, -1)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, -1)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][0], 0, 0, 1)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 1)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 <= nx < N or 0 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N or 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if min_sum == float('inf'):",
      "mutated_line": "if min_sum == float(''):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float(''):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 2, -1, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 2, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 0, -1, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 0, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 0, -1, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 0, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - -1, -1, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - -1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, -2, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -2, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, -0, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -0, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, -0, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -0, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, --1, -1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, --1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, -1, -2):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -2):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, -1, -0):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -0):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, -1, -0):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -0):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for step in range(k - 1, -1, -1):",
      "mutated_line": "for step in range(k - 1, -1, --1):",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, --1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[i][j][0] = grid[i][j]",
      "mutated_line": "dp[i][j][1] = grid[i][j]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][1] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[i][j][0] = grid[i][j]",
      "mutated_line": "dp[i][j][-1] = grid[i][j]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][-1] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[i][j][0] = grid[i][j]",
      "mutated_line": "dp[i][j][1] = grid[i][j]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][1] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][1], 0, 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][1], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][-1], 0, 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][-1], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[0][1], 0, 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][1], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(2, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(2, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(-1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, -1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, -1), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (+1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (+1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, -1), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, -1), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (-1, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (-1, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 2), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 2), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, -1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, -1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (-1, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (-1, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, +1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, +1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x - dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x * dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y - dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y * dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 < nx < N and 0 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 < nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 > nx < N and 0 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 > nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 == nx < N and 0 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 == nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 <= nx < N and 0 < ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 < ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 <= nx < N and 0 > ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 > ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 <= nx < N and 0 == ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 == ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k or curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k or curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_sum = min(dp[i][j][k - 1] for i in range(N) for j in range(N))",
      "mutated_line": "min_sum = min((dp[i][j][k + 1] for i in range(N) for j in range(N)))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k + 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_sum = min(dp[i][j][k - 1] for i in range(N) for j in range(N))",
      "mutated_line": "min_sum = min((dp[i][j][k * 1] for i in range(N) for j in range(N)))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k * 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if dp[i][j][step] == min_sum:",
      "mutated_line": "if dp[i][j][step] != min_sum:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] != min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "min_sum -= grid[i][j]",
      "mutated_line": "min_sum += grid[i][j]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum += grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[1][0], 0, 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[1][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[-1][0], 0, 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[-1][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(grid[0][0], 0, 0, 0)]",
      "mutated_line": "pq = [(grid[1][0], 0, 0, 0)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[1][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-2, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-2, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (--1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (--1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -2)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -2)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, --1)]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, --1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 1 <= nx < N and 0 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 1 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if -1 <= nx < N and 0 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if -1 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 1 <= nx < N and 0 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 1 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 <= nx < N and 1 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 1 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 <= nx < N and -1 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and -1 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < N and 0 <= ny < N:",
      "mutated_line": "if 0 <= nx < N and 1 <= ny < N:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 1 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 <= k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 <= k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 >= k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 >= k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 != k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 != k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum + grid[nx][ny] <= dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] <= dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum + grid[nx][ny] >= dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] >= dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum + grid[nx][ny] != dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] != dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]",
      "mutated_line": "dp[nx][ny][steps + 1] = curr_sum - grid[nx][ny]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum - grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]",
      "mutated_line": "dp[nx][ny][steps + 1] = curr_sum * grid[nx][ny]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum * grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_sum = min(dp[i][j][k - 1] for i in range(N) for j in range(N))",
      "mutated_line": "min_sum = min((dp[i][j][k - 2] for i in range(N) for j in range(N)))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 2] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_sum = min(dp[i][j][k - 1] for i in range(N) for j in range(N))",
      "mutated_line": "min_sum = min((dp[i][j][k - 0] for i in range(N) for j in range(N)))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 0] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_sum = min(dp[i][j][k - 1] for i in range(N) for j in range(N))",
      "mutated_line": "min_sum = min((dp[i][j][k - 0] for i in range(N) for j in range(N)))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 0] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_sum = min(dp[i][j][k - 1] for i in range(N) for j in range(N))",
      "mutated_line": "min_sum = min((dp[i][j][k - -1] for i in range(N) for j in range(N)))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - -1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[float('')] * k for _ in range(N)] for _ in range(N)]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps - 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps - 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps * 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps * 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum - grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum - grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum * grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum * grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]",
      "mutated_line": "dp[nx][ny][steps - 1] = curr_sum + grid[nx][ny]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps - 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]",
      "mutated_line": "dp[nx][ny][steps * 1] = curr_sum + grid[nx][ny]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps * 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 2 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 2 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 0 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 0 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 0 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 0 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + -1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + -1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps - 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps - 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps * 1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps * 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]",
      "mutated_line": "dp[nx][ny][steps + 2] = curr_sum + grid[nx][ny]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 2] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]",
      "mutated_line": "dp[nx][ny][steps + 0] = curr_sum + grid[nx][ny]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 0] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]",
      "mutated_line": "dp[nx][ny][steps + 0] = curr_sum + grid[nx][ny]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 0] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]",
      "mutated_line": "dp[nx][ny][steps + -1] = curr_sum + grid[nx][ny]",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + -1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps - 1))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps - 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps * 1))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps * 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 2]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 2]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 0]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 0]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 0]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 0]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:",
      "mutated_line": "if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + -1]:",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + -1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps - 1], nx, ny, steps + 1))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps - 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps * 1], nx, ny, steps + 1))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps * 1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 2))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 2))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 0))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 0))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 0))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 0))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + -1))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + -1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + 2], nx, ny, steps + 1))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 2], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + 0], nx, ny, steps + 1))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 0], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + 0], nx, ny, steps + 1))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + 0], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (dp[nx][ny][steps + 1], nx, ny, steps + 1))",
      "mutated_line": "heapq.heappush(pq, (dp[nx][ny][steps + -1], nx, ny, steps + 1))",
      "code": "import heapq\n\ndef minPathSumSequence(grid, k):\n    N = len(grid)\n    if k < N * N:\n        dp = [[[float('inf')] * k for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                dp[i][j][0] = grid[i][j]\n        pq = [(grid[0][0], 0, 0, 0)]\n        while pq:\n            (curr_sum, x, y, steps) = heapq.heappop(pq)\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    if steps + 1 < k and curr_sum + grid[nx][ny] < dp[nx][ny][steps + 1]:\n                        dp[nx][ny][steps + 1] = curr_sum + grid[nx][ny]\n                        heapq.heappush(pq, (dp[nx][ny][steps + -1], nx, ny, steps + 1))\n        min_sum = min((dp[i][j][k - 1] for i in range(N) for j in range(N)))\n        if min_sum == float('inf'):\n            return []\n        path = []\n        for step in range(k - 1, -1, -1):\n            for i in range(N):\n                for j in range(N):\n                    if dp[i][j][step] == min_sum:\n                        path.append(grid[i][j])\n                        min_sum -= grid[i][j]\n                        break\n                else:\n                    continue\n                break\n        return list(reversed(path))\n    else:\n        return 'The number of steps is larger than the number of cells in the grid.'"
    }
  ]
}