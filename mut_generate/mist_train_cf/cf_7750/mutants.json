{
  "task_id": "cf_7750",
  "entry_point": "parse_comments",
  "mutant_count": 12,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[0]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is not None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "comments_json = row[0]",
      "mutated_line": "comments_json = row[1]",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[1]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is not None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "comments_json = row[0]",
      "mutated_line": "comments_json = row[-1]",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[-1]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is not None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "comments_json = row[0]",
      "mutated_line": "comments_json = row[1]",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[1]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is not None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if email is not None and re.match(r\"[^@]+@[^@]+\\.[^@]+\", email):",
      "mutated_line": "if email is not None or re.match('[^@]+@[^@]+\\\\.[^@]+', email):",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[0]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is not None or re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "name = comment.get('name')",
      "mutated_line": "name = comment.get('')",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[0]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('')\n            email = comment.get('email')\n            if email is not None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "email = comment.get('email')",
      "mutated_line": "email = comment.get('')",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[0]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('')\n            if email is not None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if email is not None and re.match(r\"[^@]+@[^@]+\\.[^@]+\", email):",
      "mutated_line": "if email is None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[0]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if email is not None and re.match(r\"[^@]+@[^@]+\\.[^@]+\", email):",
      "mutated_line": "if email is not None and re.match('', email):",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[0]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is not None and re.match('', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "valid_comments.sort(key=lambda x: x['name'])",
      "mutated_line": "valid_comments.sort(key=lambda x: x[''])",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[0]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is not None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, 'email': email})\n    valid_comments.sort(key=lambda x: x[''])\n    return valid_comments"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "valid_comments.append({'name': name, 'email': email})",
      "mutated_line": "valid_comments.append({'': name, 'email': email})",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[0]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is not None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'': name, 'email': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "valid_comments.append({'name': name, 'email': email})",
      "mutated_line": "valid_comments.append({'name': name, '': email})",
      "code": "import json\nimport re\n\ndef parse_comments(rows):\n    \"\"\"\n    Parse JSON strings in the 'Comments' column of the input rows, extract the values \n    for the keys 'name' and 'email' for each comment, discard comments with invalid \n    email formats, and return a list of the extracted values sorted in alphabetical \n    order based on the 'name' key.\n\n    Args:\n        rows (list): A list of rows from a database table 'Users' with a column \n            'Comments' containing JSON strings.\n\n    Returns:\n        list: A list of dictionaries containing 'name' and 'email' values for valid comments.\n    \"\"\"\n    valid_comments = []\n    for row in rows:\n        comments_json = row[0]\n        comments = json.loads(comments_json)\n        for comment in comments:\n            name = comment.get('name')\n            email = comment.get('email')\n            if email is not None and re.match('[^@]+@[^@]+\\\\.[^@]+', email):\n                valid_comments.append({'name': name, '': email})\n    valid_comments.sort(key=lambda x: x['name'])\n    return valid_comments"
    }
  ]
}