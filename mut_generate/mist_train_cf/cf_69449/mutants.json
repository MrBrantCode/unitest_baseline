{
  "task_id": "cf_69449",
  "entry_point": "extract_integer",
  "mutant_count": 15,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\" Given a float, it separates into an integer component",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\"\"\"\"\n    if number == 0:\n        return 0\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if number == 0:",
      "mutated_line": "if number != 0:",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number != 0:\n        return 0\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if number == 0:",
      "mutated_line": "if number == 1:",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 1:\n        return 0\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if number == 0:",
      "mutated_line": "if number == -1:",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == -1:\n        return 0\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if number == 0:",
      "mutated_line": "if number == 1:",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 1:\n        return 0\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return 1\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return -1\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return 1\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "elif number == float('inf') or number == -float('inf'):",
      "mutated_line": "elif number == float('inf') and number == -float('inf'):",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return 0\n    elif number == float('inf') and number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif number == float('inf') or number == -float('inf'):",
      "mutated_line": "elif number != float('inf') or number == -float('inf'):",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return 0\n    elif number != float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif number == float('inf') or number == -float('inf'):",
      "mutated_line": "elif number == float('inf') or number != -float('inf'):",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return 0\n    elif number == float('inf') or number != -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 'Error: Number too large.'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return 0\n    elif number == float('inf') or number == -float('inf'):\n        return ''\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "elif number == float('inf') or number == -float('inf'):",
      "mutated_line": "elif number == float('inf') or number == +float('inf'):",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return 0\n    elif number == float('inf') or number == +float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif number == float('inf') or number == -float('inf'):",
      "mutated_line": "elif number == float('') or number == -float('inf'):",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return 0\n    elif number == float('') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif number == float('inf') or number == -float('inf'):",
      "mutated_line": "elif number == float('inf') or number == -float(''):",
      "code": "import math\n\ndef extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component \n    (the largest integer less than or equal to the given number) and decimals \n    (remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    \"\"\"\n    if number == 0:\n        return 0\n    elif number == float('inf') or number == -float(''):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
    }
  ]
}