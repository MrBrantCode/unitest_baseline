{
  "task_id": "cf_61786",
  "entry_point": "shortest_path",
  "mutant_count": 110,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return +1"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 1 or y == n - 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 or y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited = {(0, 0): k}",
      "mutated_line": "visited = {(1, 0): k}",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(1, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited = {(0, 0): k}",
      "mutated_line": "visited = {(-1, 0): k}",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(-1, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited = {(0, 0): k}",
      "mutated_line": "visited = {(1, 0): k}",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(1, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited = {(0, 0): k}",
      "mutated_line": "visited = {(0, 1): k}",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 1): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited = {(0, 0): k}",
      "mutated_line": "visited = {(0, -1): k}",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, -1): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited = {(0, 0): k}",
      "mutated_line": "visited = {(0, 1): k}",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 1): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x != m - 1 and y == n - 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x != m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 1 and y != n - 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y != n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m or 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[-1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1),(0,-1),(1,0),(-1,0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deque = collections.deque([(0, 0, 0, k)])",
      "mutated_line": "deque = collections.deque([(1, 0, 0, k)])",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(1, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deque = collections.deque([(0, 0, 0, k)])",
      "mutated_line": "deque = collections.deque([(-1, 0, 0, k)])",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(-1, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deque = collections.deque([(0, 0, 0, k)])",
      "mutated_line": "deque = collections.deque([(1, 0, 0, k)])",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(1, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deque = collections.deque([(0, 0, 0, k)])",
      "mutated_line": "deque = collections.deque([(0, 1, 0, k)])",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 1, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deque = collections.deque([(0, 0, 0, k)])",
      "mutated_line": "deque = collections.deque([(0, -1, 0, k)])",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, -1, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deque = collections.deque([(0, 0, 0, k)])",
      "mutated_line": "deque = collections.deque([(0, 1, 0, k)])",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 1, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deque = collections.deque([(0, 0, 0, k)])",
      "mutated_line": "deque = collections.deque([(0, 0, 1, k)])",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 1, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deque = collections.deque([(0, 0, 0, k)])",
      "mutated_line": "deque = collections.deque([(0, 0, -1, k)])",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, -1, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deque = collections.deque([(0, 0, 0, k)])",
      "mutated_line": "deque = collections.deque([(0, 0, 1, k)])",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 1, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m + 1 and y == n - 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m + 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m * 1 and y == n - 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m * 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 1 and y == n + 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n + 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 1 and y == n * 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n * 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 < ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 > ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 == ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nextK = remainingK - grid[nx][ny]",
      "mutated_line": "nextK = remainingK + grid[nx][ny]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK + grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nextK = remainingK - grid[nx][ny]",
      "mutated_line": "nextK = remainingK * grid[nx][ny]",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK * grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if (nextK >= 0 and (nx, ny) not in visited) and nextK > visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if (nextK >= 0 and (nx, ny) not in visited) and nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 2 and y == n - 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 2 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 0 and y == n - 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 0 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 0 and y == n - 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 0 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - -1 and y == n - 1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - -1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 1 and y == n - 2:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 2:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 1 and y == n - 0:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 0:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 1 and y == n - 0:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 0:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == m-1 and y == n-1:",
      "mutated_line": "if x == m - 1 and y == n - -1:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - -1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and -1 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n:",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if (nextK >= 0 or (nx, ny) not in visited) or nextK > visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if (nextK >= 0 or (nx, ny) not in visited) or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 0 and (nx, ny) not in visited or nextK >= visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK >= visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 0 and (nx, ny) not in visited or nextK <= visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK <= visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 0 and (nx, ny) not in visited or nextK != visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK != visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK > 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK > 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK < 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK < 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK == 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK == 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 0 and (nx, ny) in visited or nextK > visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 1 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 1 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= -1 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= -1 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 1 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 1 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), +1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), +1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "deque.append((nx, ny, steps+1, nextK))",
      "mutated_line": "deque.append((nx, ny, steps - 1, nextK))",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps - 1, nextK))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "deque.append((nx, ny, steps+1, nextK))",
      "mutated_line": "deque.append((nx, ny, steps * 1, nextK))",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps * 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -2):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -2):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -0):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -0):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -0):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -0):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):",
      "mutated_line": "if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), --1):",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), --1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 1, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "deque.append((nx, ny, steps+1, nextK))",
      "mutated_line": "deque.append((nx, ny, steps + 2, nextK))",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 2, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "deque.append((nx, ny, steps+1, nextK))",
      "mutated_line": "deque.append((nx, ny, steps + 0, nextK))",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 0, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "deque.append((nx, ny, steps+1, nextK))",
      "mutated_line": "deque.append((nx, ny, steps + 0, nextK))",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + 0, nextK))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "deque.append((nx, ny, steps+1, nextK))",
      "mutated_line": "deque.append((nx, ny, steps + -1, nextK))",
      "code": "import collections\n\ndef shortest_path(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    deque = collections.deque([(0, 0, 0, k)])\n    visited = {(0, 0): k}\n    while deque:\n        (x, y, steps, remainingK) = deque.popleft()\n        if x == m - 1 and y == n - 1:\n            return steps\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                nextK = remainingK - grid[nx][ny]\n                if nextK >= 0 and (nx, ny) not in visited or nextK > visited.get((nx, ny), -1):\n                    visited[nx, ny] = nextK\n                    deque.append((nx, ny, steps + -1, nextK))\n    return -1"
    }
  ]
}