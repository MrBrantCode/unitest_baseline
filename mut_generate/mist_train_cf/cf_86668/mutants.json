{
  "task_id": "cf_86668",
  "entry_point": "find_shortest_path",
  "mutant_count": 122,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist[tuple(start)] = 0",
      "mutated_line": "dist[tuple(start)] = 1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 1\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist[tuple(start)] = 0",
      "mutated_line": "dist[tuple(start)] = -1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = -1\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist[tuple(start)] = 0",
      "mutated_line": "dist[tuple(start)] = 1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 1\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if current == end:",
      "mutated_line": "if current != end:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current != end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "dist = {(i, j): float('') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(1, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(-1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(-1, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(1, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) or 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) or 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] - movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] - movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] * movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] * movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[1] - movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] - movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[1] * movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] * movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 < new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 < new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 > new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 > new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 == new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 == new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 < new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 < new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 > new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 > new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 == new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 == new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_distance = current_dist + matrix[new_i][new_j]",
      "mutated_line": "if new_distance < dist[new_i, new_j]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist - matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_distance = current_dist + matrix[new_i][new_j]",
      "mutated_line": "if new_distance < dist[new_i, new_j]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist * matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if new_distance < dist[(new_i, new_j)]:",
      "mutated_line": "dist[new_i, new_j] = new_distance",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance <= dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if new_distance < dist[(new_i, new_j)]:",
      "mutated_line": "dist[new_i, new_j] = new_distance",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance >= dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if new_distance < dist[(new_i, new_j)]:",
      "mutated_line": "dist[new_i, new_j] = new_distance",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance != dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if -1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if -1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 1 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 1 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and -1 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and -1 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 1 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 1 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[-1]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[-1]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[1] + movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[1] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[-1] + movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[-1] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[1] + movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[1] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[1], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[1], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[-1], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[-1], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[1], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[1], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[2] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[2] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[0] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[0] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[0] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[0] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[-1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[-1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[1] + movement[2])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[2])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[1] + movement[0])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[0])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[1] + movement[0])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[0])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new_i, new_j = current[0] + movement[0], current[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current[0] + movement[0], current[1] + movement[-1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[-1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[1]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[1]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[-1]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[-1]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[1]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function implements Dijkstra's algorithm to find the shortest path \n    between a start point and an end point in a given 2D matrix. The function \n    considers diagonal movement as a valid option and returns -1 if there is no \n    valid path between the start and end points.\n\n    Args:\n        matrix (list): A 2D list of non-negative integers.\n        start (list): The start point coordinates in the matrix.\n        end (list): The end point coordinates in the matrix.\n\n    Returns:\n        int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        for movement in movements:\n            (new_i, new_j) = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[1]):\n                new_distance = current_dist + matrix[new_i][new_j]\n                if new_distance < dist[new_i, new_j]:\n                    dist[new_i, new_j] = new_distance\n                    heapq.heappush(pq, (new_distance, (new_i, new_j)))\n    return -1"
    }
  ]
}