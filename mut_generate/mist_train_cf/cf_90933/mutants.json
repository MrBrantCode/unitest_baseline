{
  "task_id": "cf_90933",
  "entry_point": "find_shortest_path",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[0]][start[1]] = 1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 1\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[0]][start[1]] = -1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = -1\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[0]][start[1]] = 1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 1\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "return -1  # No path found",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "distances = [[float('inf')] * cols for _ in range(rows)]",
      "mutated_line": "distances = [[float('inf')] / cols for _ in range(rows)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] / cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "distances = [[float('inf')] * cols for _ in range(rows)]",
      "mutated_line": "distances = [[float('inf')] + cols for _ in range(rows)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] + cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "distances = [[float('inf')] * cols for _ in range(rows)]",
      "mutated_line": "distances = [[float('inf')] ** cols for _ in range(rows)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] ** cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if current == end:",
      "mutated_line": "if current != end:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current != end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist >= distances[current[0]][current[1]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist >= distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist <= distances[current[0]][current[1]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist <= distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist != distances[current[0]][current[1]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist != distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1  # No path found",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1  # No path found",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1  # No path found",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1  # No path found",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[0]][start[2]] = 0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[2]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[0]][start[0]] = 0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[0]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[0]][start[0]] = 0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[0]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[0]][start[-1]] = 0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[-1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(1, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(-1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(-1, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(1, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 <= nx < rows or 0 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows or 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(matrix), len(matrix[0])",
      "mutated_line": "(rows, cols) = (len(matrix), len(matrix[1]))",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[1]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(matrix), len(matrix[0])",
      "mutated_line": "(rows, cols) = (len(matrix), len(matrix[-1]))",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[-1]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(matrix), len(matrix[0])",
      "mutated_line": "(rows, cols) = (len(matrix), len(matrix[1]))",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[1]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[1]][start[1]] = 0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[1]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[-1]][start[1]] = 0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[-1]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start[0]][start[1]] = 0",
      "mutated_line": "distances[start[1]][start[1]] = 0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[1]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[0] - dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] - dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[0] * dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] * dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] - dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] - dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] * dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] * dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 < nx < rows and 0 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 < nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 > nx < rows and 0 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 > nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 == nx < rows and 0 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 == nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 <= nx < rows and 0 < ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 < ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 <= nx < rows and 0 > ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 > ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 <= nx < rows and 0 == ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 == ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new_dist = dist + matrix[nx][ny]",
      "mutated_line": "new_dist = dist - matrix[nx][ny]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist - matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new_dist = dist + matrix[nx][ny]",
      "mutated_line": "new_dist = dist * matrix[nx][ny]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist * matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if new_dist < distances[nx][ny]:",
      "mutated_line": "if new_dist <= distances[nx][ny]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist <= distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if new_dist < distances[nx][ny]:",
      "mutated_line": "if new_dist >= distances[nx][ny]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist >= distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if new_dist < distances[nx][ny]:",
      "mutated_line": "if new_dist != distances[nx][ny]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist != distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances = [[float('inf')] * cols for _ in range(rows)]",
      "mutated_line": "distances = [[float('')] * cols for _ in range(rows)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist > distances[current[0]][current[2]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[2]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist > distances[current[0]][current[0]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[0]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist > distances[current[0]][current[0]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[0]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist > distances[current[0]][current[-1]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[-1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 1 <= nx < rows and 0 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 1 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if -1 <= nx < rows and 0 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if -1 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 1 <= nx < rows and 0 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 1 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 <= nx < rows and 1 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 1 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 <= nx < rows and -1 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and -1 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols:",
      "mutated_line": "if 0 <= nx < rows and 1 <= ny < cols:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 1 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist > distances[current[1]][current[1]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[1]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist > distances[current[-1]][current[1]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[-1]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist > distances[current[0]][current[1]]:",
      "mutated_line": "if dist > distances[current[1]][current[1]]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[1]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[1] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[1] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[-1] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[-1] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[1] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[1] + dx, current[1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[2] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[2] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[0] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[0] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[0] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[0] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx, ny = current[0] + dx, current[1] + dy",
      "mutated_line": "(nx, ny) = (current[0] + dx, current[-1] + dy)",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    pq = [(0, start)]\n    while pq:\n        (dist, current) = heapq.heappop(pq)\n        if current == end:\n            return dist\n        if dist > distances[current[0]][current[1]]:\n            continue\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (current[0] + dx, current[-1] + dy)\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_dist = dist + matrix[nx][ny]\n                if new_dist < distances[nx][ny]:\n                    distances[nx][ny] = new_dist\n                    heapq.heappush(pq, (new_dist, (nx, ny)))\n    return -1"
    }
  ]
}