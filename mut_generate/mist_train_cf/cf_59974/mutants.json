{
  "task_id": "cf_59974",
  "entry_point": "total_match",
  "mutant_count": 13,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def total_match(lst1, lst2, case_sensitive=False):",
      "mutated_line": "def total_match(lst1, lst2, case_sensitive=True):",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=True):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "mutated_line": "return lst1 if sum((len(s) for s in lst1)) < sum((len(s) for s in lst2)) else lst2",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) < sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "mutated_line": "return lst1 if sum((len(s) for s in lst1)) > sum((len(s) for s in lst2)) else lst2",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) > sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "mutated_line": "return lst1 if sum((len(s) for s in lst1)) == sum((len(s) for s in lst2)) else lst2",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) == sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]",
      "mutated_line": "lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('', '', s) for s in lst1]",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]",
      "mutated_line": "lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', 'MUTATED', s) for s in lst1]",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', 'MUTATED', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]",
      "mutated_line": "lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('', '', s) for s in lst2]",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]",
      "mutated_line": "lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', 'MUTATED', s) for s in lst2]",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', 'MUTATED', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]",
      "mutated_line": "lst1 = [re.sub('', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]",
      "mutated_line": "lst1 = [re.sub('\\\\W+', 'MUTATED', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', 'MUTATED', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]",
      "mutated_line": "lst2 = [re.sub('', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]",
      "mutated_line": "lst2 = [re.sub('\\\\W+', 'MUTATED', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]",
      "code": "import re\n\ndef total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n    \"\"\"\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', 'MUTATED', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    (lst1, lst2) = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
    }
  ]
}