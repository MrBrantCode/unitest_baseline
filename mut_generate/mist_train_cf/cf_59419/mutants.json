{
  "task_id": "cf_59419",
  "entry_point": "rapidFoxSimulation",
  "mutant_count": 147,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 and n <= 0 and (t < 0):\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 and startX >= m and (startY < 0) and (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if (startX, startY) in obstacles:",
      "mutated_line": "if (startX, startY) not in obstacles:",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) not in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "grid[startX][startY] = t + 1",
      "mutated_line": "grid[startX][startY] = t - 1",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t - 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "grid[startX][startY] = t + 1",
      "mutated_line": "grid[startX][startY] = t * 1",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t * 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m < 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m > 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m == 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n < 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n > 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n == 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t <= 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t >= 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t != 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return \"Invalid grid dimensions or time step\"",
      "mutated_line": "return ''",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return ''\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX <= 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX >= 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX != 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX > m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX < m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX == m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY <= 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY >= 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY != 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY > n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY < n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY == n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return \"Invalid starting position\"",
      "mutated_line": "for (x, y) in obstacles:",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return ''\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 and x >= m and (y < 0) and (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return \"Starting position can't be an obstacle\"",
      "mutated_line": "return ''",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return ''\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "grid = [[0]*n for _ in range(m)]",
      "mutated_line": "for (x, y) in obstacles:",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] / n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "grid = [[0]*n for _ in range(m)]",
      "mutated_line": "for (x, y) in obstacles:",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] + n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "grid = [[0]*n for _ in range(m)]",
      "mutated_line": "for (x, y) in obstacles:",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] ** n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "grid[x][y] = -1",
      "mutated_line": "grid[x][y] = +1",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = +1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "grid[startX][startY] = t + 1",
      "mutated_line": "grid[startX][startY] = t + 2",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 2\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "grid[startX][startY] = t + 1",
      "mutated_line": "grid[startX][startY] = t + 0",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 0\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "grid[startX][startY] = t + 1",
      "mutated_line": "grid[startX][startY] = t + 0",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 0\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "grid[startX][startY] = t + 1",
      "mutated_line": "grid[startX][startY] = t + -1",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + -1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 1 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= -1 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 1 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 1 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= -1 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 1 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 1:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < -1:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if m <= 0 or n <= 0 or t < 0:",
      "mutated_line": "return 'Invalid grid dimensions or time step'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 1:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 1 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < -1 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 1 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 1 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < -1 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if startX < 0 or startX >= m or startY < 0 or startY >= n:",
      "mutated_line": "return 'Invalid starting position'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 1 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x <= 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x >= 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x != 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x > m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x < m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x == m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y <= 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y >= 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y != 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y > n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y < n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y == n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return \"Invalid obstacles\"",
      "mutated_line": "return ''",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return ''\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "grid[x][y] = -1",
      "mutated_line": "grid[x][y] = -2",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -2\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "grid[x][y] = -1",
      "mutated_line": "grid[x][y] = -0",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -0\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "grid[x][y] = -1",
      "mutated_line": "grid[x][y] = -0",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -0\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "grid[x][y] = -1",
      "mutated_line": "grid[x][y] = --1",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = --1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n or grid[nx][ny] < grid[x][y] - 1:",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m or 0 <= ny < n or grid[nx][ny] < grid[x][y] - 1:\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]",
      "mutated_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] >= 0]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] >= 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]",
      "mutated_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] <= 0]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] <= 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]",
      "mutated_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] != 0]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] != 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 1 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < -1 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 1 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 1 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < -1 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n:",
      "mutated_line": "return 'Invalid obstacles'",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 1 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "grid = [[0]*n for _ in range(m)]",
      "mutated_line": "for (x, y) in obstacles:",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[1] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "grid = [[0]*n for _ in range(m)]",
      "mutated_line": "for (x, y) in obstacles:",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[-1] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "grid = [[0]*n for _ in range(m)]",
      "mutated_line": "for (x, y) in obstacles:",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[1] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "direction = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 < ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 > ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 == ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] <= grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] <= grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] >= grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] >= grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "grid[nx][ny] = grid[x][y] - 1",
      "mutated_line": "grid[nx][ny] = grid[x][y] + 1",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] + 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "grid[nx][ny] = grid[x][y] - 1",
      "mutated_line": "grid[nx][ny] = grid[x][y] * 1",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] * 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]",
      "mutated_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 1]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 1]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]",
      "mutated_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > -1]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > -1]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]",
      "mutated_line": "reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 1]",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 1]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and -1 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] + 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] + 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] * 1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] * 1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "grid[nx][ny] = grid[x][y] - 1",
      "mutated_line": "grid[nx][ny] = grid[x][y] - 2",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 2\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "grid[nx][ny] = grid[x][y] - 1",
      "mutated_line": "grid[nx][ny] = grid[x][y] - 0",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 0\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "grid[nx][ny] = grid[x][y] - 1",
      "mutated_line": "grid[nx][ny] = grid[x][y] - 0",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - 0\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "grid[nx][ny] = grid[x][y] - 1",
      "mutated_line": "grid[nx][ny] = grid[x][y] - -1",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 1):\n                grid[nx][ny] = grid[x][y] - -1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 2):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 2):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 0):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 0):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 0):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - 0):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] < grid[x][y] - 1:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - -1):",
      "code": "from queue import Queue\n\ndef rapidFoxSimulation(m, n, t, startX, startY, obstacles):\n    if m <= 0 or n <= 0 or t < 0:\n        return 'Invalid grid dimensions or time step'\n    if startX < 0 or startX >= m or startY < 0 or (startY >= n):\n        return 'Invalid starting position'\n    for (x, y) in obstacles:\n        if x < 0 or x >= m or y < 0 or (y >= n):\n            return 'Invalid obstacles'\n    if (startX, startY) in obstacles:\n        return \"Starting position can't be an obstacle\"\n    grid = [[0] * n for _ in range(m)]\n    for (x, y) in obstacles:\n        grid[x][y] = -1\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = Queue()\n    queue.put((startX, startY))\n    grid[startX][startY] = t + 1\n    while not queue.empty():\n        (x, y) = queue.get()\n        for (dx, dy) in direction:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] < grid[x][y] - -1):\n                grid[nx][ny] = grid[x][y] - 1\n                queue.put((nx, ny))\n    reachable_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] > 0]\n    return reachable_cells"
    }
  ]
}