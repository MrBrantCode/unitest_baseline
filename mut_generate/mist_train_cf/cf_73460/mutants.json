{
  "task_id": "cf_73460",
  "entry_point": "sort",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def sort(arr, ascending=True):",
      "mutated_line": "def sort(arr, ascending=False):",
      "code": "def sort(arr, ascending=False):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if start < end:",
      "mutated_line": "if start <= end:",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start <= end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if start < end:",
      "mutated_line": "if start >= end:",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start >= end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if start < end:",
      "mutated_line": "if start != end:",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start != end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = (start - 1)",
      "mutated_line": "i = start + 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start + 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = (start - 1)",
      "mutated_line": "i = start * 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start * 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "comparison = 0",
      "mutated_line": "comparison = 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 1\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "comparison = 0",
      "mutated_line": "comparison = -1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = -1\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "comparison = 0",
      "mutated_line": "comparison = 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 1\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swap = 0",
      "mutated_line": "swap = 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 1\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swap = 0",
      "mutated_line": "swap = -1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = -1\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swap = 0",
      "mutated_line": "swap = 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 1\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "comparison += 1",
      "mutated_line": "comparison -= 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison -= 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c, s = quicksort(arr, 0, n - 1, ascending)",
      "mutated_line": "(c, s) = quicksort(arr, 1, n - 1, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 1, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c, s = quicksort(arr, 0, n - 1, ascending)",
      "mutated_line": "(c, s) = quicksort(arr, -1, n - 1, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, -1, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c, s = quicksort(arr, 0, n - 1, ascending)",
      "mutated_line": "(c, s) = quicksort(arr, 1, n - 1, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 1, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "c, s = quicksort(arr, 0, n - 1, ascending)",
      "mutated_line": "(c, s) = quicksort(arr, 0, n + 1, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n + 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "c, s = quicksort(arr, 0, n - 1, ascending)",
      "mutated_line": "(c, s) = quicksort(arr, 0, n * 1, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n * 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (start - 1)",
      "mutated_line": "i = start - 2",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 2\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (start - 1)",
      "mutated_line": "i = start - 0",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 0\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (start - 1)",
      "mutated_line": "i = start - 0",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 0\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (start - 1)",
      "mutated_line": "i = start - -1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - -1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "comparison += 1",
      "mutated_line": "comparison += 2",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 2\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "comparison += 1",
      "mutated_line": "comparison += 0",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 0\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "comparison += 1",
      "mutated_line": "comparison += 0",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 0\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "comparison += 1",
      "mutated_line": "comparison += -1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += -1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if (arr[j] <= pivot and ascending) or (arr[j] >= pivot and not ascending):",
      "mutated_line": "if (arr[j] <= pivot and ascending) and (arr[j] >= pivot and (not ascending)):",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if (arr[j] <= pivot and ascending) and (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "swap += 1",
      "mutated_line": "swap -= 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap -= 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i - 1, comparison, swap + 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i - 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i * 1, comparison, swap + 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i * 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + 1, comparison, swap - 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap - 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + 1, comparison, swap * 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap * 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c, s = quicksort(arr, 0, n - 1, ascending)",
      "mutated_line": "(c, s) = quicksort(arr, 0, n - 2, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 2, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c, s = quicksort(arr, 0, n - 1, ascending)",
      "mutated_line": "(c, s) = quicksort(arr, 0, n - 0, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 0, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c, s = quicksort(arr, 0, n - 1, ascending)",
      "mutated_line": "(c, s) = quicksort(arr, 0, n - 0, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 0, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c, s = quicksort(arr, 0, n - 1, ascending)",
      "mutated_line": "(c, s) = quicksort(arr, 0, n - -1, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - -1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lc, ls = quicksort(arr, start, pi - 1, ascending)",
      "mutated_line": "(lc, ls) = quicksort(arr, start, pi + 1, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi + 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lc, ls = quicksort(arr, start, pi - 1, ascending)",
      "mutated_line": "(lc, ls) = quicksort(arr, start, pi * 1, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi * 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "rc, rs = quicksort(arr, pi + 1, end, ascending)",
      "mutated_line": "(rc, rs) = quicksort(arr, pi - 1, end, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi - 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "rc, rs = quicksort(arr, pi + 1, end, ascending)",
      "mutated_line": "(rc, rs) = quicksort(arr, pi * 1, end, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi * 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (comparison + lc + rc, swap + ls + rs)",
      "mutated_line": "return (comparison + lc - rc, swap + ls + rs)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc - rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (comparison + lc + rc, swap + ls + rs)",
      "mutated_line": "return ((comparison + lc) * rc, swap + ls + rs)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return ((comparison + lc) * rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (comparison + lc + rc, swap + ls + rs)",
      "mutated_line": "return (comparison + lc + rc, swap + ls - rs)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls - rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (comparison + lc + rc, swap + ls + rs)",
      "mutated_line": "return (comparison + lc + rc, (swap + ls) * rs)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, (swap + ls) * rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0, 0",
      "mutated_line": "return (1, 0)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (1, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0, 0",
      "mutated_line": "return (-1, 0)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (-1, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0, 0",
      "mutated_line": "return (1, 0)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (1, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0, 0",
      "mutated_line": "return (0, 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 1)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0, 0",
      "mutated_line": "return (0, -1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, -1)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0, 0",
      "mutated_line": "return (0, 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 1)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if (arr[j] <= pivot and ascending) or (arr[j] >= pivot and not ascending):",
      "mutated_line": "if (arr[j] <= pivot or ascending) or (arr[j] >= pivot and (not ascending)):",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if (arr[j] <= pivot or ascending) or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if (arr[j] <= pivot and ascending) or (arr[j] >= pivot and not ascending):",
      "mutated_line": "if arr[j] <= pivot and ascending or (arr[j] >= pivot or not ascending):",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot or not ascending):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = i + 1",
      "mutated_line": "i = i - 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i - 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = i + 1",
      "mutated_line": "i = i * 1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i * 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "swap += 1",
      "mutated_line": "swap += 2",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 2\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "swap += 1",
      "mutated_line": "swap += 0",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 0\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "swap += 1",
      "mutated_line": "swap += 0",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 0\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "swap += 1",
      "mutated_line": "swap += -1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += -1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i - 1], arr[end]) = (arr[end], arr[i + 1])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i - 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i * 1], arr[end]) = (arr[end], arr[i + 1])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i * 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + 1], arr[end]) = (arr[end], arr[i - 1])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i - 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + 1], arr[end]) = (arr[end], arr[i * 1])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i * 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + 2, comparison, swap + 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 2, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + 0, comparison, swap + 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 0, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + 0, comparison, swap + 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 0, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + -1, comparison, swap + 1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + -1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + 1, comparison, swap + 2)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 2)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + 1, comparison, swap + 0)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 0)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + 1, comparison, swap + 0)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 0)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (i + 1, comparison, swap + 1)",
      "mutated_line": "return (i + 1, comparison, swap + -1)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + -1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lc, ls = quicksort(arr, start, pi - 1, ascending)",
      "mutated_line": "(lc, ls) = quicksort(arr, start, pi - 2, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 2, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lc, ls = quicksort(arr, start, pi - 1, ascending)",
      "mutated_line": "(lc, ls) = quicksort(arr, start, pi - 0, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 0, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lc, ls = quicksort(arr, start, pi - 1, ascending)",
      "mutated_line": "(lc, ls) = quicksort(arr, start, pi - 0, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 0, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lc, ls = quicksort(arr, start, pi - 1, ascending)",
      "mutated_line": "(lc, ls) = quicksort(arr, start, pi - -1, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - -1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rc, rs = quicksort(arr, pi + 1, end, ascending)",
      "mutated_line": "(rc, rs) = quicksort(arr, pi + 2, end, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 2, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rc, rs = quicksort(arr, pi + 1, end, ascending)",
      "mutated_line": "(rc, rs) = quicksort(arr, pi + 0, end, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 0, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rc, rs = quicksort(arr, pi + 1, end, ascending)",
      "mutated_line": "(rc, rs) = quicksort(arr, pi + 0, end, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 0, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rc, rs = quicksort(arr, pi + 1, end, ascending)",
      "mutated_line": "(rc, rs) = quicksort(arr, pi + -1, end, ascending)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + -1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (comparison + lc + rc, swap + ls + rs)",
      "mutated_line": "return (comparison - lc + rc, swap + ls + rs)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison - lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (comparison + lc + rc, swap + ls + rs)",
      "mutated_line": "return (comparison * lc + rc, swap + ls + rs)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison * lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (comparison + lc + rc, swap + ls + rs)",
      "mutated_line": "return (comparison + lc + rc, swap - ls + rs)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap - ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (comparison + lc + rc, swap + ls + rs)",
      "mutated_line": "return (comparison + lc + rc, swap * ls + rs)",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap * ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (arr[j] <= pivot and ascending) or (arr[j] >= pivot and not ascending):",
      "mutated_line": "if arr[j] < pivot and ascending or (arr[j] >= pivot and (not ascending)):",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] < pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (arr[j] <= pivot and ascending) or (arr[j] >= pivot and not ascending):",
      "mutated_line": "if arr[j] > pivot and ascending or (arr[j] >= pivot and (not ascending)):",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] > pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (arr[j] <= pivot and ascending) or (arr[j] >= pivot and not ascending):",
      "mutated_line": "if arr[j] == pivot and ascending or (arr[j] >= pivot and (not ascending)):",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] == pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (arr[j] <= pivot and ascending) or (arr[j] >= pivot and not ascending):",
      "mutated_line": "if arr[j] <= pivot and ascending or (arr[j] > pivot and (not ascending)):",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] > pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (arr[j] <= pivot and ascending) or (arr[j] >= pivot and not ascending):",
      "mutated_line": "if arr[j] <= pivot and ascending or (arr[j] < pivot and (not ascending)):",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] < pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (arr[j] <= pivot and ascending) or (arr[j] >= pivot and not ascending):",
      "mutated_line": "if arr[j] <= pivot and ascending or (arr[j] == pivot and (not ascending)):",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] == pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 2",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 2\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 0\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 0\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + -1",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + -1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + 2], arr[end]) = (arr[end], arr[i + 1])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 2], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + 0], arr[end]) = (arr[end], arr[i + 1])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 0], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + 0], arr[end]) = (arr[end], arr[i + 1])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 0], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + -1], arr[end]) = (arr[end], arr[i + 1])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + -1], arr[end]) = (arr[end], arr[i + 1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + 1], arr[end]) = (arr[end], arr[i + 2])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 2])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + 1], arr[end]) = (arr[end], arr[i + 0])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 0])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + 1], arr[end]) = (arr[end], arr[i + 0])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + 0])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "arr[i+1], arr[end] = arr[end], arr[i+1]",
      "mutated_line": "(arr[i + 1], arr[end]) = (arr[end], arr[i + -1])",
      "code": "def sort(arr, ascending=True):\n\n    def quicksort(arr, start, end, ascending):\n        if start < end:\n            (pi, comparison, swap) = partition(arr, start, end, ascending)\n            (lc, ls) = quicksort(arr, start, pi - 1, ascending)\n            (rc, rs) = quicksort(arr, pi + 1, end, ascending)\n            return (comparison + lc + rc, swap + ls + rs)\n        else:\n            return (0, 0)\n\n    def partition(arr, start, end, ascending):\n        i = start - 1\n        pivot = arr[end]\n        comparison = 0\n        swap = 0\n        for j in range(start, end):\n            comparison += 1\n            if arr[j] <= pivot and ascending or (arr[j] >= pivot and (not ascending)):\n                i = i + 1\n                (arr[i], arr[j]) = (arr[j], arr[i])\n                swap += 1\n        (arr[i + 1], arr[end]) = (arr[end], arr[i + -1])\n        return (i + 1, comparison, swap + 1)\n    n = len(arr)\n    (c, s) = quicksort(arr, 0, n - 1, ascending)\n    return (arr, c, s)"
    }
  ]
}