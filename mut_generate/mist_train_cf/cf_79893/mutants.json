{
  "task_id": "cf_79893",
  "entry_point": "a_star_search",
  "mutant_count": 31,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cost = {start: 0}",
      "mutated_line": "cost = {start: 1}",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 1}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cost = {start: 0}",
      "mutated_line": "cost = {start: -1}",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: -1}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cost = {start: 0}",
      "mutated_line": "cost = {start: 1}",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 1}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if current_node == goal:",
      "mutated_line": "if current_node != goal:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node != goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "open_list = [(0, start)]",
      "mutated_line": "open_list = [(1, start)]",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(1, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "open_list = [(0, start)]",
      "mutated_line": "open_list = [(-1, start)]",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(-1, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "open_list = [(0, start)]",
      "mutated_line": "open_list = [(1, start)]",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(1, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while current_node is not None:",
      "mutated_line": "while current_node is None:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "new_cost = cost[current_node] + neighbor_cost",
      "mutated_line": "new_cost = cost[current_node] - neighbor_cost",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] - neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "new_cost = cost[current_node] + neighbor_cost",
      "mutated_line": "new_cost = cost[current_node] * neighbor_cost",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] * neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 48,
      "original_line": "if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_list or new_cost < cost.get(neighbor, float('inf')):",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list or new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor not in closed_list and new_cost < cost.get(neighbor, float('inf')):",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor not in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_list and new_cost <= cost.get(neighbor, float('inf')):",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost <= cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_list and new_cost >= cost.get(neighbor, float('inf')):",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost >= cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_list and new_cost != cost.get(neighbor, float('inf')):",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost != cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 53,
      "original_line": "elif neighbor not in cost or new_cost < cost[neighbor]:",
      "mutated_line": "elif neighbor not in cost and new_cost < cost[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost and new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::+1]",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::+1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "elif neighbor not in cost or new_cost < cost[neighbor]:",
      "mutated_line": "elif neighbor in cost or new_cost < cost[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "elif neighbor not in cost or new_cost < cost[neighbor]:",
      "mutated_line": "elif neighbor not in cost or new_cost <= cost[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost <= cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "elif neighbor not in cost or new_cost < cost[neighbor]:",
      "mutated_line": "elif neighbor not in cost or new_cost >= cost[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost >= cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "elif neighbor not in cost or new_cost < cost[neighbor]:",
      "mutated_line": "elif neighbor not in cost or new_cost != cost[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost != cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::-2]",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-2]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::-0]",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-0]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::-0]",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-0]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::--1]",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::--1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))",
      "mutated_line": "heapq.heappush(open_list, (new_cost - heuristic(neighbor, goal), neighbor))",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost - heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))",
      "mutated_line": "heapq.heappush(open_list, (new_cost * heuristic(neighbor, goal), neighbor))",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost * heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_list and new_cost < cost.get(neighbor, float('')):",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))",
      "mutated_line": "heapq.heappush(open_list, (new_cost - heuristic(neighbor, goal), neighbor))",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost - heuristic(neighbor, goal), neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))",
      "mutated_line": "heapq.heappush(open_list, (new_cost * heuristic(neighbor, goal), neighbor))",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"\n    Performs an A* search algorithm to find the shortest path from the start node to the goal node.\n    \n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a dictionary of its neighbors and their costs.\n    start (node): The node to start the search from.\n    goal (node): The node to search for.\n    heuristic (function): A function that estimates the cost to reach the goal from a given node.\n    \n    Returns:\n    list: The shortest path from the start node to the goal node.\n    \"\"\"\n    open_list = [(0, start)]\n    closed_list = set()\n    cost = {start: 0}\n    parent = {start: None}\n    while open_list:\n        (current_cost, current_node) = heapq.heappop(open_list)\n        if current_node == goal:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = parent[current_node]\n            return path[::-1]\n        closed_list.add(current_node)\n        for (neighbor, neighbor_cost) in graph[current_node].items():\n            new_cost = cost[current_node] + neighbor_cost\n            if neighbor in closed_list and new_cost < cost.get(neighbor, float('inf')):\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), neighbor))\n            elif neighbor not in cost or new_cost < cost[neighbor]:\n                cost[neighbor] = new_cost\n                parent[neighbor] = current_node\n                heapq.heappush(open_list, (new_cost * heuristic(neighbor, goal), neighbor))\n    return None"
    }
  ]
}